{"mappings":"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","sources":["src/sketches/random_rhombus_tilings/random_rhombus_tilings.ts","src/sketches/random_rhombus_tilings/rhombus_tiling_render.ts","src/common/color_utils.ts","src/common/tag.ts","src/common/classname.ts","src/sketches/random_rhombus_tilings/rhombus_tiling.ts","src/common/perfometer.ts","src/sketches/random_rhombus_tilings/triangle_grid.ts","src/common/queue.ts","src/sketches/random_rhombus_tilings/rhombus_randomizer.binding.ts","node_modules/@parcel/runtime-js/lib/runtime-be2eac7296bd2141.js","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js"],"sourcesContent":["import {renderRhombuses} from \"sketches/random_rhombus_tilings/rhombus_tiling_render\"\nimport {getEmptyRhombusPattern, tileWithRandomRhombuses} from \"sketches/random_rhombus_tilings/rhombus_tiling\"\nimport {transformColorHsl} from \"common/color_utils\"\nimport {performeter} from \"common/perfometer\"\nimport {getWasmRhombusRandomiser} from \"sketches/random_rhombus_tilings/rhombus_randomizer.binding\"\n\nconst colors = [0x53bc01, 0xffeb03, 0xffa801, 0xf93a1d, 0xe21a5f, 0x572c62, 0xa1ccd3, 0x006898]\n\nexport function main(container: HTMLElement): void {\n\tgetWasmRhombusRandomiser().then(x => console.log(x.addTwoNumbers(2, 3)))\n\tperformeter.enterBlock(\"initializing\")\n\tconst grid = getEmptyRhombusPattern({width: 25, height: 25, length: 25})\n\n\tperformeter.exitEnterBlock(\"randomizing\")\n\ttileWithRandomRhombuses(grid)\n\n\tperformeter.exitEnterBlock(\"drawing\")\n\n\tconst color = colors[Math.floor(Math.random() * colors.length)]!\n\n\tconst svg = renderRhombuses({\n\t\thorisontalColor: transformColorHsl(color, ([h, s, l]) => [h, s * 1.1, l]),\n\t\tleftColor: transformColorHsl(color, ([h, s, l]) => [h, s * 0.9, l * 0.9]),\n\t\trightColor: transformColorHsl(color, ([h, s, l]) => [h, s * 0.9, l * 0.8]),\n\t\tcellSize: {\n\t\t\tx: 10,\n\t\t\ty: 10\n\t\t},\n\t\tgrid\n\t})\n\tsvg.style.margin = \"100px 500px\"\n\tcontainer.appendChild(svg)\n\n\tperformeter.exitBlock()\n\tperformeter.print()\n}","import {rgbNumberToColorString} from \"common/color_utils\"\nimport {svgTag} from \"common/tag\"\nimport {RhombusGrid} from \"sketches/random_rhombus_tilings/rhombus_tiling\"\nimport {TriangleGrid, XY} from \"sketches/random_rhombus_tilings/triangle_grid\"\n\ninterface Props {\n\treadonly cellSize: XY\n\treadonly horisontalColor: number\n\treadonly leftColor: number\n\treadonly rightColor: number\n\treadonly grid: RhombusGrid\n}\n\nexport const renderRhombuses = (props: Props): SVGSVGElement => {\n\tconst grid = props.grid\n\tconst svg = svgTag({tagName: \"svg\"})\n\n\tsvg.setAttribute(\"width\", grid.xWidth + \"\")\n\tsvg.setAttribute(\"height\", grid.yHeight + \"\")\n\tsvg.setAttribute(\"viewBox\", `-1 -1 ${grid.xWidth + 1} ${grid.yHeight + 0.5}`)\n\tsvg.style.width = ((grid.xWidth + 1) * props.cellSize.x) + \"px\"\n\tsvg.style.height = ((grid.yHeight + 0.5) * props.cellSize.y) + \"px\"\n\n\tconst strokeWidth = 2 / (props.cellSize.x + props.cellSize.y)\n\tconst makePathMaker = (color: number, expr: (x: number, y: number) => string) => (x: number, y: number): SVGPathElement => {\n\t\tlet offset = grid.getVerticalOffset(Math.max(0, Math.min(grid.xWidth - 1, x)))\n\t\tif(x < 0 || x >= grid.xWidth){\n\t\t\toffset += 0.5\n\t\t}\n\t\treturn svgTag({\n\t\t\ttagName: \"path\",\n\t\t\tattrs: {\n\t\t\t\td: expr(x, y + offset),\n\t\t\t\tfill: rgbNumberToColorString(color),\n\t\t\t\t// strokes are only required to fill small gaps between the elements\n\t\t\t\t// if all the lines were cardinal - there would be no gaps, but they are not\n\t\t\t\tstroke: rgbNumberToColorString(color),\n\t\t\t\t\"stroke-width\": strokeWidth\n\t\t\t}\n\t\t})\n\t}\n\n\tconst makeLeft = makePathMaker(\n\t\tprops.leftColor,\n\t\t(x, y) => `M ${x} ${y} V ${y - 1} L ${x - 1} ${y - 0.5} V ${y + 0.5} z`)\n\n\tconst makeRight = makePathMaker(\n\t\tprops.rightColor,\n\t\t(x, y) => `M ${x} ${y} V ${y - 1} L ${x + 1} ${y - 0.5} V ${y + 0.5} z`)\n\n\tconst makeBottom = makePathMaker(\n\t\tprops.horisontalColor,\n\t\t(x, y) => `M ${x} ${y} L ${x - 1} ${y + 0.5} L ${x} ${y + 1} L ${x + 1} ${y + 0.5} z`)\n\n\tfor(const {x, y, value: {leftIsSolid, rightIsSolid, bottomIsSolid}} of props.grid){\n\t\tif(leftIsSolid){\n\t\t\tsvg.appendChild(makeLeft(x, y))\n\t\t}\n\t\tif(rightIsSolid){\n\t\t\tsvg.appendChild(makeRight(x, y))\n\t\t}\n\t\tif(bottomIsSolid){\n\t\t\tsvg.appendChild(makeBottom(x, y))\n\t\t}\n\t}\n\n\t// filling borders\n\tgrid.exploreFrom(grid.getTopCornerCoords(), xy => {\n\t\tgrid.get(xy).leftIsSolid || svg.appendChild(makeBottom(xy.x, xy.y - 1))\n\t\treturn [grid.getBottomLeftOf(xy)]\n\t})\n\n\tgrid.exploreFrom(grid.getTopCornerCoords(), xy => {\n\t\tgrid.get(xy).rightIsSolid || svg.appendChild(makeBottom(xy.x, xy.y - 1))\n\t\treturn [grid.getBottomRightOf(xy)]\n\t})\n\n\tgrid.exploreFrom(grid.getRightBottomCornerCoords(), xy => {\n\t\tgrid.get(xy).rightIsSolid || svg.appendChild(makeLeft(xy.x + 1, xy.y))\n\t\treturn [grid.getTopOf(xy)]\n\t})\n\n\tgrid.exploreFrom(grid.getRightBottomCornerCoords(), xy => {\n\t\tgrid.get(xy).bottomIsSolid || svg.appendChild(makeLeft(xy.x + 1, xy.y))\n\t\treturn [grid.getBottomLeftOf(xy)]\n\t})\n\n\tgrid.exploreFrom(grid.getLeftBottomCornerCoords(), xy => {\n\t\tgrid.get(xy).bottomIsSolid || svg.appendChild(makeRight(xy.x - 1, xy.y))\n\t\treturn [grid.getBottomRightOf(xy)]\n\t})\n\n\tgrid.exploreFrom(grid.getLeftBottomCornerCoords(), xy => {\n\t\tgrid.get(xy).leftIsSolid || svg.appendChild(makeRight(xy.x - 1, xy.y))\n\t\treturn [grid.getTopOf(xy)]\n\t})\n\n\t// debug dots\n\t// for(const {x, y} of grid){\n\t// \tsvg.appendChild(svgTag({tagName: \"circle\", attrs: {\n\t// \t\tcx: x, cy: y + grid.getVerticalOffset(x), r: 0.1, fill: \"white\", stroke: \"none\"\n\t// \t}}))\n\t// }\n\n\treturn svg\n}\n\n// that's mostly for debug\nexport const renderRhombusDots = (grid: TriangleGrid<unknown>): SVGSVGElement => {\n\tconst cellSizePx = 20\n\tconst dotSizePx = 10\n\n\tconst svg = svgTag({tagName: \"svg\"})\n\tsvg.setAttribute(\"width\", grid.xWidth + \"\")\n\tsvg.setAttribute(\"height\", grid.yHeight + \"\")\n\tsvg.setAttribute(\"viewBox\", `-1 -1 ${grid.xWidth + 1} ${grid.yHeight + 1}`)\n\tsvg.style.width = (grid.xWidth * cellSizePx) + \"px\"\n\tsvg.style.height = (grid.yHeight * cellSizePx) + \"px\"\n\n\tconst findDot = ({x, y}: XY): SVGCircleElement | null => {\n\t\tconst el = svg.getElementById(`circle-${x}-${y}`)\n\t\treturn el instanceof SVGCircleElement ? el : null\n\t}\n\n\tconst setColor = (xy: XY, color: string) => {\n\t\tconst dot = findDot(xy)\n\t\tif(dot){\n\t\t\tdot.style.fill = color\n\t\t}\n\t}\n\n\tconst showNeighbours = (xy: XY) => grid.getValidNeighbourCoords(xy)\n\t\t.forEach(xy => setColor(xy, \"red\"))\n\n\tconst hideNeighbours = (xy: XY) => grid.getValidNeighbourCoords(xy)\n\t\t.forEach(xy => setColor(xy, \"white\"))\n\n\tfor(const xy of grid){\n\t\tconst circle = svgTag({\n\t\t\ttagName: \"circle\",\n\t\t\tattrs: {\n\t\t\t\tid: `circle-${xy.x}-${xy.y}`,\n\t\t\t\tcx: xy.x,\n\t\t\t\tcy: grid.getVerticalOffset(xy.x) + xy.y,\n\t\t\t\tr: dotSizePx / cellSizePx,\n\t\t\t\tfill: \"white\",\n\t\t\t\tstroke: \"none\"\n\t\t\t}\n\t\t})\n\n\t\tcircle.addEventListener(\"mouseover\", () => showNeighbours(xy))\n\t\tcircle.addEventListener(\"mouseout\", () => hideNeighbours(xy))\n\n\t\tsvg.appendChild(circle)\n\t}\n\n\treturn svg\n}","function twoHex(x: number): string {\n\treturn (x > 0xf ? \"\" : \"0\") + x.toString(16)\n}\n\nexport function colorNumberTo3Components(color: number): [r: number, g: number, b: number] {\n\tconst r = (color >> 16) & 0xff,\n\t\tg = (color >> 8) & 0xff,\n\t\tb = (color >> 0) & 0xff\n\treturn [r, g, b]\n}\n\nexport function color3ComponentsToNumber(components: [r: number, g: number, b: number]): number {\n\tconst [r, g, b] = components\n\treturn (r << 16) | (g << 8) | b\n}\n\nexport function rgbToHsl(color: number): number {\n\tlet [r, g, b] = colorNumberTo3Components(color)\n\t// Make r, g, and b fractions of 1\n\tr /= 255\n\tg /= 255\n\tb /= 255\n\n\t// Find greatest and smallest channel values\n\tconst cmin = Math.min(r, g, b),\n\t\tcmax = Math.max(r, g, b),\n\t\tdelta = cmax - cmin\n\tlet h = 0,\n\t\ts = 0,\n\t\tl = 0\n\n\t// Calculate hue\n\t// No difference\n\tif(delta === 0){\n\t\th = 0\n\t} else if(cmax === r){\n\t\t// Red is max\n\t\th = ((g - b) / delta) % 6\n\t} else if(cmax === g){\n\t\t// Green is max\n\t\th = (b - r) / delta + 2\n\t} else {\n\t\t// Blue is max\n\t\th = (r - g) / delta + 4\n\t}\n\n\th = Math.round(h * 60)\n\n\t// Make negative hues positive behind 360Â°\n\tif(h < 0){\n\t\th += 360\n\t}\n\n\t// Calculate lightness\n\tl = (cmax + cmin) / 2\n\n\t// Calculate saturation\n\ts = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1))\n\n\t// Multiply l and s by 100\n\ts = +(s * 100).toFixed(1)\n\tl = +(l * 100).toFixed(1)\n\n\treturn color3ComponentsToNumber([(h / 360) * 255, (s / 100) * 255, (l / 100) * 255])\n}\n\nexport function hslToRgb(hsl: number): number {\n\tlet [h, s, l] = colorNumberTo3Components(hsl)\n\th /= 255\n\ts /= 255\n\tl /= 255\n\tlet r: number, g: number, b: number\n\n\tif(s === 0){\n\t\tr = g = b = l // achromatic\n\t} else {\n\t\tconst q = l < 0.5 ? l * (1 + s) : l + s - l * s\n\t\tconst p = 2 * l - q\n\t\tr = hueToRgb(p, q, h + 1 / 3)\n\t\tg = hueToRgb(p, q, h)\n\t\tb = hueToRgb(p, q, h - 1 / 3)\n\t}\n\n\treturn color3ComponentsToNumber([Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)])\n}\n\nfunction hueToRgb(p: number, q: number, t: number): number {\n\tif(t < 0){\n\t\tt += 1\n\t}\n\tif(t > 1){\n\t\tt -= 1\n\t}\n\tif(t < 1 / 6){\n\t\treturn p + (q - p) * 6 * t\n\t}\n\tif(t < 1 / 2){\n\t\treturn q\n\t}\n\tif(t < 2 / 3){\n\t\treturn p + (q - p) * (2 / 3 - t) * 6\n\t}\n\treturn p\n}\n\nexport function rgbNumberToColorString(rgb: number): string {\n\tconst b = rgb & 0xff\n\trgb >>= 8\n\tconst g = rgb & 0xff\n\trgb >>= 8\n\tconst r = rgb & 0xff\n\n\treturn \"#\" + twoHex(r) + twoHex(g) + twoHex(b)\n}\n\nexport function transformColorHsl(colorRgb: number, transform: (hsl: [number, number, number]) => [number, number, number]): number {\n\tconst transformResult = transform(\n\t\tcolorNumberTo3Components(\n\t\t\trgbToHsl(colorRgb)\n\t\t)\n\t)\n\ttransformResult[0] = Math.max(0, Math.min(255, Math.round(transformResult[0])))\n\ttransformResult[1] = Math.max(0, Math.min(255, Math.round(transformResult[1])))\n\ttransformResult[2] = Math.max(0, Math.min(255, Math.round(transformResult[2])))\n\treturn hslToRgb(\n\t\tcolor3ComponentsToNumber(\n\t\t\ttransformResult\n\t\t)\n\t)\n}","import {Binder, getBinder} from \"common/binder/binder\"\nimport {isRBox, MaybeRBoxed, RBox, unbox, WBox} from \"common/box\"\nimport {ClassNameParts, makeClassname} from \"common/classname\"\nimport {FieldsOfObjectWithType, WritableKeysOf} from \"common/type_utils\"\n\ntype CssStyleAssignableKeys = WritableKeysOf<CSSStyleDeclaration> & FieldsOfObjectWithType<CSSStyleDeclaration, string>\n\ninterface TagDescription<K extends string = string, ThisType = unknown> {\n\treadonly tagName?: K\n\treadonly text?: MaybeRBoxed<string | number>\n\treadonly attrs?: {\n\t\treadonly [attrName: string]: MaybeRBoxed<string | number | undefined | null>\n\t}\n\treadonly on?: {\n\t\treadonly [k in keyof GlobalEventHandlersEventMap]?: (this: ThisType, evt: GlobalEventHandlersEventMap[k]) => void\n\t}\n\treadonly class?: ClassNameParts\n}\n\nexport interface HTMLTagDescription<K extends keyof HTMLElementTagNameMap = keyof HTMLElementTagNameMap> extends TagDescription<K, HTMLElementTagNameMap[K]> {\n\n\treadonly style?: {\n\t\treadonly [k in CssStyleAssignableKeys]?: MaybeRBoxed<string | number>\n\t}\n}\n\nexport type SVGTagDescription<K extends keyof SVGElementTagNameMap = keyof SVGElementTagNameMap> = TagDescription<K, SVGElementTagNameMap[K]>\n\ntype ChildArray = (Element | null | undefined)[] | RBox<(Element | null | undefined)[]>\n\n// typings are weird here, had to cast\nfunction resolveArgs<K>(a?: K | ChildArray, b?: ChildArray): [K, ChildArray | undefined] {\n\tif(!a){\n\t\treturn [{} as K, b]\n\t} else if(Array.isArray(a) || isRBox(a)){\n\t\treturn [{} as K, a as ChildArray]\n\t} else {\n\t\treturn [a as K, b]\n\t}\n}\n\nfunction populateTag<K extends string, T>(tagBase: Element, description: TagDescription<K, T>, children?: ChildArray): Binder | null {\n\tlet binder: Binder | null = null\n\n\tif(description.text){\n\t\tconst text = description.text\n\t\tif(isRBox(text)){\n\t\t\t(binder ||= getBinder(tagBase)).watch<string | number>(text, text => {\n\t\t\t\ttagBase.textContent = text + \"\"\n\t\t\t})\n\t\t}\n\t\ttagBase.textContent = unbox(text) + \"\"\n\t}\n\n\tif(description.on){\n\t\tfor(const evtName in description.on){\n\t\t\tconst handler = description.on[evtName as keyof GlobalEventHandlersEventMap]\n\t\t\t// I don't want to construct elaborat solid type here\n\t\t\t// I know the type will be correct, because it is enforced by function parameter type\n\t\t\t// so just be Any and that's it\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\ttagBase.addEventListener(evtName, handler as any, {passive: true, capture: false})\n\t\t}\n\t}\n\n\tfor(const k in description.attrs){\n\t\tconst v = description.attrs[k]\n\t\tif(isRBox(v)){\n\t\t\t(binder ||= getBinder(tagBase)).watch<string | number | null | undefined>(v, v => {\n\t\t\t\tif(v === null || v === undefined){\n\t\t\t\t\ttagBase.removeAttribute(k)\n\t\t\t\t} else {\n\t\t\t\t\ttagBase.setAttribute(k, v + \"\")\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\tconst vv = unbox(v)\n\t\tif(v !== null && v !== undefined){\n\t\t\ttagBase.setAttribute(k, vv + \"\")\n\t\t}\n\t}\n\n\tif(children){\n\t\tconst setChildren = (children: (Element | null | undefined)[]) => {\n\t\t\tconst childTags = children.filter(x => !!x) as Element[]\n\t\t\tupdateChildren(tagBase, childTags)\n\t\t}\n\n\t\tif(isRBox(children)){\n\t\t\t(binder ||= getBinder(tagBase)).watch(children, children => {\n\t\t\t\tsetChildren(children)\n\t\t\t})\n\t\t}\n\t\tsetChildren(unbox(children))\n\t}\n\n\tif(description.class){\n\t\tbinder = makeClassname(\n\t\t\tbinder,\n\t\t\ttagBase,\n\t\t\tdescription.class,\n\t\t\t// using classList here because on svg elements .className is readonly (in runtime)\n\t\t\tclassname => tagBase.classList.value = classname\n\t\t) || binder\n\t}\n\n\treturn binder\n}\n\nexport function tag(): HTMLDivElement\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(description: HTMLTagDescription<K>): HTMLElementTagNameMap[K]\nexport function tag(children: ChildArray): HTMLDivElement\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(description: HTMLTagDescription<K>, children: ChildArray): HTMLElementTagNameMap[K]\n\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(a?: HTMLTagDescription<K> | ChildArray, b?: ChildArray): HTMLElementTagNameMap[K] {\n\tconst [description, children] = resolveArgs(a, b)\n\n\tconst tagBase = document.createElement(description.tagName || \"div\")\n\n\tlet binder = populateTag(tagBase, description, children)\n\n\tif(description.style){\n\t\tfor(const k in description.style){\n\t\t\tconst v = description.style[k as CssStyleAssignableKeys]\n\t\t\tif(isRBox(v)){\n\t\t\t\t(binder ||= getBinder(tagBase)).watch<string | number>(v, v => {\n\t\t\t\t\ttagBase.style[k] = v + \"\"\n\t\t\t\t})\n\t\t\t}\n\t\t\ttagBase.style[k] = unbox(description.style[k]!) + \"\"\n\t\t}\n\t}\n\n\treturn tagBase as HTMLElementTagNameMap[K]\n}\n\nexport function svgTag(): SVGGElement\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(description: SVGTagDescription<K>): SVGElementTagNameMap[K]\nexport function svgTag(children: ChildArray): SVGGElement\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(description: SVGTagDescription<K>, children: ChildArray): SVGElementTagNameMap[K]\n\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(a?: SVGTagDescription<K> | ChildArray, b?: ChildArray): SVGElementTagNameMap[K] {\n\tconst [description, children] = resolveArgs(a, b)\n\n\tconst tagBase = document.createElementNS(\"http://www.w3.org/2000/svg\", description.tagName || \"g\")\n\n\tif(description.tagName === \"svg\"){\n\t\ttagBase.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\")\n\t}\n\n\tpopulateTag(tagBase, description, children)\n\n\treturn tagBase as SVGElementTagNameMap[K]\n}\n\nfunction updateChildren(parent: Element, newChildren: readonly Element[]): void {\n\tfor(let i = 0; i < newChildren.length; i++){\n\t\tconst childTag = newChildren[i]!\n\t\tconst x = parent.childNodes[i]\n\t\tif(x === childTag){\n\t\t\tcontinue\n\t\t}\n\t\tif(x){\n\t\t\tparent.insertBefore(childTag, x)\n\t\t} else {\n\t\t\tparent.appendChild(childTag)\n\t\t}\n\t}\n\n\twhile(parent.childNodes[newChildren.length]){\n\t\tparent.childNodes[newChildren.length]!.remove()\n\t}\n}\n\n/** Cached renderer for list of elements\n * Won't re-render an element if already has one for the value */\nexport function renderArray<T, K, E extends Element>(src: WBox<T[]>, getKey: (value: T) => K, render: (value: WBox<T>) => E): RBox<E[]>\nexport function renderArray<T, K, E extends Element>(src: RBox<T[]>, getKey: (value: T) => K, render: (value: RBox<T>) => E): RBox<E[]>\nexport function renderArray<T, K, E extends Element>(src: MaybeRBoxed<readonly T[]>, getKey: (value: T) => K, render: (value: MaybeRBoxed<T>) => E): E[]\nexport function renderArray<T, K, E extends Element>(src: MaybeRBoxed<readonly T[]> | WBox<T[]>, getKey: (value: T) => K, render: (value: WBox<T> | T) => E): Node[] | RBox<Node[]> {\n\tif(Array.isArray(src)){\n\t\treturn src.map(el => render(el))\n\t}\n\n\tconst map = new Map<WBox<T>, E>()\n\n\treturn (src as WBox<T[]>).wrapElements(getKey).map(itemBoxes => {\n\t\tconst leftoverBoxes = new Set(map.keys())\n\n\t\tconst result = itemBoxes.map(itemBox => {\n\t\t\tleftoverBoxes.delete(itemBox)\n\t\t\tlet el = map.get(itemBox)\n\t\t\tif(!el){\n\t\t\t\tel = render(itemBox)\n\t\t\t\tmap.set(itemBox, el)\n\t\t\t}\n\t\t\treturn el\n\t\t})\n\n\t\tfor(const oldBox of leftoverBoxes){\n\t\t\tmap.delete(oldBox)\n\t\t}\n\n\t\treturn result\n\t})\n}","import {Binder, getBinder} from \"common/binder/binder\"\nimport {isRBox, MaybeRBoxed, unbox} from \"common/box\"\n\ntype ClassNamePart = MaybeRBoxed<string | null | undefined> | Record<string, MaybeRBoxed<boolean | undefined>>\nexport type ClassNameParts = ClassNamePart | ClassNamePart[]\n\n/** Utility function that assembles classname from parts */\nexport function makeClassname(binder: Binder | null, node: Node, parts: ClassNameParts, callback: (className: string) => void): Binder | null {\n\tconst arr = Array.isArray(parts) ? parts : [parts]\n\tfor(const item of arr){\n\t\tif(isRBox(item)){\n\t\t\t(binder ||= getBinder(node)).watch(item, makeClassnameAndCallTheCallback)\n\t\t} else if(item && typeof(item) === \"object\"){\n\t\t\tfor(const key in item){\n\t\t\t\tconst bool = item[key]\n\t\t\t\tif(isRBox(bool)){\n\t\t\t\t\t(binder ||= getBinder(node)).watch(bool, makeClassnameAndCallTheCallback)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction makeClassnameAndCallTheCallback() {\n\t\tconst result = []\n\t\tfor(const item of arr){\n\t\t\tif(item && typeof(item) === \"object\"){\n\t\t\t\tfor(const classname in item){\n\t\t\t\t\tif(unbox(item[classname])){\n\t\t\t\t\t\tresult.push(classname)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst classname = unbox(item)\n\t\t\t\tif(classname){\n\t\t\t\t\tresult.push(classname)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcallback(result.join(\" \"))\n\t}\n\n\tmakeClassnameAndCallTheCallback()\n\n\treturn binder\n}","import {performeter} from \"common/perfometer\"\nimport {decodeXY, encodeXY, TriangleGrid, XY} from \"sketches/random_rhombus_tilings/triangle_grid\"\n\n// this all is very inoptimal, and can be stored in a few bits\n// but whatever, it's not heavy enough to lag anyway\nexport interface TriangleGridRhombusNode {\n\treadonly leftIsSolid: boolean\n\treadonly rightIsSolid: boolean\n\treadonly bottomIsSolid: boolean\n}\n\nexport type RhombusGrid = TriangleGrid<TriangleGridRhombusNode>\n\n// horisontal places at the bottom\nexport const getEmptyRhombusPattern = (props: {width: number, height: number, length: number}): RhombusGrid => {\n\tconst grid = new TriangleGrid<TriangleGridRhombusNode>({\n\t\t...props,\n\t\tdefaultValue: {\n\t\t\tleftIsSolid: false,\n\t\t\trightIsSolid: false,\n\t\t\tbottomIsSolid: false\n\t\t}\n\t})\n\n\tconst center = grid.getCenterCornerCoords()\n\n\tgrid.exploreFrom(center, xy => {\n\t\tgrid.set(xy, {...grid.get(xy), bottomIsSolid: true})\n\t\treturn [grid.getBottomLeftOf(xy), grid.getBottomRightOf(xy), grid.getBottomOf(xy)]\n\t})\n\n\tgrid.exploreFrom(center, xy => {\n\t\tgrid.set(xy, {...grid.get(xy), leftIsSolid: true})\n\t\treturn [grid.getBottomLeftOf(xy), grid.getTopLeftOf(xy), grid.getTopOf(xy)]\n\t})\n\n\tgrid.exploreFrom(center, xy => {\n\t\tgrid.set(xy, {...grid.get(xy), rightIsSolid: true})\n\t\treturn [grid.getBottomRightOf(xy), grid.getTopRightOf(xy), grid.getTopOf(xy)]\n\t})\n\n\treturn grid\n}\n\nexport const tileWithRandomRhombuses = (grid: RhombusGrid): void => {\n\tconst flippables = new Set<number>([encodeXY(grid.getCenterCornerCoords())])\n\n\tconst updateNeighbours = (sourceXy: XY) => {\n\t\tfor(const xy of grid.getValidNeighbourCoords(sourceXy)){\n\t\t\tconst key = encodeXY(xy)\n\t\t\tif(canFlipAt(xy)){\n\t\t\t\tflippables.add(key)\n\t\t\t} else {\n\t\t\t\tflippables.delete(key)\n\t\t\t}\n\t\t}\n\t}\n\n\tconst isConcaveCorner = (node: TriangleGridRhombusNode) => node.bottomIsSolid && node.leftIsSolid && node.rightIsSolid\n\tconst canFlipAt = (xy: XY) => {\n\t\tconst node = grid.get(xy)\n\t\tif(isConcaveCorner(node)){\n\t\t\treturn true\n\t\t}\n\n\t\tif(node.bottomIsSolid || node.leftIsSolid || node.rightIsSolid){\n\t\t\treturn false\n\t\t}\n\n\t\tconst top = grid.getTopOf(xy)\n\t\tconst left = grid.getBottomLeftOf(xy)\n\t\tconst right = grid.getBottomRightOf(xy)\n\n\t\tconst topIsSolid = !grid.isCoordValid(top) || grid.get(top).bottomIsSolid\n\t\tconst leftIsSolid = !grid.isCoordValid(left) || grid.get(left).rightIsSolid\n\t\tconst rightIsSolid = !grid.isCoordValid(right) || grid.get(right).leftIsSolid\n\n\t\treturn topIsSolid && leftIsSolid && rightIsSolid\n\t}\n\tconst getFlipped = (node: TriangleGridRhombusNode): TriangleGridRhombusNode => {\n\t\tif(isConcaveCorner(node)){\n\t\t\treturn {leftIsSolid: false, rightIsSolid: false, bottomIsSolid: false}\n\t\t}\n\t\treturn {leftIsSolid: true, rightIsSolid: true, bottomIsSolid: true}\n\t}\n\tconst tryMutate = (xy: XY, mutator: (node: TriangleGridRhombusNode) => TriangleGridRhombusNode) => {\n\t\tif(grid.isCoordValid(xy)){\n\t\t\tgrid.set(xy, mutator(grid.get(xy)))\n\t\t}\n\t}\n\tconst flipAt = (xy: XY) => {\n\t\t// console.log(`Flipping ${xy.x}, ${xy.y}`)\n\t\tconst node = grid.get(xy)\n\t\ttryMutate(grid.getBottomLeftOf(xy), node => ({...node, rightIsSolid: !node.rightIsSolid}))\n\t\ttryMutate(grid.getBottomRightOf(xy), node => ({...node, leftIsSolid: !node.leftIsSolid}))\n\t\ttryMutate(grid.getTopOf(xy), node => ({...node, bottomIsSolid: !node.bottomIsSolid}))\n\t\tgrid.set(xy, getFlipped(node))\n\t\tupdateNeighbours(xy)\n\t}\n\n\tfor(let i = 0; i < grid.count * 1; i++){\n\t\tif(flippables.size === 0){\n\t\t\tconsole.log(\"no flip candidate????\")\n\t\t\tbreak\n\t\t}\n\n\t\tperformeter.enterBlock(\"copy set\")\n\t\tconst arr = [...flippables] // very unoptimized, but I don't want to think about it too much right now\n\t\tperformeter.exitEnterBlock(\"flip\")\n\t\tconst xy = decodeXY(arr[Math.floor(Math.random() * arr.length)]!)\n\t\tflipAt(xy)\n\t\tperformeter.exitBlock()\n\t}\n\n}","interface Block {\n\tparent: Block | null\n\tsubblocks: Record<string, Block>\n\ttimeStart: number\n\ttimeSum: number\n\tenterCount: number\n}\n\ninterface BlockToPrint {\n\t\"ms per enter\": number\n\t\"full %\": number\n\t\"parent %\": number\n}\n\nclass Perfometer {\n\n\tprivate root: Block = this.makeBlock(null)\n\tprivate currentBlock: Block = this.root\n\tprivate eventCounters: Record<string, number> = {}\n\n\tprivate makeBlock(parent: Block | null): Block {\n\t\treturn {\n\t\t\tsubblocks: {}, parent: parent,\n\t\t\ttimeStart: -1, timeSum: 0,\n\t\t\tenterCount: 0\n\t\t}\n\t}\n\n\tenterBlock(name: string): void {\n\t\tlet nextBlock = this.currentBlock.subblocks[name]\n\t\tif(!nextBlock){\n\t\t\tnextBlock = this.makeBlock(this.currentBlock)\n\t\t\tthis.currentBlock.subblocks[name] = nextBlock\n\t\t}\n\t\tnextBlock.timeStart = performance.now()\n\t\tnextBlock.enterCount++\n\t\tthis.currentBlock = nextBlock\n\t}\n\n\trecordEvent(name: string): void {\n\t\tthis.eventCounters[name] = (this.eventCounters[name] ?? 0) + 1\n\t}\n\n\texitBlock(): void {\n\t\tthis.currentBlock.timeSum += performance.now() - this.currentBlock.timeStart\n\t\tconst parent = this.currentBlock.parent\n\t\tif(!parent){\n\t\t\tthrow new Error(\"No parent! Blocks are all messed up.\")\n\t\t}\n\t\tthis.currentBlock = parent\n\t}\n\n\texitEnterBlock(name: string): void {\n\t\tthis.exitBlock()\n\t\tthis.enterBlock(name)\n\t}\n\n\tprint(): void {\n\t\tconst table: Record<string, BlockToPrint> = {}\n\t\tlet fullTime = 0\n\t\tfor(const name in this.root.subblocks){\n\t\t\tfullTime += this.root.subblocks[name]!.timeSum\n\t\t}\n\n\t\tthis.forEachBlock((block, name, depth) => {\n\t\t\tname = new Array(depth + 1).join(\"-\") + name\n\t\t\ttable[name] = {\n\t\t\t\t\"parent %\": strip((block.timeSum / block.parent!.timeSum) * 100),\n\t\t\t\t\"full %\": strip((block.timeSum / fullTime) * 100),\n\t\t\t\t\"ms per enter\": strip(block.timeSum / block.enterCount)\n\t\t\t}\n\t\t})\n\n\t\tconsole.table(table)\n\t\tconsole.table(this.eventCounters)\n\t}\n\n\treset(): void {\n\t\tthis.root = this.makeBlock(null)\n\t\tthis.currentBlock = this.root\n\t\tthis.eventCounters = {}\n\t}\n\n\tprivate forEachBlock(callback: (block: Block, name: string, depth: number) => void, start: Block = this.root, currentDepth = 0): void {\n\t\tfor(const name in start.subblocks){\n\t\t\tconst subblock = start.subblocks[name]!\n\t\t\tcallback(subblock, name, currentDepth)\n\t\t\tthis.forEachBlock(callback, subblock, currentDepth + 1)\n\t\t}\n\t}\n\n}\n\nexport const performeter = new Perfometer()\n\nfunction strip(v: number): number {\n\treturn Math.round(v * 100) / 100\n}","import {Queue} from \"common/queue\"\n\ninterface Props<T> {\n\treadonly length: number // left side distance\n\treadonly width: number // right side distance\n\treadonly height: number // top side distance\n\treadonly defaultValue: T\n}\n\nexport interface XY {\n\treadonly x: number\n\treadonly y: number\n}\n\nexport const encodeXY = (xy: XY): number => (xy.y << 0x10) | xy.x\nexport const decodeXY = (key: number): XY => ({x: key & 0xffff, y: (key >> 0x10)})\n\n/** A container for values arranged in triangle pattern.\n * Columns are aligned, each next row is offset by half.\n * Resulting pattern of values, if drawn on 2d plane, will generally look like 6-sided polygon (4-sided, if one of the dimensions is 1, etc)\n *\n * This class also contains utility related arithmetic functions.  */\nexport class TriangleGrid<T> {\n\n\t/** Amount of columns in the grid */\n\treadonly xWidth: number\n\t/** Difference of Y coord between lowest and highest point of grid, in cells.\n\t * May be fractional (because half-cell distance is possible in triangle grid). */\n\treadonly yHeight: number\n\t/** Count of elements in the grid. */\n\treadonly count: number\n\t/** X coord of column that has highest grid point */\n\treadonly topCornerColumnX: number\n\tprivate readonly values: T[][]\n\n\tconstructor(private readonly props: Props<T>) {\n\t\tif(props.width < 1 || props.height < 1 || props.length < 1 || props.width % 1 || props.height % 1 || props.length % 1){\n\t\t\tthrow new Error(`Incorrect grid dimensions: ${props.length} x ${props.width} x ${props.height}`)\n\t\t}\n\t\tthis.xWidth = props.length + props.width - 1\n\t\tthis.yHeight = (this.xWidth / 2) + props.height\n\t\tthis.topCornerColumnX = this.props.width - 1\n\t\tlet count = 0\n\t\tthis.values = new Array(this.xWidth)\n\t\t\t.fill(null)\n\t\t\t.map((_, x) => {\n\t\t\t\tconst height = this.getHeightOfColumnAt(x)\n\t\t\t\tcount += height\n\t\t\t\treturn new Array(height)\n\t\t\t\t\t.fill(null)\n\t\t\t\t\t.map(() => props.defaultValue)\n\t\t\t})\n\t\tthis.count = count\n\t}\n\n\tgetHeightOfColumnAt(x: number): number {\n\t\tlet result = this.props.height\n\t\tif(x < this.props.length && x < this.props.width){\n\t\t\tresult += x\n\t\t} else if((x < this.props.length) !== (x < this.props.width)){\n\t\t\tresult += Math.min(this.props.length, this.props.width) - 1\n\t\t} else {\n\t\t\tresult += this.xWidth - 1 - x\n\t\t}\n\t\treturn result\n\t}\n\n\t* [Symbol.iterator](): IterableIterator<{x: number, y: number, value: T}> {\n\t\tfor(let x = 0; x < this.values.length; x++){\n\t\t\tconst col = this.values[x]!\n\t\t\tfor(let y = 0; y < col.length; y++){\n\t\t\t\tyield{x, y, value: col[y]!}\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @returns difference between y coord of highest point of the whole rhombus and y coords the highest point in this column, in cells */\n\tgetVerticalOffset(x: number): number {\n\t\tconst topPointX = this.props.length - 1\n\t\treturn Math.abs(topPointX - x) / 2\n\t}\n\n\tgetCenterCornerCoords(): XY {\n\t\treturn {\n\t\t\tx: this.topCornerColumnX,\n\t\t\ty: this.props.height - 1\n\t\t}\n\t}\n\n\tgetTopCornerCoords(): XY {\n\t\treturn {\n\t\t\tx: this.topCornerColumnX,\n\t\t\ty: 0\n\t\t}\n\t}\n\n\tgetLeftBottomCornerCoords(): XY {\n\t\treturn {\n\t\t\tx: 0,\n\t\t\ty: this.values[0]!.length - 1\n\t\t}\n\t}\n\n\tgetRightBottomCornerCoords(): XY {\n\t\treturn {\n\t\t\tx: this.values.length - 1,\n\t\t\ty: this.values[this.values.length - 1]!.length - 1\n\t\t}\n\t}\n\n\t/** @returns true if coords are within the grid */\n\tisCoordValid(coords: XY): boolean {\n\t\tif(coords.x < 0 || coords.y < 0){\n\t\t\treturn false\n\t\t}\n\t\tconst col = this.values[coords.x]\n\t\treturn !!col && col.length > coords.y\n\t}\n\n\tprivate throwOnInvalidCoords(coords: XY): void {\n\t\tif(!this.isCoordValid(coords)){\n\t\t\tthrow new Error(`Asked for value at ${coords.x}, ${coords.y}, but container only has ${this.values.length} columns, and this column ${this.values.length > coords.x ? `contains only ${this.values[coords.x]!.length} rows` : \"does not exist\"}.`)\n\t\t}\n\t}\n\n\tget(coords: XY): T {\n\t\tthis.throwOnInvalidCoords(coords)\n\t\treturn this.values[coords.x]![coords.y]!\n\t}\n\n\tset(coords: XY, value: T): void {\n\t\tthis.values[coords.x]![coords.y] = value\n\t}\n\n\t// this method, and others, are just for arithmetics\n\t// they can return a coord that is out of this grid\n\t// use areCoordsValid() to check if this is the case\n\tgetTopLeftOf({x, y}: XY): XY {\n\t\treturn {x: x - 1, y: x <= this.topCornerColumnX ? y - 1 : y}\n\t}\n\n\tgetBottomLeftOf({x, y}: XY): XY {\n\t\treturn {x: x - 1, y: x <= this.topCornerColumnX ? y : y + 1}\n\t}\n\n\tgetTopRightOf({x, y}: XY): XY {\n\t\treturn {x: x + 1, y: x < this.topCornerColumnX ? y : y - 1}\n\t}\n\n\tgetBottomRightOf({x, y}: XY): XY {\n\t\treturn {x: x + 1, y: x < this.topCornerColumnX ? y + 1 : y}\n\t}\n\n\tgetTopOf({x, y}: XY): XY {\n\t\treturn {x, y: y - 1}\n\t}\n\n\tgetBottomOf({x, y}: XY): XY {\n\t\treturn {x, y: y + 1}\n\t}\n\n\tgetValidNeighbourCoords(xy: XY): XY[] {\n\t\treturn [\n\t\t\tthis.getTopOf(xy),\n\t\t\tthis.getBottomOf(xy),\n\t\t\tthis.getTopLeftOf(xy),\n\t\t\tthis.getTopRightOf(xy),\n\t\t\tthis.getBottomLeftOf(xy),\n\t\t\tthis.getBottomRightOf(xy)\n\t\t].filter(xy => this.isCoordValid(xy))\n\t}\n\n\t/** Starting at startingPoint, get next points from explorer; explore while there are points to explore.\n\t * Each point is visited only once. */\n\texploreFrom(startingPoint: XY, explore: (xy: XY) => XY[]): void {\n\t\tconst queue = new Queue<XY>()\n\t\tconst processed = new Set<number>()\n\n\t\tlet next: XY | undefined = startingPoint\n\t\twhile(next){\n\t\t\tconst points = explore(next)\n\t\t\tfor(const xy of points){\n\t\t\t\tif(!this.isCoordValid(xy)){\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst key = encodeXY(xy)\n\t\t\t\tif(!processed.has(key)){\n\t\t\t\t\tprocessed.add(key)\n\t\t\t\t\tqueue.enqueue(xy)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnext = queue.maybeDequeue()\n\t\t}\n\t}\n\n\n}","interface Node<T> {\n\tprev?: Node<T>\n\tvalue: T\n}\n\nexport class Queue<T> {\n\n\tprivate len = 0\n\tprivate headNode?: Node<T>\n\tprivate tailNode?: Node<T>\n\n\tget length(): number {\n\t\treturn this.len\n\t}\n\n\tget head(): T | undefined {\n\t\treturn this.headNode?.value\n\t}\n\n\tget tail(): T | undefined {\n\t\treturn this.tailNode?.value\n\t}\n\n\tenqueue(value: T): void {\n\t\tif(this.headNode && this.tailNode){\n\t\t\tconst oldTail = this.tailNode\n\t\t\tthis.tailNode = {value}\n\t\t\toldTail.prev = this.tailNode\n\t\t} else {\n\t\t\tthis.headNode = this.tailNode = {value}\n\t\t}\n\t\tthis.len++\n\t}\n\n\tdequeue(): T {\n\t\tif(!this.headNode){\n\t\t\tthrow new Error(\"Queue empty, cannot dequeue.\")\n\t\t}\n\t\tconst result = this.headNode.value\n\t\tthis.headNode = this.headNode.prev\n\t\tthis.len--\n\t\treturn result\n\t}\n\n\tmaybeDequeue(): T | undefined {\n\t\tif(!this.headNode){\n\t\t\treturn undefined\n\t\t}\n\t\tconst result = this.headNode.value\n\t\tthis.headNode = this.headNode.prev\n\t\tthis.len--\n\t\treturn result\n\t}\n\n\tclear(): void {\n\t\tthis.len = 0\n\t\tthis.headNode = this.tailNode = undefined\n\t}\n\n\ttoArrayHeadFirst(): T[] {\n\t\tconst result: T[] = new Array(this.len)\n\t\tlet node = this.headNode\n\t\tlet i = 0\n\t\twhile(node){\n\t\t\tresult[i++] = node.value\n\t\t\tnode = node.prev\n\t\t}\n\t\treturn result\n\t}\n\n}","import wasm from \"sketches/random_rhombus_tilings/wasm/rhombus_randomiser.wasm\"\nimport type {instantiate} from \"./wasm/rhombus_randomiser\"\n\ntype Exports = ReturnType<typeof instantiate> extends Promise<infer X>? X: never\n\n// this file exists because default autogenerated bindings suck, for two reasons:\n// 1. no interop with Parcel. it is expected to know URL of wasm binary ahead of time, which is not the case for us\n// 2. no support for .instantiateStreaming\nexport const getWasmRhombusRandomiser = async(): Promise<Exports> => {\n\tconst {instance} = await WebAssembly.instantiateStreaming(fetch(wasm))\n\treturn instance.exports as Exports\n}","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"d9iEL\")).toString();","\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;"],"names":["$elQpM","parcelRequire","$feb87bdc332a04e8$var$colors","$feb87bdc332a04e8$export$f22da7240b7add18","container","$kxLP6","getWasmRhombusRandomiser","then","x","console","log","addTwoNumbers","$8HcCf","performeter","enterBlock","grid","$kFpLY","getEmptyRhombusPattern","width","height","length","exitEnterBlock","tileWithRandomRhombuses","color","Math","floor","random","svg","renderRhombuses","horisontalColor","$efatB","transformColorHsl","h","s","l","leftColor","rightColor","cellSize","y","style","margin","appendChild","exitBlock","print","$fbf140c75cf60424$export$61227af714afdbe3","props","$aCP3q","svgTag","tagName","setAttribute","xWidth","yHeight","strokeWidth","makePathMaker","expr","offset","getVerticalOffset","max","min","attrs","d","fill","rgbNumberToColorString","stroke","makeLeft","makeRight","makeBottom","value","leftIsSolid","rightIsSolid","bottomIsSolid","exploreFrom","getTopCornerCoords","xy","get","getBottomLeftOf","getBottomRightOf","getRightBottomCornerCoords","getTopOf","getLeftBottomCornerCoords","$fa4a5aa5cdd6ce8e$var$twoHex","toString","$fa4a5aa5cdd6ce8e$export$fdc9c29511f1a926","$fa4a5aa5cdd6ce8e$export$79db3ad3d560d193","components","r","g","b","$fa4a5aa5cdd6ce8e$var$hueToRgb","p","q","t","$fa4a5aa5cdd6ce8e$export$c5ea230d2f55d434","rgb","$fa4a5aa5cdd6ce8e$export$21d90289cdbe307c","colorRgb","transform","transformResult","cmin","cmax","delta","round","abs","toFixed","$fa4a5aa5cdd6ce8e$export$c85ca4f4753af384","hsl","$fa4a5aa5cdd6ce8e$export$29fb7152bd3f781a","$hIDiW","$4c0fbf616468c6ce$var$resolveArgs","a","Array","isArray","$hsvBG","isRBox","$4c0fbf616468c6ce$var$populateTag","tagBase","description","children","binder","text","getBinder","watch","textContent","unbox","on","evtName","handler","addEventListener","passive","capture","k","v","removeAttribute","vv","setChildren","childTags","filter","parent","newChildren","i","childTag","childNodes","insertBefore","remove","$4c0fbf616468c6ce$var$updateChildren","class","$jM5hi","makeClassname","classname","classList","$4c0fbf616468c6ce$export$2b067c6666111485","document","createElement","$4c0fbf616468c6ce$export$e0e99c6b21dfde8d","createElementNS","setAttributeNS","$0d27fb504028ccb8$export$4ded07f8b6ee4cea","node","parts","callback","arr","item","makeClassnameAndCallTheCallback","key","bool","result","push","classname1","join","$625d88d1d12e65ae$export$594265a16ba9ecb7","$6fuK6","TriangleGrid","defaultValue","center","getCenterCornerCoords","set","getBottomOf","getTopLeftOf","getTopRightOf","$625d88d1d12e65ae$export$3483baa73bd0a475","flippables","Set","encodeXY","isConcaveCorner","canFlipAt","top","left","right","topIsSolid","isCoordValid","tryMutate","mutator","flipAt","getFlipped","sourceXy","getValidNeighbourCoords","add","delete","updateNeighbours","count","size","decodeXY","$6f792b9b35387246$export$e1ee22bc4cc102ea","root","this","makeBlock","currentBlock","eventCounters","subblocks","timeStart","timeSum","enterCount","name","nextBlock","performance","now","recordEvent","Error","table","fullTime","forEachBlock","block","depth","$6f792b9b35387246$var$strip","reset","start","currentDepth","subblock","$6A5Hp","$420e0860c859833c$export$7f5a1f6765a2b466","$420e0860c859833c$export$5fdd4d96ea786aae","$420e0860c859833c$export$f83afd22d38be4aa","constructor","topCornerColumnX","values","map","_","getHeightOfColumnAt","Symbol","iterator","col","topPointX","coords","throwOnInvalidCoords","startingPoint","explore","queue","Queue","processed","next","points","has","enqueue","maybeDequeue","$d86dd992f2068262$export$3dc07afe418952bc","len","head","headNode","tail","tailNode","oldTail","prev","dequeue","clear","undefined","toArrayHeadFirst","$9qvFf","$ac3684afa04ca243$export$bd88742c9a5aa178","async","instance","WebAssembly","instantiateStreaming","fetch","$parcel$interopDefault","exports","module","URL","resolve","import","meta","url","$18c11f3350a906ea$export$6503ec6e8aabbaf","$18c11f3350a906ea$export$f7ad0328861e2f03","$18c11f3350a906ea$var$mapping","pairs","keys","Object","id","resolved"],"version":3,"file":"random_rhombus_tilings.eee9c95d.js.map"}