{"mappings":"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","sources":["src/sketches/timer/timer.ts","src/sketches/timer/timer.module.scss","src/common/classname.ts","src/common/tag.ts"],"sourcesContent":["import {tag} from \"common/tag\"\nimport * as css from \"./timer.module.scss\"\n\nconst twoDigis = (x: number): string => x < 10 ? \"0\" + x : \"\" + x\nconst threeDigits = (x: number): string => x < 10 ? \"00\" + x : x < 100 ? \"0\" + x : \"\" + x\n\nfunction formatTime(time: number): string {\n\tif(time < 0){\n\t\treturn \"-\" + formatTime(-time)\n\t}\n\tconst ms = time % 1000\n\ttime = Math.floor(time / 1000)\n\n\tconst s = time % 60\n\ttime = Math.floor(time / 60)\n\n\tconst m = time % 60\n\tconst h = Math.floor(time / 60)\n\treturn `${twoDigis(h)}:${twoDigis(m)}:${twoDigis(s)}.${threeDigits(ms)}`\n}\n\nfunction formatTimeShort(time: number): string {\n\tlet result = formatTime(time).replace(/^[0:]+/, \"\") // lol\n\tif(result.startsWith(\".\")){\n\t\tresult = \"0\" + result\n\t}\n\treturn result\n}\n\nfunction intOrZero(x: string): number {\n\tconst result = parseInt(x)\n\tif(Number.isNaN(result) || !Number.isFinite(result)){\n\t\treturn 0\n\t} else {\n\t\treturn result\n\t}\n}\n\nfunction parseTime(time: string): number {\n\tconst parts = time.split(\":\")\n\tlet msec = 0\n\tif(parts.length > 0){\n\t\tconst lastPart = parts[parts.length - 1]!\n\t\tconst secParts = lastPart.split(\".\")\n\t\tif(secParts.length === 2){\n\t\t\tconst [secondsPart, msecPart] = secParts\n\t\t\tparts[parts.length - 1] = secondsPart!\n\t\t\tmsec += intOrZero(msecPart!)\n\t\t}\n\t}\n\n\tlet mult = 1000\n\tfor(let i = parts.length - 1; i >= 0; i--){\n\t\tconst part = parts[i]!\n\t\tmsec += intOrZero(part) * mult\n\t\tmult *= 60\n\t}\n\treturn msec\n}\n\nfunction onAnyChange(input: HTMLInputElement, handler: (value: string) => void): void {\n\tlet lastValue = input.value\n\tconst wrappedHandler = () => {\n\t\tconst value = input.value\n\t\tif(value !== lastValue){\n\t\t\tlastValue = value\n\t\t\thandler(value)\n\t\t}\n\t}\n\tinput.addEventListener(\"change\", wrappedHandler)\n\tinput.addEventListener(\"mousedown\", wrappedHandler)\n\tinput.addEventListener(\"mouseup\", wrappedHandler)\n\tinput.addEventListener(\"keydown\", wrappedHandler)\n\tinput.addEventListener(\"keyup\", wrappedHandler)\n}\n\nexport function main(root: HTMLElement): void {\n\troot.classList.add(css.timerRoot ?? \"\")\n\tconst wrap = tag({class: css.wrap})\n\n\tconst timeEl = tag({class: css.timer})\n\twrap.appendChild(timeEl)\n\n\tconst resetBtn = tag({tagName: \"button\", text: \"reset\", class: css.button})\n\tresetBtn.addEventListener(\"click\", () => {\n\t\ttimeAcc = 0\n\t\tupdateText()\n\t})\n\twrap.appendChild(resetBtn)\n\n\tconst pauseBtn = tag({tagName: \"button\", text: \"pause\", class: css.button})\n\tpauseBtn.addEventListener(\"click\", () => {\n\t\tif(paused){\n\t\t\tpaused = false\n\t\t\tpauseBtn.value = \"pause\"\n\t\t} else {\n\t\t\tpaused = true\n\t\t\tpauseBtn.value = \"unpause\"\n\t\t}\n\t})\n\twrap.appendChild(pauseBtn)\n\n\tconst speedBlock = tag({class: css.speedBlock, text: \"Speed: \"})\n\tconst speedInput = tag({tagName: \"input\", attrs: {type: \"number\", value: 1}, class: css.speedInput})\n\tonAnyChange(speedInput, () => {\n\t\tconst parsed = parseFloat(speedInput.value)\n\t\tif(Number.isNaN(parsed) || !Number.isFinite(parsed)){\n\t\t\tconsole.warn(\"Bad speed value: \" + JSON.stringify(speedInput.value) + \": cannot parse\")\n\t\t\treturn\n\t\t}\n\t\tspeed = parsed\n\t})\n\tspeedBlock.appendChild(speedInput)\n\twrap.appendChild(speedBlock)\n\n\n\tconst addTimeBlock = tag()\n\tconst addTimeButton = tag({tagName: \"button\", text: \"Add time\", class: css.button})\n\taddTimeButton.addEventListener(\"click\", () => {\n\t\ttimeAcc += parseTime(addTimeInput.value)\n\t\tupdateText()\n\t})\n\taddTimeBlock.appendChild(addTimeButton)\n\tconst addTimeInput = tag({tagName: \"input\", attrs: {type: \"string\", value: \"5:00.000\"}, class: css.speedInput})\n\taddTimeInput.addEventListener(\"blur\", () => {\n\t\taddTimeInput.value = formatTimeShort(parseTime(addTimeInput.value))\n\t})\n\taddTimeBlock.appendChild(addTimeInput)\n\n\twrap.appendChild(addTimeBlock)\n\n\troot.appendChild(wrap)\n\n\tfunction updateText(): void {\n\t\ttimeEl.textContent = formatTime(Math.round(timeAcc))\n\t}\n\n\tlet timeAcc = 0\n\tlet paused = false\n\tlet speed = 1\n\tlet lastUpdateTime = Date.now()\n\tconst updateTimer = () => {\n\t\trequestAnimationFrame(updateTimer)\n\t\tconst now = Date.now()\n\t\tconst dTime = (now - lastUpdateTime) * speed\n\t\tlastUpdateTime = now\n\t\tif(!paused){\n\t\t\ttimeAcc += dTime\n\t\t\tupdateText()\n\t\t}\n\t}\n\tupdateTimer()\n}",".timerRoot {\n\tbackground: #222;\n\tdisplay: flex;\n\tflex-direction: column;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n.wrap {\n\tdisplay: flex;\n\tflex-direction: column;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n.timer {\n\tfont-size: 5vw;\n\tcolor: #ccc;\n\tfont-family: 'courier new';\n}\n\n.speedInput, \n.button {\n\tfont-size: 2vw;\n\tcolor: #aaa;\n\tborder: 2px solid #aaa;\n\tbackground: #444;\n\tcursor: pointer;\n\ttransition: 0.25s;\n\tborder-radius: 3px;\n\n\tmargin: 0.5vw;\n}\n\n.speedInput:hover, \n.resetButton:hover {\n\tcolor: #fff;\n\tborder-color: #fff;\n\tbackground: #888;\n}\n\n.speedBlock {\n\tmargin: 0.5vw;\n\tfont-size: 2vw;\n\tcolor: #ccc;\n}\n\n.speedInput {\n\tmax-width: 5em;\n}","import {Binder, getBinder} from \"common/binder/binder\"\nimport {isRBox, MaybeRBoxed, unbox} from \"common/box\"\n\ntype ClassNamePart = MaybeRBoxed<string | null | undefined> | Record<string, MaybeRBoxed<boolean | undefined>>\nexport type ClassNameParts = ClassNamePart | ClassNamePart[]\n\n/** Utility function that assembles classname from parts */\nexport function makeClassname(binder: Binder | null, node: Node, parts: ClassNameParts, callback: (className: string) => void): Binder | null {\n\tconst arr = Array.isArray(parts) ? parts : [parts]\n\tfor(const item of arr){\n\t\tif(isRBox(item)){\n\t\t\t(binder ||= getBinder(node)).watch(item, makeClassnameAndCallTheCallback)\n\t\t} else if(item && typeof(item) === \"object\"){\n\t\t\tfor(const key in item){\n\t\t\t\tconst bool = item[key]\n\t\t\t\tif(isRBox(bool)){\n\t\t\t\t\t(binder ||= getBinder(node)).watch(bool, makeClassnameAndCallTheCallback)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction makeClassnameAndCallTheCallback() {\n\t\tconst result = []\n\t\tfor(const item of arr){\n\t\t\tif(item && typeof(item) === \"object\"){\n\t\t\t\tfor(const classname in item){\n\t\t\t\t\tif(unbox(item[classname])){\n\t\t\t\t\t\tresult.push(classname)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst classname = unbox(item)\n\t\t\t\tif(classname){\n\t\t\t\t\tresult.push(classname)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcallback(result.join(\" \"))\n\t}\n\n\tmakeClassnameAndCallTheCallback()\n\n\treturn binder\n}","import {Binder, getBinder} from \"common/binder/binder\"\nimport {isRBox, MaybeRBoxed, RBox, unbox, WBox} from \"common/box\"\nimport {ClassNameParts, makeClassname} from \"common/classname\"\nimport {FieldsOfObjectWithType, WritableKeysOf} from \"common/type_utils\"\n\ntype CssStyleAssignableKeys = WritableKeysOf<CSSStyleDeclaration> & FieldsOfObjectWithType<CSSStyleDeclaration, string>\n\ninterface TagDescription<K extends string = string, ThisType = unknown> {\n\treadonly tagName?: K\n\treadonly text?: MaybeRBoxed<string | number>\n\treadonly attrs?: {\n\t\treadonly [attrName: string]: MaybeRBoxed<string | number | undefined | null>\n\t}\n\treadonly on?: {\n\t\treadonly [k in keyof GlobalEventHandlersEventMap]?: (this: ThisType, evt: GlobalEventHandlersEventMap[k]) => void\n\t}\n\treadonly class?: ClassNameParts\n}\n\nexport interface HTMLTagDescription<K extends keyof HTMLElementTagNameMap = keyof HTMLElementTagNameMap> extends TagDescription<K, HTMLElementTagNameMap[K]> {\n\n\treadonly style?: {\n\t\treadonly [k in CssStyleAssignableKeys]?: MaybeRBoxed<string | number>\n\t}\n}\n\nexport type SVGTagDescription<K extends keyof SVGElementTagNameMap = keyof SVGElementTagNameMap> = TagDescription<K, SVGElementTagNameMap[K]>\n\ntype ChildArray = (Element | null | undefined)[] | RBox<(Element | null | undefined)[]>\n\n// typings are weird here, had to cast\nfunction resolveArgs<K>(a?: K | ChildArray, b?: ChildArray): [K, ChildArray | undefined] {\n\tif(!a){\n\t\treturn [{} as K, b]\n\t} else if(Array.isArray(a) || isRBox(a)){\n\t\treturn [{} as K, a as ChildArray]\n\t} else {\n\t\treturn [a as K, b]\n\t}\n}\n\nfunction populateTag<K extends string, T>(tagBase: Element, description: TagDescription<K, T>, children?: ChildArray): Binder | null {\n\tlet binder: Binder | null = null\n\n\tif(description.text){\n\t\tconst text = description.text\n\t\tif(isRBox(text)){\n\t\t\t(binder ||= getBinder(tagBase)).watch<string | number>(text, text => {\n\t\t\t\ttagBase.textContent = text + \"\"\n\t\t\t})\n\t\t}\n\t\ttagBase.textContent = unbox(text) + \"\"\n\t}\n\n\tif(description.on){\n\t\tfor(const evtName in description.on){\n\t\t\tconst handler = description.on[evtName as keyof GlobalEventHandlersEventMap]\n\t\t\t// I don't want to construct elaborat solid type here\n\t\t\t// I know the type will be correct, because it is enforced by function parameter type\n\t\t\t// so just be Any and that's it\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\ttagBase.addEventListener(evtName, handler as any, {passive: true, capture: false})\n\t\t}\n\t}\n\n\tfor(const k in description.attrs){\n\t\tconst v = description.attrs[k]\n\t\tif(isRBox(v)){\n\t\t\t(binder ||= getBinder(tagBase)).watch<string | number | null | undefined>(v, v => {\n\t\t\t\tif(v === null || v === undefined){\n\t\t\t\t\ttagBase.removeAttribute(k)\n\t\t\t\t} else {\n\t\t\t\t\ttagBase.setAttribute(k, v + \"\")\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\tconst vv = unbox(v)\n\t\tif(v !== null && v !== undefined){\n\t\t\ttagBase.setAttribute(k, vv + \"\")\n\t\t}\n\t}\n\n\tif(children){\n\t\tconst setChildren = (children: (Element | null | undefined)[]) => {\n\t\t\tconst childTags = children.filter(x => !!x) as Element[]\n\t\t\tupdateChildren(tagBase, childTags)\n\t\t}\n\n\t\tif(isRBox(children)){\n\t\t\t(binder ||= getBinder(tagBase)).watch(children, children => {\n\t\t\t\tsetChildren(children)\n\t\t\t})\n\t\t}\n\t\tsetChildren(unbox(children))\n\t}\n\n\tif(description.class){\n\t\tbinder = makeClassname(\n\t\t\tbinder,\n\t\t\ttagBase,\n\t\t\tdescription.class,\n\t\t\t// using classList here because on svg elements .className is readonly (in runtime)\n\t\t\tclassname => tagBase.classList.value = classname\n\t\t) || binder\n\t}\n\n\treturn binder\n}\n\nexport function tag(): HTMLDivElement\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(description: HTMLTagDescription<K>): HTMLElementTagNameMap[K]\nexport function tag(children: ChildArray): HTMLDivElement\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(description: HTMLTagDescription<K>, children: ChildArray): HTMLElementTagNameMap[K]\n\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(a?: HTMLTagDescription<K> | ChildArray, b?: ChildArray): HTMLElementTagNameMap[K] {\n\tconst [description, children] = resolveArgs(a, b)\n\n\tconst tagBase = document.createElement(description.tagName || \"div\")\n\n\tlet binder = populateTag(tagBase, description, children)\n\n\tif(description.style){\n\t\tfor(const k in description.style){\n\t\t\tconst v = description.style[k as CssStyleAssignableKeys]\n\t\t\tif(isRBox(v)){\n\t\t\t\t(binder ||= getBinder(tagBase)).watch<string | number>(v, v => {\n\t\t\t\t\ttagBase.style[k] = v + \"\"\n\t\t\t\t})\n\t\t\t}\n\t\t\ttagBase.style[k] = unbox(description.style[k]!) + \"\"\n\t\t}\n\t}\n\n\treturn tagBase as HTMLElementTagNameMap[K]\n}\n\nexport function svgTag(): SVGGElement\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(description: SVGTagDescription<K>): SVGElementTagNameMap[K]\nexport function svgTag(children: ChildArray): SVGGElement\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(description: SVGTagDescription<K>, children: ChildArray): SVGElementTagNameMap[K]\n\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(a?: SVGTagDescription<K> | ChildArray, b?: ChildArray): SVGElementTagNameMap[K] {\n\tconst [description, children] = resolveArgs(a, b)\n\n\tconst tagBase = document.createElementNS(\"http://www.w3.org/2000/svg\", description.tagName || \"g\")\n\n\tif(description.tagName === \"svg\"){\n\t\ttagBase.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\")\n\t}\n\n\tpopulateTag(tagBase, description, children)\n\n\treturn tagBase as SVGElementTagNameMap[K]\n}\n\nfunction updateChildren(parent: Element, newChildren: readonly Element[]): void {\n\tfor(let i = 0; i < newChildren.length; i++){\n\t\tconst childTag = newChildren[i]!\n\t\tconst x = parent.childNodes[i]\n\t\tif(x === childTag){\n\t\t\tcontinue\n\t\t}\n\t\tif(x){\n\t\t\tparent.insertBefore(childTag, x)\n\t\t} else {\n\t\t\tparent.appendChild(childTag)\n\t\t}\n\t}\n\n\twhile(parent.childNodes[newChildren.length]){\n\t\tparent.childNodes[newChildren.length]!.remove()\n\t}\n}\n\n/** Cached renderer for list of elements\n * Won't re-render an element if already has one for the value */\nexport function renderArray<T, K, E extends Element>(src: WBox<T[]>, getKey: (value: T) => K, render: (value: WBox<T>) => E): RBox<E[]>\nexport function renderArray<T, K, E extends Element>(src: RBox<T[]>, getKey: (value: T) => K, render: (value: RBox<T>) => E): RBox<E[]>\nexport function renderArray<T, K, E extends Element>(src: MaybeRBoxed<readonly T[]>, getKey: (value: T) => K, render: (value: MaybeRBoxed<T>) => E): E[]\nexport function renderArray<T, K, E extends Element>(src: MaybeRBoxed<readonly T[]> | WBox<T[]>, getKey: (value: T) => K, render: (value: WBox<T> | T) => E): Node[] | RBox<Node[]> {\n\tif(Array.isArray(src)){\n\t\treturn src.map(el => render(el))\n\t}\n\n\tconst map = new Map<WBox<T>, E>()\n\n\treturn (src as WBox<T[]>).wrapElements(getKey).map(itemBoxes => {\n\t\tconst leftoverBoxes = new Set(map.keys())\n\n\t\tconst result = itemBoxes.map(itemBox => {\n\t\t\tleftoverBoxes.delete(itemBox)\n\t\t\tlet el = map.get(itemBox)\n\t\t\tif(!el){\n\t\t\t\tel = render(itemBox)\n\t\t\t\tmap.set(itemBox, el)\n\t\t\t}\n\t\t\treturn el\n\t\t})\n\n\t\tfor(const oldBox of leftoverBoxes){\n\t\t\tmap.delete(oldBox)\n\t\t}\n\n\t\treturn result\n\t})\n}"],"names":["$g0JTA","parcelRequire","$85fafec3b85dd8b2$var$formatTime","time","ms","s","Math","floor","m","h","$85fafec3b85dd8b2$var$twoDigis","x","$85fafec3b85dd8b2$var$intOrZero","result","parseInt","Number","isNaN","isFinite","$85fafec3b85dd8b2$var$parseTime","parts","split","msec","length","secParts","secondsPart","msecPart","mult","i","$85fafec3b85dd8b2$export$f22da7240b7add18","root","classList","add","timerRoot","wrap","$aCP3q","tag","class","timeEl","timer","appendChild","resetBtn","tagName","text","button","addEventListener","timeAcc","updateText","pauseBtn","paused","value","speedBlock","speedInput","attrs","type","input","handler","lastValue","wrappedHandler","$85fafec3b85dd8b2$var$onAnyChange","parsed","parseFloat","speed","console","warn","JSON","stringify","addTimeBlock","addTimeButton","addTimeInput","textContent","round","replace","$85fafec3b85dd8b2$var$formatTimeShort","lastUpdateTime","Date","now","updateTimer","requestAnimationFrame","dTime","$ba803f58ba7028d1$export$9dc4ecf953986f04","$ba803f58ba7028d1$export$4997ffc0176396a6","$ba803f58ba7028d1$export$ac48f81997917406","$ba803f58ba7028d1$export$df1e6181cc5665bb","$ba803f58ba7028d1$export$fd786f21a988b067","$ba803f58ba7028d1$export$2ba01fb71ed41cb6","$0d27fb504028ccb8$export$4ded07f8b6ee4cea","binder","node","callback","arr","Array","isArray","item","$hsvBG","isRBox","$hIDiW","getBinder","watch","makeClassnameAndCallTheCallback","key","bool","classname","unbox","push","classname1","join","$4c0fbf616468c6ce$var$resolveArgs","a","b","$4c0fbf616468c6ce$var$populateTag","tagBase","description","children","on","evtName","passive","capture","k","v","removeAttribute","setAttribute","vv","setChildren","childTags","filter","parent","newChildren","childTag","childNodes","insertBefore","remove","$4c0fbf616468c6ce$var$updateChildren","$jM5hi","makeClassname","$4c0fbf616468c6ce$export$2b067c6666111485","document","createElement","style","$4c0fbf616468c6ce$export$e0e99c6b21dfde8d","createElementNS","setAttributeNS"],"version":3,"file":"timer.68bd9806.js.map"}