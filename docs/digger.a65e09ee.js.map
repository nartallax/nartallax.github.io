{"mappings":"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","sources":["src/sketches/digger/digger.ts","src/sketches/digger/digger_world.ts","src/common/bitmap.ts","src/common/rectangle_deduplicator.ts"],"sourcesContent":["import {DiggerWorld, DiggerWorldOptions} from \"./digger_world\"\n\nexport async function main(root: HTMLElement): Promise<void> {\n\tconst config: DiggerWorldOptions = {\n\t\twidthCells: 15,\n\t\theightCells: 10,\n\t\tscreenWidth: document.body.clientWidth,\n\t\tscreenHeight: document.body.clientHeight,\n\t\twallThickness: 0.1,\n\t\tcolors: {\n\t\t\tterrainA: \"#d45500\",\n\t\t\tterrainB: \"#aa4400\",\n\t\t\tterrainEmpty: \"#2b1100\"\n\t\t},\n\t\tdramaticDrawTiming: {\n\t\t\tterrain: 0.5\n\t\t}\n\t}\n\n\tconst world = new DiggerWorld(config)\n\troot.appendChild(world.el)\n\tworld.start()\n\n\tworld.digVertical(0, 0, 5)\n\tworld.digVertical(0, 0, 4)\n\n\t/*\n\tlet rects = [\n\t\t{x: 100, y: 100, w: 100, h: 100},\n\t\t{x: 175, y: 175, w: 100, h: 100},\n\t\t{x: 250, y: 125, w: 100, h: 100}\n\t]\n\n\tlet dedup = new RectanlgeDeduplicator()\n\trects.forEach(rect => dedup.add(rect))\n\tdocument.body.style.cssText = \"position: relative; width: 100vw; height: 100vh; background-color: #000\"\n\tfor(let rect of dedup.getNonIntersectingRects()){\n\t// for(let rect of rects){\n\t\tconsole.log(rect)\n\t\tdocument.body.appendChild(tag({\n\t\t\tstyle: {\n\t\t\t\tposition: \"absolute\",\n\t\t\t\ttop: rect.y + \"px\",\n\t\t\t\tleft: rect.x + \"px\",\n\t\t\t\twidth: rect.w + \"px\",\n\t\t\t\theight: rect.h + \"px\",\n\t\t\t\tbackgroundColor: \"rgba(255, 255, 255, 0.5)\",\n\t\t\t\tboxSizing: \"border-box\",\n\t\t\t\tborder: \"3px solid red\"\n\t\t\t}\n\t\t}))\n\t}\n\t*/\n}","import {tag} from \"@nartallax/cardboard-dom\"\nimport {Bitmap} from \"common/bitmap\"\nimport {RectanlgeDeduplicator} from \"common/rectangle_deduplicator\"\n\nexport interface DiggerWorldOptions {\n\treadonly widthCells: number\n\treadonly heightCells: number\n\treadonly screenHeight: number\n\treadonly screenWidth: number\n\treadonly wallThickness: number\n\treadonly dramaticDrawTiming: {\n\t\treadonly terrain: number\n\t}\n\treadonly colors: {\n\t\treadonly terrainA: string\n\t\treadonly terrainB: string\n\t\treadonly terrainEmpty: string\n\t}\n}\n\nenum GameState {\n\tDramaticDrawTerrain,\n\tRunning\n}\n\nexport class DiggerWorld {\n\n\tprivate readonly terrain: Bitmap\n\treadonly el: HTMLCanvasElement\n\tprivate readonly context: CanvasRenderingContext2D\n\tprivate state: GameState = GameState.Running\n\tprivate dramaticDrawProgress = 0\n\tprivate raf: number | null = null\n\tprivate readonly cellSizePx: number\n\tprivate readonly soilMarginLeft: number\n\t// private readonly soilMarginRight: number\n\t// private readonly soilMarginBottom: number\n\tprivate readonly playgroundWidthPx: number\n\t// private readonly playgroundHeightPx: number\n\n\treadonly invalidatedRects = new RectanlgeDeduplicator()\n\n\tconstructor(private readonly options: DiggerWorldOptions) {\n\n\t\tconst cellSizeByWidth = options.screenWidth / options.widthCells\n\t\tconst cellSizeByHeight = options.screenHeight / (options.heightCells + 1)\n\t\tthis.cellSizePx = Math.floor(Math.min(cellSizeByWidth, cellSizeByHeight))\n\t\tconst hMarginSum = options.screenWidth - (this.cellSizePx * options.widthCells)\n\t\tthis.soilMarginLeft = Math.ceil(hMarginSum / 2)\n\t\t// this.soilMarginRight = hMarginSum - this.soilMarginLeft\n\t\t// this.soilMarginBottom = options.screenHeight - (this.cellSizePx * (options.heightCells + 1))\n\t\tthis.playgroundWidthPx = options.widthCells * this.cellSizePx\n\t\t// this.playgroundHeightPx = options.heightCells * this.cellSizePx\n\n\t\tthis.terrain = new Bitmap((this.cellSizePx ** 2) * options.widthCells * options.heightCells)\n\t\tthis.terrain.setAll()\n\n\t\tthis.el = tag({\n\t\t\ttag: \"canvas\",\n\t\t\tattrs: {\n\t\t\t\twidth: options.screenWidth,\n\t\t\t\theight: options.screenHeight\n\t\t\t}\n\t\t})\n\t\tconst ctx = this.el.getContext(\"2d\")\n\t\tif(!ctx){\n\t\t\tthrow new Error(\"Browser can't canvas 2d\")\n\t\t}\n\t\tthis.context = ctx\n\n\t\tif(!requestAnimationFrame){\n\t\t\tthrow new Error(\"Browser can't RAF\")\n\t\t}\n\t}\n\n\t// screen coords here\n\tprivate drawTerrainPixelAt(x: number, y: number, isFull: boolean): void {\n\t\tthis.context.fillStyle\n\t\tthis.context.fillStyle = isFull\n\t\t\t? ((y & 0b1111) > 0b1000 ? ((y + x) & 0b1111) > 0b1000 : ((y - x) & 0b1111) < 0b1000)\n\t\t\t\t? this.options.colors.terrainA\n\t\t\t\t: this.options.colors.terrainB\n\t\t\t: this.options.colors.terrainEmpty\n\t\tthis.context.fillRect(x, y, 1, 1)\n\t}\n\n\t// playground coords here\n\tprivate redrawTerrainAt(x: number, y: number): void {\n\t\tthis.drawTerrainPixelAt(\n\t\t\tx + this.soilMarginLeft,\n\t\t\ty + this.cellSizePx,\n\t\t\tthis.terrain.get((y * this.playgroundWidthPx) + x)\n\t\t)\n\t}\n\n\tprivate dramaticDrawInitialTerrain(deltaTime: number): void {\n\t\tconst startAt = this.dramaticDrawProgress\n\n\t\tconst limit = this.options.screenWidth * (this.options.screenHeight - this.cellSizePx)\n\t\tconst drawSpeed = limit / this.options.dramaticDrawTiming.terrain\n\t\tconst pixelsToDraw = Math.floor(deltaTime * drawSpeed)\n\t\tthis.dramaticDrawProgress = Math.min(\n\t\t\tlimit,\n\t\t\tthis.dramaticDrawProgress + pixelsToDraw\n\t\t)\n\n\t\tfor(let i = startAt; i < this.dramaticDrawProgress; i++){\n\t\t\tconst x = (i % this.options.screenWidth)\n\t\t\tconst y = ((i - x) / this.options.screenWidth) + this.cellSizePx\n\t\t\tthis.drawTerrainPixelAt(x, y, true)\n\t\t}\n\n\t\tif(this.dramaticDrawProgress === limit){\n\t\t\tthis.state = GameState.Running\n\t\t\tthis.dramaticDrawProgress = 0\n\t\t}\n\t}\n\n\tinvalidate(x: number, y: number, w: number, h: number): void {\n\t\tthis.invalidatedRects.add({x, y, w, h})\n\t}\n\n\tprivate redrawInvalidatedRectangles(): void {\n\t\tfor(const rect of this.invalidatedRects.getNonIntersectingRects()){\n\t\t\tconst xLim = rect.x + rect.w\n\t\t\tconst yLim = rect.y + rect.h\n\t\t\tfor(let x = rect.x; x < xLim; x++){\n\t\t\t\tfor(let y = rect.y; y < yLim; y++){\n\t\t\t\t\tthis.redrawTerrainAt(x, y)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.invalidatedRects.clear()\n\t}\n\n\tprivate onTick(deltaTime: number): void {\n\t\tswitch(this.state){\n\t\t\tcase GameState.DramaticDrawTerrain:\n\t\t\t\tthis.dramaticDrawInitialTerrain(deltaTime)\n\t\t\t\treturn\n\t\t\tcase GameState.Running:\n\t\t\t\tthis.redrawInvalidatedRectangles()\n\t\t\t\t// draw objects here\n\t\t\t\treturn\n\t\t}\n\t}\n\n\tprivate reset(): void {\n\t\tthis.state = GameState.DramaticDrawTerrain\n\t\tthis.dramaticDrawProgress = 0\n\t}\n\n\tstart(): void {\n\t\tif(this.raf){\n\t\t\tthrow new Error(\"Already started\")\n\t\t}\n\n\t\tthis.reset()\n\n\t\tlet prevTime = 0\n\t\tconst doTick = (time: number) => {\n\t\t\tthis.raf = requestAnimationFrame(doTick)\n\t\t\tconst deltaTime = Math.min(1000 / 15, time - prevTime) / 1000\n\t\t\tprevTime = time\n\t\t\tthis.onTick(deltaTime)\n\t\t}\n\t\tdoTick(prevTime)\n\t}\n\n\tstop(): void {\n\t\tif(!this.raf){\n\t\t\tthrow new Error(\"Not started\")\n\t\t}\n\n\t\tcancelAnimationFrame(this.raf)\n\t\tthis.raf = null\n\t}\n\n\tdigVertical(cellX: number, startCellY: number, endCellY: number): void {\n\t\tif(startCellY > endCellY){\n\t\t\tconst buf = startCellY\n\t\t\tendCellY = startCellY\n\t\t\tstartCellY = buf\n\t\t}\n\t\tconst width = this.cellSizePx * (1 - this.options.wallThickness)\n\t\tconst xStart = (cellX * this.cellSizePx) - (width / 2)\n\t\tconst xEnd = xStart + width\n\t\tconst yStart = startCellY * this.cellSizePx\n\t\tconst yEnd = endCellY * this.cellSizePx\n\t\tfor(let y = yStart; y <= yEnd; y++){\n\t\t\tconst rowStart = (y * this.playgroundWidthPx)\n\t\t\tfor(let x = xStart; x <= xEnd; x++){\n\t\t\t\tthis.terrain.clear(rowStart + x)\n\t\t\t}\n\t\t}\n\t\tthis.invalidate(xStart, yStart, xEnd - xStart, yEnd - yStart)\n\t}\n\n}","/** An optimized array of bits (booleans) */\nexport class Bitmap {\n\tprivate readonly arr: Uint8Array\n\tconstructor(readonly size: number) {\n\t\tif(size < 0){\n\t\t\tthrow new Error(`Expected non-negative as size, got ${size}`)\n\t\t}\n\n\t\tif(size % 8){\n\t\t\tsize = Math.ceil(size / 8) * 8\n\t\t}\n\n\t\tthis.arr = new Uint8Array(size >> 3)\n\t}\n\n\t/** Set bit at selected index to 1 */\n\tset(index: number): void {\n\t\tconst arr = this.arr\n\t\tconst byteIndex = index >> 3\n\t\tarr[byteIndex] = arr[byteIndex]! | (1 << (index & 0b111))\n\t}\n\n\t/** Set bit at selected index to 0 */\n\tclear(index: number): void {\n\t\tconst arr = this.arr\n\t\tconst byteIndex = index >> 3\n\t\tarr[byteIndex] = arr[byteIndex]! & (~(1 << (index & 0b111)))\n\t}\n\n\t/** Get value of bit at index */\n\tget(index: number): boolean {\n\t\treturn (this.arr[index >> 3]! & (1 << (index & 0b111))) !== 0\n\t}\n\n\t/** Set value of all the bits to 1 */\n\tsetAll(): void {\n\t\tthis.arr.fill(0xff)\n\t}\n\n\t/** Set value of all the bits to 0 */\n\tclearAll(): void {\n\t\tthis.arr.fill(0)\n\t}\n\n\t/** @returns sorted array of offsets within [start, start + length] */\n\tgetOffsetsAsNumbers(start: number, length: number): number[] {\n\t\tif(start & 0x7 || length & 0x7){\n\t\t\tthrow new Error(\"Assertion failed, only byte-aligned start/length is supported\")\n\t\t}\n\t\tconst result: number[] = []\n\t\tlet i = 0\n\t\tfor(let byteOffset = 0; byteOffset < (length >> 3); byteOffset++){\n\t\t\tconst byte = this.arr[(start >> 3) + byteOffset]!\n\t\t\tlet mask = 0x1\n\t\t\twhile(mask !== 0x100){\n\t\t\t\tif(byte & mask){\n\t\t\t\t\tresult.push(i)\n\t\t\t\t}\n\t\t\t\ti++\n\t\t\t\tmask <<= 1\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n\n\t/** Sets to 1 every offset that is present in array of offsets and to 0 everything else\n\t * @param offsets sorted array of offsets\n\t * @returns if anything was changed */\n\tsetOffsetsByNumbers(start: number, length: number, offsets: number[]): boolean {\n\t\tif(start & 0x7 || length & 0x7){\n\t\t\tthrow new Error(\"Assertion failed, only byte-aligned start/length is supported\")\n\t\t}\n\t\tlet hasChange = false\n\t\tlet offset = 0\n\t\tlet offsetIndex = 0\n\t\tlet nextNonzeroOffset = offsets[offsetIndex]\n\t\tfor(let byteOffset = 0; byteOffset < (length >> 3); byteOffset++){\n\t\t\tconst origByte = this.arr[(start >> 3) + byteOffset]!\n\t\t\tlet byte = 0\n\t\t\tlet mask = 0x1\n\t\t\twhile(mask !== 0x100){\n\t\t\t\tconst bit = offset === nextNonzeroOffset ? mask : 0\n\t\t\t\thasChange = hasChange || (origByte & mask) !== bit\n\t\t\t\tif(bit){\n\t\t\t\t\tbyte |= mask\n\t\t\t\t\toffsetIndex++\n\t\t\t\t\tnextNonzeroOffset = offsets[offsetIndex]\n\t\t\t\t}\n\t\t\t\toffset++\n\t\t\t\tmask <<= 1\n\t\t\t}\n\t\t\tthis.arr[(start >> 3) + byteOffset] = byte\n\t\t}\n\t\treturn hasChange\n\t}\n\n\t/** Applies bitwise-and operation to this bitmap; saves result in this bitmap\n\t * Expecting other bitmap to be smaller than this one\n\t * @returns if this bitmap was changed\n\t */\n\tand(other: Bitmap, startThis: number): boolean {\n\t\tif(startThis & 0x7){\n\t\t\tthrow new Error(\"Assertion failed, only byte-aligned start/length is supported\")\n\t\t}\n\t\tlet hasChange = false\n\t\tfor(let byteOffset = 0; byteOffset < other.arr.length; byteOffset++){\n\t\t\tconst thisByte = this.arr[(startThis >> 3) + byteOffset]!\n\t\t\tconst otherByte = other.arr[byteOffset]!\n\t\t\tconst result = thisByte & otherByte\n\t\t\thasChange = hasChange || (result !== thisByte)\n\t\t\tthis.arr[(startThis >> 3) + byteOffset] = result\n\t\t}\n\t\treturn hasChange\n\t}\n\n\torFromTheStart(other: Bitmap): void {\n\t\tif(other.arr.length > this.arr.length){\n\t\t\tthrow new Error(\"Assertion failed, lengths are not equal\")\n\t\t}\n\t\tfor(let byteOffset = 0; byteOffset < other.arr.length; byteOffset++){\n\t\t\tthis.arr[byteOffset] = this.arr[byteOffset]! | other.arr[byteOffset]!\n\t\t}\n\t}\n\n}","interface Rect {\n\treadonly x: number\n\treadonly y: number\n\treadonly w: number\n\treadonly h: number\n}\n\ninterface Span {\n\treadonly a: number\n\treadonly b: number\n}\n\n/** A collection of rectangles.\n * Can return set of rectangles that occupy the same area, but don't intersect.\n * (useful in the case when you need to drop intersections) */\nexport class RectanlgeDeduplicator {\n\n\tprivate readonly rects: Rect[] = []\n\n\tadd(rect: Rect): void {\n\t\tthis.rects.push(rect)\n\t}\n\n\tclear(): void {\n\t\tthis.rects.length = 0\n\t}\n\n\t* getNonIntersectingRects(): IterableIterator<Rect> {\n\t\tfor(const lump of this.groupByLumps()){\n\t\t\tconst splitResult = [...this.splitLump(lump)]\n\t\t\tyield* dropDuplicates(splitResult)\n\t\t}\n\t}\n\n\t/** Packs rectangles into groups.\n\t * Rectangles in different groups never intersect.\n\t * Rectangles in same group has common area (maybe not directly, but through another rectangle) */\n\tprivate* groupByLumps(): IterableIterator<Rect[]> {\n\t\tfor(const vLump of groupByCond(this.rects, intersectionCondition(\"y\", \"h\"))){\n\t\t\tyield* groupByCond(vLump, intersectionCondition(\"x\", \"w\"))\n\t\t}\n\t}\n\n\tprivate* splitLump(lump: Rect[]): IterableIterator<Rect> {\n\t\tconst hBounds = findBoundaries(lump, \"x\", \"w\")\n\t\tconst vBounds = findBoundaries(lump, \"y\", \"h\")\n\t\tfor(const rect of lump){\n\t\t\tfor(const vRect of splitRectByBoundaries(rect, hBounds, \"x\", \"w\")){\n\t\t\t\tyield* splitRectByBoundaries(vRect, vBounds, \"y\", \"h\")\n\t\t\t}\n\t\t}\n\t}\n\n\n}\n\nfunction* groupByCond<T, G>(values: T[], condition: (a: T, b: T, g: G | null) => G | null): IterableIterator<T[]> {\n\tif(values.length === 0){\n\t\treturn\n\t}\n\n\tlet prev = values[0]!\n\tlet pack = [prev]\n\tlet groupData: G | null = null\n\tfor(let i = 1; i < values.length; i++){\n\t\tconst cur = values[i]!\n\t\tgroupData = condition(prev, cur, groupData)\n\t\tif(groupData){\n\t\t\tpack.push(cur)\n\t\t} else {\n\t\t\tyield pack\n\t\t\tpack = [cur]\n\t\t}\n\t\tprev = cur\n\t}\n\tyield pack\n}\n\nfunction intersectionCondition(coordField: \"x\" | \"y\", sizeField: \"w\" | \"h\"): (a: Rect, b: Rect, span: Span | null) => Span | null {\n\treturn (a, b, span) => {\n\t\tconst spanStart = span ? span.a : a[coordField]\n\t\tconst spanEnd = span ? span.b : a[coordField] + a[sizeField]\n\t\tif(b[coordField] + b[sizeField] < spanStart || b[coordField] > spanEnd){\n\t\t\treturn null\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ta: Math.min(spanStart, b[coordField]),\n\t\t\t\tb: Math.max(spanEnd, b[coordField] + b[sizeField])\n\t\t\t}\n\t\t}\n\t}\n}\n\n/** Returns sorted array of starts and ends of rectangles in a dimension\n * Duplicates are possible! */\nfunction findBoundaries(rects: Rect[], coordField: \"x\" | \"y\", sizeField: \"w\" | \"h\"): number[] {\n\tconst result = [] as number[]\n\n\tfor(let i = 0; i < rects.length; i++){\n\t\tconst rect = rects[i]!\n\t\tconst coord = rect[coordField]\n\t\tresult.push(coord, coord + rect[sizeField])\n\t}\n\n\treturn result.sort((a, b) => a - b)\n}\n\n/** Split rectangle by horisontal/vertical boundary, making more rectangles\n * Assumes boundaries are sorted */\nfunction* splitRectByBoundaries(rect: Rect, boundaries: number[], coordField: \"x\" | \"y\", sizeField: \"w\" | \"h\"): IterableIterator<Rect> {\n\tlet prevBound = boundaries[0]!\n\tfor(let j = 1; j < boundaries.length; j++){\n\t\tconst curBound = boundaries[j]!\n\t\tif(curBound === prevBound){\n\t\t\tcontinue\n\t\t}\n\t\tconst coord = rect[coordField]\n\t\tif(prevBound < coord){\n\t\t\tif(curBound > coord){\n\t\t\t\tyield{\n\t\t\t\t\t...rect,\n\t\t\t\t\t[sizeField]: curBound - coord\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst size = rect[sizeField]\n\t\t\tif(curBound < coord + size){\n\t\t\t\tyield{\n\t\t\t\t\t...rect,\n\t\t\t\t\t[coordField]: prevBound,\n\t\t\t\t\t[sizeField]: curBound - prevBound\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tyield{\n\t\t\t\t\t...rect,\n\t\t\t\t\t[coordField]: prevBound,\n\t\t\t\t\t[sizeField]: coord + size - prevBound\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tprevBound = curBound\n\t}\n}\n\nfunction* dropDuplicates(rects: Rect[]): IterableIterator<Rect> {\n\tif(rects.length < 1){\n\t\treturn\n\t}\n\n\trects = rects.sort((a, b) => (a.x - b.x) || (a.y - b.y))\n\tlet prevRect = rects[0]!\n\tyield prevRect\n\tif(rects.length < 2){\n\t\treturn\n\t}\n\n\tfor(let i = 1; i < rects.length; i++){\n\t\tconst rect = rects[i]!\n\t\tif(rect.x === prevRect.x && rect.y === prevRect.y && rect.h === prevRect.h && rect.w === prevRect.w){\n\t\t\tcontinue\n\t\t}\n\t\tyield rect\n\t\tprevRect = rect\n\t}\n}"],"names":["$d1Qaj","parcelRequire","async","$b9439f575dba7083$export$f22da7240b7add18","root","config","widthCells","heightCells","screenWidth","document","body","clientWidth","screenHeight","clientHeight","wallThickness","colors","terrainA","terrainB","terrainEmpty","dramaticDrawTiming","terrain","world","DiggerWorld","appendChild","el","start","digVertical","$7sHgZ","$af01df04fee5a419$var$GameState","GameState","$af01df04fee5a419$export$e7d8c2491f2c2a3a","constructor","options","state","Running","dramaticDrawProgress","raf","invalidatedRects","$cZ4Y3","RectanlgeDeduplicator","cellSizeByWidth","cellSizeByHeight","this","cellSizePx","Math","floor","min","hMarginSum","soilMarginLeft","ceil","playgroundWidthPx","$1VHh9","Bitmap","setAll","tag","attrs","width","height","ctx","getContext","Error","context","requestAnimationFrame","drawTerrainPixelAt","x","y","isFull","fillStyle","fillRect","redrawTerrainAt","get","dramaticDrawInitialTerrain","deltaTime","startAt","limit","drawSpeed","pixelsToDraw","i","invalidate","w","h","add","redrawInvalidatedRectangles","rect","getNonIntersectingRects","xLim","yLim","clear","onTick","DramaticDrawTerrain","reset","prevTime","doTick","time","stop","cancelAnimationFrame","cellX","startCellY","endCellY","xStart","xEnd","yStart","yEnd","rowStart","$665dc4e67c6f8c6a$export$3924f7882b5e2b61","size","arr","Uint8Array","set","index","byteIndex","fill","clearAll","getOffsetsAsNumbers","length","result","byteOffset","byte","mask","push","setOffsetsByNumbers","offsets","hasChange","offset","offsetIndex","nextNonzeroOffset","origByte","bit","and","other","startThis","thisByte","orFromTheStart","$f426c83f2b66182a$export$4f00dabc81d75002","rects","lump","groupByLumps","splitResult","splitLump","$f426c83f2b66182a$var$dropDuplicates","vLump","$f426c83f2b66182a$var$groupByCond","$f426c83f2b66182a$var$intersectionCondition","hBounds","$f426c83f2b66182a$var$findBoundaries","vBounds","vRect","$f426c83f2b66182a$var$splitRectByBoundaries","values","condition","prev","pack","groupData","cur","coordField","sizeField","a","b","span","spanStart","spanEnd","max","coord","sort","boundaries","prevBound","j","curBound","prevRect"],"version":3,"file":"digger.a65e09ee.js.map"}