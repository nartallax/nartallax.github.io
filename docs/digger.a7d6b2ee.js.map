{"mappings":"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","sources":["src/sketches/digger/digger.ts","src/common/bitmap.ts","src/common/rectangle_deduplicator.ts","src/common/classname.ts","src/common/tag.ts","src/sketches/digger/digger_world.ts"],"sourcesContent":["import {DiggerWorld, DiggerWorldOptions} from \"./digger_world\"\n\nexport async function main(root: HTMLElement): Promise<void> {\n\tconst config: DiggerWorldOptions = {\n\t\twidthCells: 15,\n\t\theightCells: 10,\n\t\tscreenWidth: document.body.clientWidth,\n\t\tscreenHeight: document.body.clientHeight,\n\t\twallThickness: 0.1,\n\t\tcolors: {\n\t\t\tterrainA: \"#d45500\",\n\t\t\tterrainB: \"#aa4400\",\n\t\t\tterrainEmpty: \"#2b1100\"\n\t\t},\n\t\tdramaticDrawTiming: {\n\t\t\tterrain: 0.5\n\t\t}\n\t}\n\n\tconst world = new DiggerWorld(config)\n\troot.appendChild(world.el)\n\tworld.start()\n\n\tworld.digVertical(0, 0, 5)\n\tworld.digVertical(0, 0, 4)\n\n\t/*\n\tlet rects = [\n\t\t{x: 100, y: 100, w: 100, h: 100},\n\t\t{x: 175, y: 175, w: 100, h: 100},\n\t\t{x: 250, y: 125, w: 100, h: 100}\n\t]\n\n\tlet dedup = new RectanlgeDeduplicator()\n\trects.forEach(rect => dedup.add(rect))\n\tdocument.body.style.cssText = \"position: relative; width: 100vw; height: 100vh; background-color: #000\"\n\tfor(let rect of dedup.getNonIntersectingRects()){\n\t// for(let rect of rects){\n\t\tconsole.log(rect)\n\t\tdocument.body.appendChild(tag({\n\t\t\tstyle: {\n\t\t\t\tposition: \"absolute\",\n\t\t\t\ttop: rect.y + \"px\",\n\t\t\t\tleft: rect.x + \"px\",\n\t\t\t\twidth: rect.w + \"px\",\n\t\t\t\theight: rect.h + \"px\",\n\t\t\t\tbackgroundColor: \"rgba(255, 255, 255, 0.5)\",\n\t\t\t\tboxSizing: \"border-box\",\n\t\t\t\tborder: \"3px solid red\"\n\t\t\t}\n\t\t}))\n\t}\n\t*/\n}","/** An optimized array of bits (booleans) */\nexport class Bitmap {\n\tprivate readonly arr: Uint8Array\n\tconstructor(readonly size: number) {\n\t\tif(size < 0){\n\t\t\tthrow new Error(`Expected non-negative as size, got ${size}`)\n\t\t}\n\n\t\tif(size % 8){\n\t\t\tsize = Math.ceil(size / 8) * 8\n\t\t}\n\n\t\tthis.arr = new Uint8Array(size >> 3)\n\t}\n\n\t/** Set bit at selected index to 1 */\n\tset(index: number): void {\n\t\tconst arr = this.arr\n\t\tconst byteIndex = index >> 3\n\t\tarr[byteIndex] = arr[byteIndex]! | (1 << (index & 0b111))\n\t}\n\n\t/** Set bit at selected index to 0 */\n\tclear(index: number): void {\n\t\tconst arr = this.arr\n\t\tconst byteIndex = index >> 3\n\t\tarr[byteIndex] = arr[byteIndex]! & (~(1 << (index & 0b111)))\n\t}\n\n\t/** Get value of bit at index */\n\tget(index: number): boolean {\n\t\treturn (this.arr[index >> 3]! & (1 << (index & 0b111))) !== 0\n\t}\n\n\t/** Set value of all the bits to 1 */\n\tsetAll(): void {\n\t\tfor(let i = 0; i < this.arr.length; i++){\n\t\t\tthis.arr[i] = 0xff\n\t\t}\n\t}\n\n\t/** Set value of all the bits to 0 */\n\tclearAll(): void {\n\t\tfor(let i = 0; i < this.arr.length; i++){\n\t\t\tthis.arr[i] = 0\n\t\t}\n\t}\n\n}","interface Rect {\n\treadonly x: number\n\treadonly y: number\n\treadonly w: number\n\treadonly h: number\n}\n\ninterface Span {\n\treadonly a: number\n\treadonly b: number\n}\n\n/** A collection of rectangles.\n * Can return set of rectangles that occupy the same area, but don't intersect.\n * (useful in the case when you need to drop intersections) */\nexport class RectanlgeDeduplicator {\n\n\tprivate readonly rects: Rect[] = []\n\n\tadd(rect: Rect): void {\n\t\tthis.rects.push(rect)\n\t}\n\n\tclear(): void {\n\t\tthis.rects.length = 0\n\t}\n\n\t* getNonIntersectingRects(): IterableIterator<Rect> {\n\t\tfor(const lump of this.groupByLumps()){\n\t\t\tconst splitResult = [...this.splitLump(lump)]\n\t\t\tyield* dropDuplicates(splitResult)\n\t\t}\n\t}\n\n\t/** Packs rectangles into groups.\n\t * Rectangles in different groups never intersect.\n\t * Rectangles in same group has common area (maybe not directly, but through another rectangle) */\n\tprivate* groupByLumps(): IterableIterator<Rect[]> {\n\t\tfor(const vLump of groupByCond(this.rects, intersectionCondition(\"y\", \"h\"))){\n\t\t\tyield* groupByCond(vLump, intersectionCondition(\"x\", \"w\"))\n\t\t}\n\t}\n\n\tprivate* splitLump(lump: Rect[]): IterableIterator<Rect> {\n\t\tconst hBounds = findBoundaries(lump, \"x\", \"w\")\n\t\tconst vBounds = findBoundaries(lump, \"y\", \"h\")\n\t\tfor(const rect of lump){\n\t\t\tfor(const vRect of splitRectByBoundaries(rect, hBounds, \"x\", \"w\")){\n\t\t\t\tyield* splitRectByBoundaries(vRect, vBounds, \"y\", \"h\")\n\t\t\t}\n\t\t}\n\t}\n\n\n}\n\nfunction* groupByCond<T, G>(values: T[], condition: (a: T, b: T, g: G | null) => G | null): IterableIterator<T[]> {\n\tif(values.length === 0){\n\t\treturn\n\t}\n\n\tlet prev = values[0]!\n\tlet pack = [prev]\n\tlet groupData: G | null = null\n\tfor(let i = 1; i < values.length; i++){\n\t\tconst cur = values[i]!\n\t\tgroupData = condition(prev, cur, groupData)\n\t\tif(groupData){\n\t\t\tpack.push(cur)\n\t\t} else {\n\t\t\tyield pack\n\t\t\tpack = [cur]\n\t\t}\n\t\tprev = cur\n\t}\n\tyield pack\n}\n\nfunction intersectionCondition(coordField: \"x\" | \"y\", sizeField: \"w\" | \"h\"): (a: Rect, b: Rect, span: Span | null) => Span | null {\n\treturn (a, b, span) => {\n\t\tconst spanStart = span ? span.a : a[coordField]\n\t\tconst spanEnd = span ? span.b : a[coordField] + a[sizeField]\n\t\tif(b[coordField] + b[sizeField] < spanStart || b[coordField] > spanEnd){\n\t\t\treturn null\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ta: Math.min(spanStart, b[coordField]),\n\t\t\t\tb: Math.max(spanEnd, b[coordField] + b[sizeField])\n\t\t\t}\n\t\t}\n\t}\n}\n\n/** Returns sorted array of starts and ends of rectangles in a dimension\n * Duplicates are possible! */\nfunction findBoundaries(rects: Rect[], coordField: \"x\" | \"y\", sizeField: \"w\" | \"h\"): number[] {\n\tconst result = [] as number[]\n\n\tfor(let i = 0; i < rects.length; i++){\n\t\tconst rect = rects[i]!\n\t\tconst coord = rect[coordField]\n\t\tresult.push(coord, coord + rect[sizeField])\n\t}\n\n\treturn result.sort((a, b) => a - b)\n}\n\n/** Split rectangle by horisontal/vertical boundary, making more rectangles\n * Assumes boundaries are sorted */\nfunction* splitRectByBoundaries(rect: Rect, boundaries: number[], coordField: \"x\" | \"y\", sizeField: \"w\" | \"h\"): IterableIterator<Rect> {\n\tlet prevBound = boundaries[0]!\n\tfor(let j = 1; j < boundaries.length; j++){\n\t\tconst curBound = boundaries[j]!\n\t\tif(curBound === prevBound){\n\t\t\tcontinue\n\t\t}\n\t\tconst coord = rect[coordField]\n\t\tif(prevBound < coord){\n\t\t\tif(curBound > coord){\n\t\t\t\tyield{\n\t\t\t\t\t...rect,\n\t\t\t\t\t[sizeField]: curBound - coord\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst size = rect[sizeField]\n\t\t\tif(curBound < coord + size){\n\t\t\t\tyield{\n\t\t\t\t\t...rect,\n\t\t\t\t\t[coordField]: prevBound,\n\t\t\t\t\t[sizeField]: curBound - prevBound\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tyield{\n\t\t\t\t\t...rect,\n\t\t\t\t\t[coordField]: prevBound,\n\t\t\t\t\t[sizeField]: coord + size - prevBound\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tprevBound = curBound\n\t}\n}\n\nfunction* dropDuplicates(rects: Rect[]): IterableIterator<Rect> {\n\tif(rects.length < 1){\n\t\treturn\n\t}\n\n\trects = rects.sort((a, b) => (a.x - b.x) || (a.y - b.y))\n\tlet prevRect = rects[0]!\n\tyield prevRect\n\tif(rects.length < 2){\n\t\treturn\n\t}\n\n\tfor(let i = 1; i < rects.length; i++){\n\t\tconst rect = rects[i]!\n\t\tif(rect.x === prevRect.x && rect.y === prevRect.y && rect.h === prevRect.h && rect.w === prevRect.w){\n\t\t\tcontinue\n\t\t}\n\t\tyield rect\n\t\tprevRect = rect\n\t}\n}","import {Binder, getBinder} from \"common/binder/binder\"\nimport {isRBox, MaybeRBoxed, unbox} from \"common/box\"\n\ntype ClassNamePart = MaybeRBoxed<string | null | undefined> | Record<string, MaybeRBoxed<boolean | undefined>>\nexport type ClassNameParts = ClassNamePart | ClassNamePart[]\n\n/** Utility function that assembles classname from parts */\nexport function makeClassname(binder: Binder | null, node: Node, parts: ClassNameParts, callback: (className: string) => void): Binder | null {\n\tconst arr = Array.isArray(parts) ? parts : [parts]\n\tfor(const item of arr){\n\t\tif(isRBox(item)){\n\t\t\t(binder ||= getBinder(node)).watch(item, makeClassnameAndCallTheCallback)\n\t\t} else if(item && typeof(item) === \"object\"){\n\t\t\tfor(const key in item){\n\t\t\t\tconst bool = item[key]\n\t\t\t\tif(isRBox(bool)){\n\t\t\t\t\t(binder ||= getBinder(node)).watch(bool, makeClassnameAndCallTheCallback)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction makeClassnameAndCallTheCallback() {\n\t\tconst result = []\n\t\tfor(const item of arr){\n\t\t\tif(item && typeof(item) === \"object\"){\n\t\t\t\tfor(const classname in item){\n\t\t\t\t\tif(unbox(item[classname])){\n\t\t\t\t\t\tresult.push(classname)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst classname = unbox(item)\n\t\t\t\tif(classname){\n\t\t\t\t\tresult.push(classname)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcallback(result.join(\" \"))\n\t}\n\n\tmakeClassnameAndCallTheCallback()\n\n\treturn binder\n}","import {Binder, getBinder} from \"common/binder/binder\"\nimport {isRBox, MaybeRBoxed, RBox, unbox, WBox} from \"common/box\"\nimport {ClassNameParts, makeClassname} from \"common/classname\"\nimport {FieldsOfObjectWithType, WritableKeysOf} from \"common/type_utils\"\n\ntype CssStyleAssignableKeys = WritableKeysOf<CSSStyleDeclaration> & FieldsOfObjectWithType<CSSStyleDeclaration, string>\n\ninterface TagDescription<K extends string = string, ThisType = unknown> {\n\treadonly tagName?: K\n\treadonly text?: MaybeRBoxed<string | number>\n\treadonly attrs?: {\n\t\treadonly [attrName: string]: MaybeRBoxed<string | number | undefined | null>\n\t}\n\treadonly on?: {\n\t\treadonly [k in keyof GlobalEventHandlersEventMap]?: (this: ThisType, evt: GlobalEventHandlersEventMap[k]) => void\n\t}\n\treadonly class?: ClassNameParts\n}\n\nexport interface HTMLTagDescription<K extends keyof HTMLElementTagNameMap = keyof HTMLElementTagNameMap> extends TagDescription<K, HTMLElementTagNameMap[K]> {\n\n\treadonly style?: {\n\t\treadonly [k in CssStyleAssignableKeys]?: MaybeRBoxed<string | number>\n\t}\n}\n\nexport type SVGTagDescription<K extends keyof SVGElementTagNameMap = keyof SVGElementTagNameMap> = TagDescription<K, SVGElementTagNameMap[K]>\n\ntype ChildArray = (Element | null | undefined)[] | RBox<(Element | null | undefined)[]>\n\n// typings are weird here, had to cast\nfunction resolveArgs<K>(a?: K | ChildArray, b?: ChildArray): [K, ChildArray | undefined] {\n\tif(!a){\n\t\treturn [{} as K, b]\n\t} else if(Array.isArray(a) || isRBox(a)){\n\t\treturn [{} as K, a as ChildArray]\n\t} else {\n\t\treturn [a as K, b]\n\t}\n}\n\nfunction populateTag<K extends string, T>(tagBase: Element, description: TagDescription<K, T>, children?: ChildArray): Binder | null {\n\tlet binder: Binder | null = null\n\n\tif(description.text){\n\t\tconst text = description.text\n\t\tif(isRBox(text)){\n\t\t\t(binder ||= getBinder(tagBase)).watch<string | number>(text, text => {\n\t\t\t\ttagBase.textContent = text + \"\"\n\t\t\t})\n\t\t}\n\t\ttagBase.textContent = unbox(text) + \"\"\n\t}\n\n\tif(description.on){\n\t\tfor(const evtName in description.on){\n\t\t\tconst handler = description.on[evtName as keyof GlobalEventHandlersEventMap]\n\t\t\t// I don't want to construct elaborat solid type here\n\t\t\t// I know the type will be correct, because it is enforced by function parameter type\n\t\t\t// so just be Any and that's it\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\ttagBase.addEventListener(evtName, handler as any, {passive: true, capture: false})\n\t\t}\n\t}\n\n\tfor(const k in description.attrs){\n\t\tconst v = description.attrs[k]\n\t\tif(isRBox(v)){\n\t\t\t(binder ||= getBinder(tagBase)).watch<string | number | null | undefined>(v, v => {\n\t\t\t\tif(v === null || v === undefined){\n\t\t\t\t\ttagBase.removeAttribute(k)\n\t\t\t\t} else {\n\t\t\t\t\ttagBase.setAttribute(k, v + \"\")\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\tconst vv = unbox(v)\n\t\tif(v !== null && v !== undefined){\n\t\t\ttagBase.setAttribute(k, vv + \"\")\n\t\t}\n\t}\n\n\tif(children){\n\t\tconst setChildren = (children: (Element | null | undefined)[]) => {\n\t\t\tconst childTags = children.filter(x => !!x) as Element[]\n\t\t\tupdateChildren(tagBase, childTags)\n\t\t}\n\n\t\tif(isRBox(children)){\n\t\t\t(binder ||= getBinder(tagBase)).watch(children, children => {\n\t\t\t\tsetChildren(children)\n\t\t\t})\n\t\t}\n\t\tsetChildren(unbox(children))\n\t}\n\n\tif(description.class){\n\t\tbinder = makeClassname(\n\t\t\tbinder,\n\t\t\ttagBase,\n\t\t\tdescription.class,\n\t\t\t// using classList here because on svg elements .className is readonly (in runtime)\n\t\t\tclassname => tagBase.classList.value = classname\n\t\t) || binder\n\t}\n\n\treturn binder\n}\n\nexport function tag(): HTMLDivElement\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(description: HTMLTagDescription<K>): HTMLElementTagNameMap[K]\nexport function tag(children: ChildArray): HTMLDivElement\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(description: HTMLTagDescription<K>, children: ChildArray): HTMLElementTagNameMap[K]\n\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(a?: HTMLTagDescription<K> | ChildArray, b?: ChildArray): HTMLElementTagNameMap[K] {\n\tconst [description, children] = resolveArgs(a, b)\n\n\tconst tagBase = document.createElement(description.tagName || \"div\")\n\n\tlet binder = populateTag(tagBase, description, children)\n\n\tif(description.style){\n\t\tfor(const k in description.style){\n\t\t\tconst v = description.style[k as CssStyleAssignableKeys]\n\t\t\tif(isRBox(v)){\n\t\t\t\t(binder ||= getBinder(tagBase)).watch<string | number>(v, v => {\n\t\t\t\t\ttagBase.style[k] = v + \"\"\n\t\t\t\t})\n\t\t\t}\n\t\t\ttagBase.style[k] = unbox(description.style[k]!) + \"\"\n\t\t}\n\t}\n\n\treturn tagBase as HTMLElementTagNameMap[K]\n}\n\nexport function svgTag(): SVGGElement\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(description: SVGTagDescription<K>): SVGElementTagNameMap[K]\nexport function svgTag(children: ChildArray): SVGGElement\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(description: SVGTagDescription<K>, children: ChildArray): SVGElementTagNameMap[K]\n\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(a?: SVGTagDescription<K> | ChildArray, b?: ChildArray): SVGElementTagNameMap[K] {\n\tconst [description, children] = resolveArgs(a, b)\n\n\tconst tagBase = document.createElementNS(\"http://www.w3.org/2000/svg\", description.tagName || \"g\")\n\n\tif(description.tagName === \"svg\"){\n\t\ttagBase.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\")\n\t}\n\n\tpopulateTag(tagBase, description, children)\n\n\treturn tagBase as SVGElementTagNameMap[K]\n}\n\nfunction updateChildren(parent: Element, newChildren: readonly Element[]): void {\n\tfor(let i = 0; i < newChildren.length; i++){\n\t\tconst childTag = newChildren[i]!\n\t\tconst x = parent.childNodes[i]\n\t\tif(x === childTag){\n\t\t\tcontinue\n\t\t}\n\t\tif(x){\n\t\t\tparent.insertBefore(childTag, x)\n\t\t} else {\n\t\t\tparent.appendChild(childTag)\n\t\t}\n\t}\n\n\twhile(parent.childNodes[newChildren.length]){\n\t\tparent.childNodes[newChildren.length]!.remove()\n\t}\n}\n\n/** Cached renderer for list of elements\n * Won't re-render an element if already has one for the value */\nexport function renderArray<T, K, E extends Element>(src: WBox<T[]>, getKey: (value: T) => K, render: (value: WBox<T>) => E): RBox<E[]>\nexport function renderArray<T, K, E extends Element>(src: RBox<T[]>, getKey: (value: T) => K, render: (value: RBox<T>) => E): RBox<E[]>\nexport function renderArray<T, K, E extends Element>(src: MaybeRBoxed<readonly T[]>, getKey: (value: T) => K, render: (value: MaybeRBoxed<T>) => E): E[]\nexport function renderArray<T, K, E extends Element>(src: MaybeRBoxed<readonly T[]> | WBox<T[]>, getKey: (value: T) => K, render: (value: WBox<T> | T) => E): Node[] | RBox<Node[]> {\n\tif(Array.isArray(src)){\n\t\treturn src.map(el => render(el))\n\t}\n\n\tconst map = new Map<WBox<T>, E>()\n\n\treturn (src as WBox<T[]>).wrapElements(getKey).map(itemBoxes => {\n\t\tconst leftoverBoxes = new Set(map.keys())\n\n\t\tconst result = itemBoxes.map(itemBox => {\n\t\t\tleftoverBoxes.delete(itemBox)\n\t\t\tlet el = map.get(itemBox)\n\t\t\tif(!el){\n\t\t\t\tel = render(itemBox)\n\t\t\t\tmap.set(itemBox, el)\n\t\t\t}\n\t\t\treturn el\n\t\t})\n\n\t\tfor(const oldBox of leftoverBoxes){\n\t\t\tmap.delete(oldBox)\n\t\t}\n\n\t\treturn result\n\t})\n}","import {Bitmap} from \"common/bitmap\"\nimport {RectanlgeDeduplicator} from \"common/rectangle_deduplicator\"\nimport {tag} from \"common/tag\"\n\nexport interface DiggerWorldOptions {\n\treadonly widthCells: number\n\treadonly heightCells: number\n\treadonly screenHeight: number\n\treadonly screenWidth: number\n\treadonly wallThickness: number\n\treadonly dramaticDrawTiming: {\n\t\treadonly terrain: number\n\t}\n\treadonly colors: {\n\t\treadonly terrainA: string\n\t\treadonly terrainB: string\n\t\treadonly terrainEmpty: string\n\t}\n}\n\nenum GameState {\n\tDramaticDrawTerrain,\n\tRunning\n}\n\nexport class DiggerWorld {\n\n\tprivate readonly terrain: Bitmap\n\treadonly el: HTMLCanvasElement\n\tprivate readonly context: CanvasRenderingContext2D\n\tprivate state: GameState = GameState.Running\n\tprivate dramaticDrawProgress = 0\n\tprivate raf: number | null = null\n\tprivate readonly cellSizePx: number\n\tprivate readonly soilMarginLeft: number\n\t// private readonly soilMarginRight: number\n\t// private readonly soilMarginBottom: number\n\tprivate readonly playgroundWidthPx: number\n\t// private readonly playgroundHeightPx: number\n\n\treadonly invalidatedRects = new RectanlgeDeduplicator()\n\n\tconstructor(private readonly options: DiggerWorldOptions) {\n\n\t\tconst cellSizeByWidth = options.screenWidth / options.widthCells\n\t\tconst cellSizeByHeight = options.screenHeight / (options.heightCells + 1)\n\t\tthis.cellSizePx = Math.floor(Math.min(cellSizeByWidth, cellSizeByHeight))\n\t\tconst hMarginSum = options.screenWidth - (this.cellSizePx * options.widthCells)\n\t\tthis.soilMarginLeft = Math.ceil(hMarginSum / 2)\n\t\t// this.soilMarginRight = hMarginSum - this.soilMarginLeft\n\t\t// this.soilMarginBottom = options.screenHeight - (this.cellSizePx * (options.heightCells + 1))\n\t\tthis.playgroundWidthPx = options.widthCells * this.cellSizePx\n\t\t// this.playgroundHeightPx = options.heightCells * this.cellSizePx\n\n\t\tthis.terrain = new Bitmap((this.cellSizePx ** 2) * options.widthCells * options.heightCells)\n\t\tthis.terrain.setAll()\n\n\t\tthis.el = tag({\n\t\t\ttagName: \"canvas\",\n\t\t\tattrs: {\n\t\t\t\twidth: options.screenWidth,\n\t\t\t\theight: options.screenHeight\n\t\t\t}\n\t\t})\n\t\tconst ctx = this.el.getContext(\"2d\")\n\t\tif(!ctx){\n\t\t\tthrow new Error(\"Browser can't canvas 2d\")\n\t\t}\n\t\tthis.context = ctx\n\n\t\tif(!requestAnimationFrame){\n\t\t\tthrow new Error(\"Browser can't RAF\")\n\t\t}\n\t}\n\n\t// screen coords here\n\tprivate drawTerrainPixelAt(x: number, y: number, isFull: boolean): void {\n\t\tthis.context.fillStyle\n\t\tthis.context.fillStyle = isFull\n\t\t\t? ((y & 0b1111) > 0b1000 ? ((y + x) & 0b1111) > 0b1000 : ((y - x) & 0b1111) < 0b1000)\n\t\t\t\t? this.options.colors.terrainA\n\t\t\t\t: this.options.colors.terrainB\n\t\t\t: this.options.colors.terrainEmpty\n\t\tthis.context.fillRect(x, y, 1, 1)\n\t}\n\n\t// playground coords here\n\tprivate redrawTerrainAt(x: number, y: number): void {\n\t\tthis.drawTerrainPixelAt(\n\t\t\tx + this.soilMarginLeft,\n\t\t\ty + this.cellSizePx,\n\t\t\tthis.terrain.get((y * this.playgroundWidthPx) + x)\n\t\t)\n\t}\n\n\tprivate dramaticDrawInitialTerrain(deltaTime: number): void {\n\t\tconst startAt = this.dramaticDrawProgress\n\n\t\tconst limit = this.options.screenWidth * (this.options.screenHeight - this.cellSizePx)\n\t\tconst drawSpeed = limit / this.options.dramaticDrawTiming.terrain\n\t\tconst pixelsToDraw = Math.floor(deltaTime * drawSpeed)\n\t\tthis.dramaticDrawProgress = Math.min(\n\t\t\tlimit,\n\t\t\tthis.dramaticDrawProgress + pixelsToDraw\n\t\t)\n\n\t\tfor(let i = startAt; i < this.dramaticDrawProgress; i++){\n\t\t\tconst x = (i % this.options.screenWidth)\n\t\t\tconst y = ((i - x) / this.options.screenWidth) + this.cellSizePx\n\t\t\tthis.drawTerrainPixelAt(x, y, true)\n\t\t}\n\n\t\tif(this.dramaticDrawProgress === limit){\n\t\t\tthis.state = GameState.Running\n\t\t\tthis.dramaticDrawProgress = 0\n\t\t}\n\t}\n\n\tinvalidate(x: number, y: number, w: number, h: number): void {\n\t\tthis.invalidatedRects.add({x, y, w, h})\n\t}\n\n\tprivate redrawInvalidatedRectangles(): void {\n\t\tfor(const rect of this.invalidatedRects.getNonIntersectingRects()){\n\t\t\tconst xLim = rect.x + rect.w\n\t\t\tconst yLim = rect.y + rect.h\n\t\t\tfor(let x = rect.x; x < xLim; x++){\n\t\t\t\tfor(let y = rect.y; y < yLim; y++){\n\t\t\t\t\tthis.redrawTerrainAt(x, y)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.invalidatedRects.clear()\n\t}\n\n\tprivate onTick(deltaTime: number): void {\n\t\tswitch(this.state){\n\t\t\tcase GameState.DramaticDrawTerrain:\n\t\t\t\tthis.dramaticDrawInitialTerrain(deltaTime)\n\t\t\t\treturn\n\t\t\tcase GameState.Running:\n\t\t\t\tthis.redrawInvalidatedRectangles()\n\t\t\t\t// draw objects here\n\t\t\t\treturn\n\t\t}\n\t}\n\n\tprivate reset(): void {\n\t\tthis.state = GameState.DramaticDrawTerrain\n\t\tthis.dramaticDrawProgress = 0\n\t}\n\n\tstart(): void {\n\t\tif(this.raf){\n\t\t\tthrow new Error(\"Already started\")\n\t\t}\n\n\t\tthis.reset()\n\n\t\tlet prevTime = 0\n\t\tconst doTick = (time: number) => {\n\t\t\tthis.raf = requestAnimationFrame(doTick)\n\t\t\tconst deltaTime = Math.min(1000 / 15, time - prevTime) / 1000\n\t\t\tprevTime = time\n\t\t\tthis.onTick(deltaTime)\n\t\t}\n\t\tdoTick(prevTime)\n\t}\n\n\tstop(): void {\n\t\tif(!this.raf){\n\t\t\tthrow new Error(\"Not started\")\n\t\t}\n\n\t\tcancelAnimationFrame(this.raf)\n\t\tthis.raf = null\n\t}\n\n\tdigVertical(cellX: number, startCellY: number, endCellY: number): void {\n\t\tif(startCellY > endCellY){\n\t\t\tconst buf = startCellY\n\t\t\tendCellY = startCellY\n\t\t\tstartCellY = buf\n\t\t}\n\t\tconst width = this.cellSizePx * (1 - this.options.wallThickness)\n\t\tconst xStart = (cellX * this.cellSizePx) - (width / 2)\n\t\tconst xEnd = xStart + width\n\t\tconst yStart = startCellY * this.cellSizePx\n\t\tconst yEnd = endCellY * this.cellSizePx\n\t\tfor(let y = yStart; y <= yEnd; y++){\n\t\t\tconst rowStart = (y * this.playgroundWidthPx)\n\t\t\tfor(let x = xStart; x <= xEnd; x++){\n\t\t\t\tthis.terrain.clear(rowStart + x)\n\t\t\t}\n\t\t}\n\t\tthis.invalidate(xStart, yStart, xEnd - xStart, yEnd - yStart)\n\t}\n\n}"],"names":["async","$b9439f575dba7083$export$f22da7240b7add18","root","config","widthCells","heightCells","screenWidth","document","body","clientWidth","screenHeight","clientHeight","wallThickness","colors","terrainA","terrainB","terrainEmpty","dramaticDrawTiming","terrain","world","$d1Qaj","DiggerWorld","appendChild","el","start","digVertical","$665dc4e67c6f8c6a$export$3924f7882b5e2b61","constructor","size","Error","Math","ceil","this","arr","Uint8Array","set","index","byteIndex","clear","get","setAll","i","length","clearAll","$f426c83f2b66182a$export$4f00dabc81d75002","rects","add","rect","push","getNonIntersectingRects","lump","groupByLumps","splitResult","splitLump","$f426c83f2b66182a$var$dropDuplicates","vLump","$f426c83f2b66182a$var$groupByCond","$f426c83f2b66182a$var$intersectionCondition","hBounds","$f426c83f2b66182a$var$findBoundaries","vBounds","vRect","$f426c83f2b66182a$var$splitRectByBoundaries","values","condition","prev","pack","groupData","cur","coordField","sizeField","a","b","span","spanStart","spanEnd","min","max","result","coord","sort","boundaries","prevBound","j","curBound","prevRect","x","y","h","w","$0d27fb504028ccb8$export$4ded07f8b6ee4cea","binder","node","parts","callback","Array","isArray","item","$hsvBG","isRBox","$hIDiW","getBinder","watch","makeClassnameAndCallTheCallback","key","bool","classname","unbox","classname1","join","$4c0fbf616468c6ce$var$resolveArgs","$4c0fbf616468c6ce$var$populateTag","tagBase","description","children","text","textContent","on","evtName","handler","addEventListener","passive","capture","k","attrs","v","removeAttribute","setAttribute","vv","setChildren","childTags","filter","parent","newChildren","childTag","childNodes","insertBefore","remove","$4c0fbf616468c6ce$var$updateChildren","class","$jM5hi","makeClassname","classList","value","$4c0fbf616468c6ce$export$2b067c6666111485","createElement","tagName","style","$4c0fbf616468c6ce$export$e0e99c6b21dfde8d","createElementNS","setAttributeNS","$af01df04fee5a419$var$GameState","GameState","$af01df04fee5a419$export$e7d8c2491f2c2a3a","options","state","Running","dramaticDrawProgress","raf","invalidatedRects","$cZ4Y3","RectanlgeDeduplicator","cellSizeByWidth","cellSizeByHeight","cellSizePx","floor","hMarginSum","soilMarginLeft","playgroundWidthPx","$1VHh9","Bitmap","$aCP3q","tag","width","height","ctx","getContext","context","requestAnimationFrame","drawTerrainPixelAt","isFull","fillStyle","fillRect","redrawTerrainAt","dramaticDrawInitialTerrain","deltaTime","startAt","limit","drawSpeed","pixelsToDraw","invalidate","redrawInvalidatedRectangles","xLim","yLim","onTick","DramaticDrawTerrain","reset","prevTime","doTick","time","stop","cancelAnimationFrame","cellX","startCellY","endCellY","xStart","xEnd","yStart","yEnd","rowStart"],"version":3,"file":"digger.a7d6b2ee.js.map"}