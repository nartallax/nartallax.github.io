(
function imploderLoader(defs, params, evl) {
    "use strict";
    var req = typeof (require) !== "undefined" ? require : function () { throw new Error("External require() function is not defined! Could not load any external module."); };
    function handleError(e, action) {
        var handler = params.errorHandler;
        if (handler) {
            handler(e, action);
        }
        else {
            console.error((action ? "Error during " + action + ": " : "") + (e.stack || e.message || e));
        }
        throw e;
    }
    // разбираем полученный массив определений
    var renames = {};
    var defMap = {};
    for (var i = 0; i < defs.length; i++) {
        var v = defs[i];
        var m = typeof (v[2]) !== "string" ? v[2] : undefined;
        var def = m ? m : {};
        def.name = v[0];
        def.code = v[v.length - 1];
        if (m && m.altName) {
            renames[m.altName] = def.name;
        }
        def.dependencies = Array.isArray(v[1]) ? v[1] : [];
        defMap[def.name] = def;
    }
    var amd = typeof (define) === "function" && !!define.amd;
    /** функция, которую будут дергать в качестве require изнутри модулей */
    function requireAny(names, onOk, onError) {
        if (!onOk) {
            // дернуты как commonjs, т.е. синхронно с одним именем
            var name_1 = names;
            if (name_1 in defMap) {
                return getProduct(name_1);
            }
            else {
                // тут мы просто надеемся, что человек, который пишет код - не дурак
                // и знает, в каком окружении он будет запускаться
                // и поэтому просто дергаем require как commonjs синхронный require
                return req(name_1);
            }
        }
        else {
            // дернуты как amd
            var callError = function (e) {
                if (onError) {
                    onError(e);
                }
                else {
                    handleError(e);
                }
            };
            try {
                var nameArr = Array.isArray(names) ? names : [names];
                var resultArr_1 = [];
                var nameIndex_1 = {};
                var externalNameArr_1 = nameArr.filter(function (name, index) {
                    nameIndex_1[name] = index;
                    if (name in defMap) {
                        resultArr_1[index] = getProduct(name);
                        return false;
                    }
                    return true;
                });
                if (externalNameArr_1.length === 0) {
                    return onOk.apply(null, resultArr_1);
                }
                else {
                    if (amd) {
                        return req(externalNameArr_1, function (externalResults) {
                            for (var i = 0; i < externalNameArr_1.length; i++) {
                                resultArr_1[nameIndex_1[externalNameArr_1[i]]] = externalResults[i];
                            }
                            onOk.apply(null, resultArr_1);
                        }, onError);
                    }
                    else {
                        // если у нас запросили модули асинхронно, но при этом у нас есть только синрохнный commonjs-овый require - 
                        // то используем его, чего еще делать
                        externalNameArr_1.forEach(function (name) { return resultArr_1[nameIndex_1[name]] = req(name); });
                        onOk.apply(null, resultArr_1);
                    }
                }
            }
            catch (e) {
                callError(e);
            }
        }
    }
    var currentlyDefiningProductMap = {};
    var currentlyDefiningProductSeq = [];
    var products = {};
    function throwCircularDependencyError(name) {
        if (currentlyDefiningProductSeq.length === 1 &&
            currentlyDefiningProductSeq[0] === name) {
            throw new Error("Module imports itself: " + name + ". It's not clear what exactly do you want.");
        }
        var str = name;
        for (var i = currentlyDefiningProductSeq.length - 1; i >= 0; i--) {
            var n = currentlyDefiningProductSeq[i];
            str += " <- " + currentlyDefiningProductSeq[i];
            if (n === name)
                break;
        }
        throw new Error("Unresolvable circular dependency detected: " + str);
    }
    function getProduct(name) {
        name = renames[name] || name;
        var meta = defMap[name];
        if (!(name in products)) {
            if (name in currentlyDefiningProductMap) {
                throwCircularDependencyError(name);
            }
            currentlyDefiningProductMap[name] = true;
            currentlyDefiningProductSeq.push(name);
            try {
                var product = {};
                var deps_1 = [product, requireAny];
                meta.dependencies.forEach(function (name) {
                    if (name in renames) {
                        name = renames[name];
                    }
                    var product = products[name];
                    if (product) {
                        deps_1.push(product);
                        return;
                    }
                    var depMeta = defMap[name];
                    if (!depMeta) {
                        throw new Error("Failed to get module \"" + name + "\": no definition is known and no preloaded external module is present.");
                    }
                    deps_1.push(depMeta.arbitraryType || (!depMeta.exports && !depMeta.exportRefs) ? getProduct(name) : getProxy(depMeta));
                });
                var fullCode = meta.code;
                if (meta.nonModule) {
                    fullCode = "function(){" + fullCode + "}";
                }
                fullCode = "'use strict';(" + fullCode + ")\n//# sourceURL=" + meta.name;
                var defFunc = evl(fullCode);
                var returnProduct = defFunc.apply(null, deps_1);
                if (meta.arbitraryType) {
                    product = returnProduct;
                }
                products[name] = product;
            }
            finally {
                delete currentlyDefiningProductMap[name];
                currentlyDefiningProductSeq.pop();
            }
        }
        return products[name];
    }
    var proxies = {};
    function getProxy(def) {
        if (!(def.name in proxies)) {
            var proxy_1 = {};
            getAllExportNames(def).forEach(function (arr) {
                arr.forEach(function (name) {
                    defineProxyProp(def, proxy_1, name);
                });
            });
            proxies[def.name] = proxy_1;
        }
        return proxies[def.name];
    }
    function getAllExportNames(meta, result, noDefault) {
        if (result === void 0) { result = []; }
        if (noDefault === void 0) { noDefault = false; }
        if (meta.exports) {
            if (noDefault) {
                result.push(meta.exports.filter(function (_) { return _ !== "default"; }));
            }
            else {
                result.push(meta.exports);
            }
        }
        if (meta.exportRefs) {
            meta.exportRefs.forEach(function (ref) {
                // тут, теоретически, могла бы возникнуть бесконечная рекурсия
                // но не возникнет, еще при компиляции есть проверка
                if (ref in defMap) {
                    getAllExportNames(defMap[ref], result, true);
                }
                else if (ref in products) {
                    // модуля может не быть, если он внешний и в бандл не вошел
                    result.push(Object.keys(products[ref]));
                }
                else {
                    // такого по идее произойти не должно никогда, т.к. оно упадет раньше
                    // еще на этапе подгрузки внешних модулей
                    throw new Error("External module " + ref + " is not loaded at required time.");
                }
            });
        }
        return result;
    }
    function defineProxyProp(meta, proxy, name) {
        if (proxy.hasOwnProperty(name)) {
            return;
        }
        Object.defineProperty(proxy, name, {
            get: function () { return getProduct(meta.name)[name]; },
            set: function (v) { return getProduct(meta.name)[name] = v; },
            enumerable: true
        });
    }
    function discoverExternalModules(result) {
        if (result === void 0) { result = {}; }
        for (var moduleName in defMap) {
            defMap[moduleName].dependencies.forEach(function (dep) {
                if (!(dep in defMap)) {
                    result[dep] = true;
                }
            });
        }
        return Object.keys(result).sort();
    }
    function afterExternalsLoaded() {
        var mainProduct = getProduct(params.entryPoint.module);
        // инициализируем все модули в бандле, ради сайд-эффектов
        Object.keys(defMap).forEach(function (name) {
            if (!(name in products)) {
                getProduct(name);
            }
        });
        var err = null;
        if (params.entryPoint.function) {
            try {
                mainProduct[params.entryPoint.function].apply(null, params.entryPointArgs || []);
            }
            catch (e) {
                err = e;
            }
        }
        if (err) {
            handleError(err);
        }
        if (typeof (module) === "object" && module.exports) {
            module.exports = mainProduct;
        }
        return mainProduct;
    }
    function start() {
        if (amd) {
            var externalModuleNames_1 = discoverExternalModules({ "require": true });
            define(externalModuleNames_1, function (require) {
                req = require;
                for (var i = externalModuleNames_1.length; i < arguments.length; i++) {
                    products[externalModuleNames_1[i]] = arguments[i];
                }
                return afterExternalsLoaded();
            });
        }
        else {
            var externalModuleNames_2 = discoverExternalModules();
            requireAny(externalModuleNames_2, function () {
                for (var i = 0; i < arguments.length; i++) {
                    products[externalModuleNames_2[i]] = arguments[i];
                }
                afterExternalsLoaded();
            });
        }
    }
    start();
})(

[["/engine/board",["/engine/context","/engine/quad_tree/quad_tree","/engine/quad_tree/rectangle_quad_tree"],{"exports":["BoardImpl"]},"function (exports, require, context_1, quad_tree_1, rectangle_quad_tree_1) {\n    class BoardImpl {\n        constructor() {\n            this.critters = new quad_tree_1.QuadTree(2);\n            this.buildings = new rectangle_quad_tree_1.RectangleQuadTree(4);\n            this.ticksPassed = 0;\n            this.timePassed = 0;\n        }\n        addObject(object) {\n            object.onAdded();\n        }\n        removeObject(object) {\n            object.onRemoved();\n        }\n        tick(deltaTime) {\n            context_1.context.performeter.enterBlock(\"tick\");\n            context_1.context.performeter.enterBlock(\"camera\");\n            context_1.context.camera.tick(deltaTime);\n            context_1.context.performeter.exitEnterBlock(\"input\");\n            context_1.context.inputProcessor.onTick(deltaTime, context_1.context.input.takeEvents());\n            context_1.context.performeter.exitEnterBlock(\"inertial\");\n            context_1.context.inertialObjectsController.tick(deltaTime);\n            context_1.context.performeter.exitEnterBlock(\"scene\");\n            context_1.context.scene.tick(deltaTime);\n            context_1.context.performeter.exitEnterBlock(\"ticker\");\n            context_1.context.ticker.tick(deltaTime);\n            context_1.context.performeter.exitEnterBlock(\"tasker\");\n            context_1.context.tasker.tick(deltaTime);\n            context_1.context.performeter.exitBlock();\n            this.ticksPassed++;\n            this.timePassed += deltaTime;\n            context_1.context.performeter.exitBlock();\n            context_1.context.performeter.tick();\n        }\n        start() {\n            let lastTickTime = 0;\n            let handler = (now) => {\n                let deltaTime = (now - lastTickTime) / 1000;\n                if (deltaTime < 1) {\n                    this.tick(deltaTime);\n                }\n                lastTickTime = now;\n                requestAnimationFrame(handler);\n            };\n            requestAnimationFrame(handler);\n        }\n    }\n    exports.BoardImpl = BoardImpl;\n}\n"],["/engine/context",["/engine/board","/engine/input_controller","/engine/graphics/camera","/engine/graphics/scene","/engine/object_ticker","/engine/object_tasker","/generic/perfometer","/engine/inertial_object_controller","/engine/input_processor","/entities/critter/player_character"],{"exports":["context","createContext"]},"function (exports, require, board_1, input_controller_1, camera_1, scene_1, object_ticker_1, object_tasker_1, perfometer_1, inertial_object_controller_1, input_processor_1, player_character_1) {\n    exports.context = null;\n    function createContext(container) {\n        exports.context = {\n            board: new board_1.BoardImpl(),\n            camera: new camera_1.CameraImpl(),\n            scene: new scene_1.Scene(container),\n            input: new input_controller_1.InputControllerImpl(),\n            inputProcessor: new input_processor_1.InputProcessorImpl(),\n            ticker: new object_ticker_1.ObjectTickerImpl(),\n            tasker: new object_tasker_1.ObjectTaskerImpl(),\n            performeter: new perfometer_1.Perfometer(-1),\n            inertialObjectsController: new inertial_object_controller_1.InertialObjectControllerImpl(),\n            playerCharacter: new player_character_1.Player(0, 0)\n        };\n        window.context = exports.context;\n    }\n    exports.createContext = createContext;\n}\n"],["/engine/entities/grid_bound_entity",["/engine/world_object"],"function (exports, require, world_object_1) {\n    class GridBoundEntity extends world_object_1.WorldObjectBaseImpl {\n        constructor(x, y, direction) {\n            super(x, y);\n            this.direction = direction;\n        }\n        get effectiveWidth() {\n            return this.direction === 0 || this.direction === 2 ? this.width : this.height;\n        }\n        get effectiveHeight() {\n            return this.direction === 0 || this.direction === 2 ? this.height : this.width;\n        }\n        updatePositionRotation() {\n            let offsetX = 0;\n            let offsetY = 0;\n            if (this.height !== this.width && (this.direction === 1 || this.direction === 3)) {\n                let offset = (this.width - this.height) / 2;\n                offsetX = -offset;\n                offsetY = offset;\n            }\n            this.model.setPositionRotation(this.x + offsetX, this.y + offsetY, -this.direction * Math.PI / 2);\n        }\n        onGraphicMoved() {\n            super.onGraphicMoved();\n            this.updatePositionRotation();\n        }\n        onRotated(newDirection) {\n            this.direction = newDirection;\n            if (this.model) {\n                this.updatePositionRotation();\n            }\n        }\n        onGraphicAdded() {\n            super.onGraphicAdded();\n            this.updatePositionRotation();\n        }\n    }\n    exports.GridBoundEntity = GridBoundEntity;\n}\n"],["/engine/entities/inertial_object",["/engine/context","/engine/world_object"],{"exports":["InertialObject"]},"function (exports, require, context_1, world_object_1) {\n    class InertialObject extends world_object_1.WorldObjectBaseImpl {\n        constructor() {\n            super(...arguments);\n            this.xSpeed = 0;\n            this.ySpeed = 0;\n            this.deceleration = 0.1;\n            this.direction = 0;\n        }\n        moveOnTick(deltaTime) {\n            let x = this.x + deltaTime * this.xSpeed;\n            let y = this.y + deltaTime * this.ySpeed;\n            let dSpeed = deltaTime * this.deceleration;\n            let dxSpeed = dSpeed * Math.cos(this.direction);\n            let dySpeed = dSpeed * Math.sin(this.direction);\n            this.xSpeed = this.xSpeed > 0\n                ? this.xSpeed < dxSpeed ? 0 : this.xSpeed - dxSpeed\n                : this.xSpeed > dxSpeed ? 0 : this.xSpeed - dxSpeed;\n            this.ySpeed = this.ySpeed > 0\n                ? this.ySpeed < dySpeed ? 0 : this.ySpeed - dySpeed\n                : this.ySpeed > dySpeed ? 0 : this.ySpeed - dySpeed;\n            this.move(x, y);\n        }\n        onGraphicMoved() {\n            this.model.setPosition(this.x, this.y);\n        }\n        canMoveOnTick() {\n            return this.xSpeed !== 0 || this.ySpeed !== 0;\n        }\n        push(force, direction) {\n            this.xSpeed += force * Math.cos(direction);\n            this.ySpeed += force * Math.sin(direction);\n            context_1.context.inertialObjectsController.onSpeedChanged(this);\n            this.direction = Math.atan2(this.ySpeed, this.xSpeed);\n            if (this.model) {\n                this.model.setRotation(this.direction);\n            }\n        }\n    }\n    exports.InertialObject = InertialObject;\n}\n"],["/engine/entities/terrain",["/engine/entities/grid_bound_entity","/engine/world_object"],"function (exports, require, grid_bound_entity_1, world_object_1) {\n    class Terrain extends grid_bound_entity_1.GridBoundEntity {\n        static registerModel(def) {\n            let result = {\n                width: 1,\n                height: 1,\n                layer: \"terrain\",\n                ...def\n            };\n            world_object_1.objectModelMapping.define(this, result);\n            return result;\n        }\n    }\n    exports.Terrain = Terrain;\n}\n"],["/engine/graphics/camera",["/engine/context","/generic/event"],{"exports":["CameraImpl"]},"function (exports, require, context_1, event_1) {\n    function makeScheduledMove(object, targetX, targetY, speed) {\n        let dx = targetX - object.x;\n        let dy = targetY - object.y;\n        let time = Math.sqrt((dx * dx) + (dy * dy)) / speed;\n        dx /= time;\n        dy /= time;\n        let direction = Math.atan(dy / dx);\n        if (dx < 0) {\n            direction += Math.PI;\n        }\n        return {\n            dx, dy, x: targetX, y: targetY, timeLeft: time, direction\n        };\n    }\n    const cameraMovementTime = 0.15;\n    const minZoom = 16;\n    const maxZoom = 256;\n    class CameraImpl {\n        constructor() {\n            this.x = 0;\n            this.y = 0;\n            this.zoom = 1;\n            this.scheduledMovement = null;\n            this.scheduledZoom = null;\n            this.objectToFollow = null;\n            this.onMove = (0, event_1.makeEvent)();\n            this.onZoom = (0, event_1.makeEvent)();\n        }\n        zoomRelative(mult) {\n            var _a, _b;\n            let oldZoom = (_b = (_a = this.scheduledZoom) === null || _a === void 0 ? void 0 : _a.target) !== null && _b !== void 0 ? _b : this.zoom;\n            return this.zoomTo(oldZoom * mult);\n        }\n        zoomTo(newZoom) {\n            var _a, _b;\n            newZoom = Math.min(maxZoom, Math.max(minZoom, newZoom));\n            let rem = ((newZoom % 1) + 1) % 1;\n            if (rem < 0.001 || rem > 0.999) {\n                newZoom = Math.round(newZoom);\n            }\n            let oldZoom = (_b = (_a = this.scheduledZoom) === null || _a === void 0 ? void 0 : _a.target) !== null && _b !== void 0 ? _b : this.zoom;\n            if (oldZoom === newZoom) {\n                return;\n            }\n            this.scheduledZoom = {\n                target: newZoom,\n                source: this.zoom,\n                distance: newZoom - this.zoom,\n                timeLeft: cameraMovementTime\n            };\n        }\n        moveTo(x, y) {\n            if (Math.abs(this.x - x) < 0.01 && Math.abs(this.y - y) < 0.01) {\n                return;\n            }\n            let dx = x - this.x;\n            let dy = y - this.y;\n            let speed = Math.sqrt(dx * dx + dy * dy) / cameraMovementTime;\n            this.scheduledMovement = makeScheduledMove(this, x, y, speed);\n        }\n        tick(deltaTime) {\n            this.scheduleByFollowingObject();\n            let moved = this.moveBySchedule(deltaTime);\n            let zoomed = this.zoomBySchedule(deltaTime);\n            if (moved || zoomed) {\n                context_1.context.scene.onCameraChanged();\n            }\n        }\n        scheduleByFollowingObject() {\n            if (!this.objectToFollow) {\n                return;\n            }\n            this.moveTo(this.objectToFollow.x, this.objectToFollow.y);\n        }\n        moveBySchedule(deltaTime) {\n            if (!this.scheduledMovement) {\n                return false;\n            }\n            if (this.scheduledMovement.timeLeft <= deltaTime) {\n                this.x = this.scheduledMovement.x;\n                this.y = this.scheduledMovement.y;\n                this.scheduledMovement = null;\n            }\n            else {\n                this.x += this.scheduledMovement.dx * deltaTime;\n                this.y += this.scheduledMovement.dy * deltaTime;\n                this.scheduledMovement.timeLeft -= deltaTime;\n            }\n            this.onMove.fire();\n            return true;\n        }\n        zoomBySchedule(deltaTime) {\n            if (!this.scheduledZoom) {\n                return false;\n            }\n            if (this.scheduledZoom.timeLeft <= deltaTime) {\n                this.zoom = this.scheduledZoom.target;\n                this.scheduledZoom = null;\n            }\n            else {\n                let movePercent = this.scheduledZoom.timeLeft / cameraMovementTime;\n                movePercent = Math.pow(movePercent, 4);\n                this.zoom = this.scheduledZoom.source + this.scheduledZoom.distance * (1 - movePercent);\n                this.scheduledZoom.timeLeft -= deltaTime;\n            }\n            this.onZoom.fire();\n            return true;\n        }\n        follow(object) {\n            this.objectToFollow = object;\n        }\n    }\n    exports.CameraImpl = CameraImpl;\n}\n"],["/engine/graphics/gl_utils","function (exports, require) {\n    class GlUtils {\n        constructor(setupFn) {\n            this.setupFn = setupFn;\n            this.gl = null;\n            this.program = null;\n            this.loseContextExt = null;\n            this.canvas = null;\n            window.loseWebglContext = () => { var _a; return (_a = this.loseContextExt) === null || _a === void 0 ? void 0 : _a.loseContext(); };\n            window.restoreWebglContext = () => { var _a; return (_a = this.loseContextExt) === null || _a === void 0 ? void 0 : _a.restoreContext(); };\n        }\n        setup() {\n            this.gl = null;\n            this.program = null;\n            this.canvas = document.createElement(\"canvas\");\n            this.canvas.addEventListener(\"webglcontextlost\", e => {\n                e.preventDefault();\n                console.warn(\"WebGL context lost.\");\n                this.gl = null;\n                this.program = null;\n            });\n            this.canvas.addEventListener(\"webglcontextcreationerror\", function (e) {\n                console.log(e.statusMessage || (\"Failed to create webgl context: \" + e));\n            }, false);\n            this.canvas.addEventListener(\"webglcontextrestored\", e => {\n                e.preventDefault();\n                console.warn(\"WebGL context restored.\");\n                if (!this.gl) {\n                    this.setup();\n                }\n            });\n            let gl = this.canvas.getContext(\"webgl2\");\n            if (!gl) {\n                throw new Error(\"No webgl2 available.\");\n            }\n            this.loseContextExt = gl.getExtension(\"WEBGL_lose_context\");\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n            this.gl = gl;\n            try {\n                this.setupFn();\n            }\n            catch (e) {\n                this.gl = null;\n                this.program = null;\n                if (!(e instanceof Error)) {\n                    throw e;\n                }\n                else {\n                    console.error(\"Failed to setup WebGL resources: \" + e.stack);\n                }\n            }\n        }\n        makeShader(type, code) {\n            if (!this.gl) {\n                throw new Error(\"No WebGL context, cannot create shader.\");\n            }\n            let shader = null;\n            try {\n                shader = this.gl.createShader(type === \"vertex\" ? this.gl.VERTEX_SHADER : this.gl.FRAGMENT_SHADER);\n                if (!shader) {\n                    throw new Error(\"No shader is created of type \" + type);\n                }\n                this.gl.shaderSource(shader, code);\n                this.gl.compileShader(shader);\n                let success = this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS);\n                if (!success) {\n                    let infoLog = this.gl.getShaderInfoLog(shader);\n                    throw new Error(\"Failed to compile shader of type \" + type + \": \" + infoLog);\n                }\n                return shader;\n            }\n            catch (e) {\n                this.gl.deleteShader(shader);\n                throw e;\n            }\n        }\n        makeProgram(vertexShaderCode, fragmentShaderCode) {\n            if (!this.gl) {\n                throw new Error(\"No WebGL context, cannot create program.\");\n            }\n            let fragShader = null;\n            let vertShader = null;\n            let program = null;\n            try {\n                fragShader = this.makeShader(\"fragment\", fragmentShaderCode);\n                vertShader = this.makeShader(\"vertex\", vertexShaderCode);\n                program = this.gl.createProgram();\n                if (!program) {\n                    throw new Error(\"No webgl program was created.\");\n                }\n                this.gl.attachShader(program, fragShader);\n                this.gl.attachShader(program, vertShader);\n                this.gl.linkProgram(program);\n                let success = this.gl.getProgramParameter(program, this.gl.LINK_STATUS);\n                if (!success) {\n                    let log = this.gl.getProgramInfoLog(program);\n                    throw new Error(\"Failed to link program: \" + log);\n                }\n                this.program = program;\n                return { program, shaders: [fragShader, vertShader] };\n            }\n            catch (e) {\n                fragShader && this.gl.deleteShader(fragShader);\n                vertShader && this.gl.deleteShader(vertShader);\n                program && this.gl.deleteProgram(program);\n                throw e;\n            }\n        }\n        setViewportSizeByCanvas() {\n            if (!this.gl || !this.canvas) {\n                throw new Error(\"No WebGL context or canvas, cannot update viewport size.\");\n            }\n            let width = this.canvas.clientWidth * window.devicePixelRatio;\n            let height = this.canvas.clientHeight * window.devicePixelRatio;\n            this.canvas.width = width;\n            this.canvas.height = height;\n            this.gl.viewport(0, 0, width, height);\n            return { width, height };\n        }\n        loadTexture(path, width, height, scale) {\n            let lc = path.toLowerCase();\n            if (lc.endsWith(\".svg\")) {\n                return this.loadSvgTexture(path, width, height, scale);\n            }\n            else {\n                throw new Error(\"Texture format not supported: \" + path);\n            }\n        }\n        loadSvgTexture(path, width, height, scale) {\n            return new Promise((ok, bad) => {\n                let img = new Image();\n                img.style.cssText = `width:${width * scale}px;height:${height * scale}px;position:absolute;top:0;left:0;z-index:-1000`;\n                document.body.appendChild(img);\n                img.onload = () => {\n                    try {\n                        let gl = this.gl;\n                        if (!gl) {\n                            throw new Error(\"No WebGL context, cannot load SVG texture.\");\n                        }\n                        let tex = this.makeBindSetupTexture();\n                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);\n                        gl.generateMipmap(gl.TEXTURE_2D);\n                        ok(tex);\n                    }\n                    catch (e) {\n                        bad(e);\n                    }\n                    finally {\n                        img.remove();\n                    }\n                };\n                img.onerror = () => bad(new Error(\"Failed to load texture for path \" + path));\n                img.src = path;\n            });\n        }\n        makeBindSetupTexture() {\n            let gl = this.gl;\n            if (!gl) {\n                throw new Error(\"No WebGL context, cannot create texture.\");\n            }\n            let tex = gl.createTexture();\n            if (!tex) {\n                throw new Error(\"No texture was created.\");\n            }\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, tex);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            return tex;\n        }\n        getUniformLocation(name) {\n            if (!this.gl) {\n                throw new Error(\"No WebGL context, cannot get uniform location.\");\n            }\n            if (!this.program) {\n                throw new Error(\"No program, cannot get uniform location.\");\n            }\n            let loc = this.gl.getUniformLocation(this.program, name);\n            if (loc === null) {\n                throw new Error(\"Failed to get location of uniform \" + name);\n            }\n            return loc;\n        }\n        getAttribLocation(name) {\n            if (!this.gl) {\n                throw new Error(\"No WebGL context, cannot get attrib location.\");\n            }\n            if (!this.program) {\n                throw new Error(\"No program, cannot get attrib location.\");\n            }\n            return this.gl.getAttribLocation(this.program, name);\n        }\n        makeBindBuffer(target) {\n            if (!this.gl) {\n                throw new Error(\"No WebGL context, cannot create buffer.\");\n            }\n            let buf = this.gl.createBuffer();\n            if (!buf) {\n                throw new Error(\"Buffer was not created.\");\n            }\n            this.gl.bindBuffer(target, buf);\n            return buf;\n        }\n    }\n    exports.GlUtils = GlUtils;\n}\n"],["/engine/graphics/instancing/instanced_model","function (exports, require) {\n    exports.floatsPerInstancePosition = 3;\n    class InstancedModel {\n        constructor(def, makeVao, gl, controller, sizeLoc) {\n            this.def = def;\n            this.makeVao = makeVao;\n            this.gl = gl;\n            this.controller = controller;\n            this.sizeLoc = sizeLoc;\n            this.packs = [];\n            this.texture = null;\n            this.deleted = false;\n            this.instanceCount = 0;\n            this.referenceCount = 0;\n            def.offsetX || (def.offsetX = 0);\n            def.offsetY || (def.offsetY = 0);\n            this.setup(this.sizeLoc);\n        }\n        setup(sizeLoc) {\n            this.sizeLoc = sizeLoc;\n            this.packs.forEach(pack => this.setupPack(pack));\n            this.texture = null;\n            this.gl.loadTexture(this.def.path, this.def.width, this.def.height, 64).then(texture => {\n                if (this.deleted) {\n                    this.gl.gl.deleteTexture(texture);\n                }\n                else {\n                    this.texture = texture;\n                }\n            }, err => {\n                console.error(\"Failed to load texture at \" + this.def.path + \": \" + err);\n            });\n        }\n        draw() {\n            if (this.texture === null || this.instanceCount === 0) {\n                return;\n            }\n            let gl = this.gl.gl;\n            let packSize = this.def.packSize;\n            gl.bindTexture(gl.TEXTURE_2D, this.texture);\n            gl.uniform4f(this.sizeLoc, this.def.width, this.def.height, this.def.offsetX, this.def.offsetY);\n            for (let i = 0; i < this.packs.length; i++) {\n                let pack = this.packs[i];\n                if (pack.unusedIndices.length === packSize) {\n                    continue;\n                }\n                gl.bindVertexArray(pack.vao);\n                if (pack.invalidated) {\n                    gl.bindBuffer(gl.ARRAY_BUFFER, pack.buffer);\n                    gl.bufferSubData(gl.ARRAY_BUFFER, 0, pack.data);\n                }\n                gl.drawElementsInstanced(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0, packSize);\n            }\n        }\n        createPack() {\n            let packSize = this.def.packSize;\n            let indices = new Array(packSize);\n            let models = new Array(packSize);\n            for (let i = 0; i < packSize; i++) {\n                indices[i] = i;\n                models[i] = null;\n            }\n            let posData = new Float32Array(packSize * 3);\n            for (let i = 0; i < packSize * 3; i++) {\n                posData[i] = floatNearMax;\n            }\n            let result = {\n                vao: 0, buffer: 0, data: posData,\n                invalidated: false, unusedIndices: indices, models\n            };\n            this.setupPack(result);\n            return result;\n        }\n        setupPack(pack) {\n            let gl = this.gl.gl;\n            let posBuffer = this.gl.makeBindBuffer(gl.ARRAY_BUFFER);\n            gl.bufferData(gl.ARRAY_BUFFER, pack.data, gl.DYNAMIC_DRAW);\n            let vao = this.makeVao(posBuffer);\n            pack.buffer = posBuffer;\n            pack.vao = vao;\n        }\n        addModel() {\n            for (let i = 0; i < this.packs.length; i++) {\n                let pack = this.packs[i];\n                let offset = pack.unusedIndices.pop();\n                if (offset !== undefined) {\n                    if (i !== 0 && pack.unusedIndices.length > 0) {\n                        this.packs[i] = this.packs[0];\n                        this.packs[0] = pack;\n                    }\n                    return new ModelImpl(offset, pack, this);\n                }\n            }\n            let pack = this.createPack();\n            if (this.packs.length === 0) {\n                this.packs.push(pack);\n            }\n            else {\n                this.packs.push(this.packs[0]);\n                this.packs[0] = pack;\n            }\n            let offset = pack.unusedIndices.pop();\n            return new ModelImpl(offset, pack, this);\n        }\n        tryCompact() {\n            if (this.instanceCount === 0 && this.packs.length > 0) {\n                this.deleteAllPacks();\n                return true;\n            }\n            let packSize = this.def.packSize;\n            let totalSize = this.packs.length * packSize;\n            let totalUnusedSize = totalSize - this.instanceCount;\n            let maxUnusedSize = this.packs\n                .map(x => x.unusedIndices.length)\n                .reduce((a, b) => Math.max(a, b), 0);\n            totalUnusedSize -= maxUnusedSize;\n            let fullnessCoefficent = (totalSize - totalUnusedSize) / totalSize;\n            if (fullnessCoefficent < this.def.compactionRate) {\n                this.compact();\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        deleteAllPacks() {\n            this.packs.forEach(pack => this.deletePack(pack));\n            this.packs.length = 0;\n            this.instanceCount = 0;\n        }\n        compact() {\n            let packSize = this.def.packSize;\n            let newPacks = [];\n            let tail = this.packs[0];\n            newPacks.push(tail);\n            for (let i = 1; i < this.packs.length; i++) {\n                let oldPack = this.packs[i];\n                let modelIndex = 0;\n                while (tail.unusedIndices.length > 0 && oldPack.unusedIndices.length < packSize) {\n                    let model = oldPack.models[modelIndex++];\n                    if (model) {\n                        model.changePack(tail);\n                    }\n                }\n                if (tail.unusedIndices.length === 0) {\n                    tail = oldPack;\n                    newPacks.push(tail);\n                }\n                else {\n                    this.deletePack(oldPack);\n                }\n            }\n            this.packs = newPacks;\n        }\n        deletePack(pack) {\n            this.gl.gl.deleteVertexArray(pack.vao);\n            this.gl.gl.deleteBuffer(pack.buffer);\n        }\n        delete() {\n            this.deleted = true;\n            if (this.texture) {\n                this.gl.gl.deleteTexture(this.texture);\n                this.texture = null;\n            }\n            this.deleteAllPacks();\n        }\n    }\n    exports.InstancedModel = InstancedModel;\n    const floatNearMax = 10 ** 38;\n    class ModelImpl {\n        constructor(index, pack, instancedModel) {\n            this.index = index;\n            this.pack = pack;\n            this.instancedModel = instancedModel;\n            instancedModel.instanceCount++;\n            pack.models[this.index] = this;\n        }\n        setPositionRotation(x, y, rotation) {\n            let arr = this.pack.data;\n            let off = this.index * exports.floatsPerInstancePosition;\n            arr[off] = x;\n            arr[off + 1] = y;\n            arr[off + 2] = rotation;\n            this.pack.invalidated = true;\n        }\n        setPosition(x, y) {\n            let arr = this.pack.data;\n            let off = this.index * exports.floatsPerInstancePosition;\n            arr[off] = x;\n            arr[off + 1] = y;\n            this.pack.invalidated = true;\n        }\n        setRotation(rotation) {\n            let arr = this.pack.data;\n            let off = this.index * exports.floatsPerInstancePosition;\n            arr[off + 2] = rotation;\n            this.pack.invalidated = true;\n        }\n        detach() {\n            this.setPositionRotation(floatNearMax, floatNearMax, 0);\n            this.pack.unusedIndices.push(this.index);\n            this.pack.models[this.index] = null;\n        }\n        delete() {\n            this.detach();\n            this.instancedModel.instanceCount--;\n            this.instancedModel.controller.onSingleModelDeleted(this.instancedModel);\n        }\n        changePack(newPack) {\n            let newIndex = newPack.unusedIndices.pop();\n            if (newIndex === undefined) {\n                throw new Error(\"Cannot change pack to full pack!\");\n            }\n            let arr = this.pack.data;\n            let off = this.index * exports.floatsPerInstancePosition;\n            let x = arr[off];\n            let y = arr[off + 1];\n            let rotation = arr[off + 2];\n            this.detach();\n            this.pack = newPack;\n            this.index = newIndex;\n            this.pack.models[newIndex] = this;\n            this.setPositionRotation(x, y, rotation);\n        }\n    }\n}\n"],["/engine/graphics/instancing/instanced_model_controller",["/engine/context","/engine/graphics/instancing/instanced_model","/engine/graphics/instancing/instancing_types","/generic/linked_list","/generic/set_list"],{"exports":["InstancedModelController"]},"function (exports, require, context_1, instanced_model_1, instancing_types_1, linked_list_1, set_list_1) {\n    class InstancedModelController {\n        constructor(defaultInstancingParams, gl, shader, params) {\n            this.defaultInstancingParams = defaultInstancingParams;\n            this.gl = gl;\n            this.shader = shader;\n            this.allModels = new Map();\n            this.modelsByLayer = {};\n            this.modelsInDefragSchedule = new Set();\n            this.defragSchedule = new linked_list_1.LinkedList();\n            this.deletionQueue = new set_list_1.SetList();\n            this.vertexBuffer = 0;\n            this.indexBuffer = 0;\n            this.makeVaoBinded = this.makeVao.bind(this);\n            for (let layerName of instancing_types_1.sceneLayerNames) {\n                this.modelsByLayer[layerName] = new Map();\n            }\n            this.params = {\n                deletionQueueSizeHardLimit: 128,\n                deletionQueueSizeSoftLimit: 32,\n                deletionTimeout: 15 * 60,\n                maxCompactionsPerTick: 1,\n                ...params\n            };\n        }\n        setup() {\n            this.vertexBuffer = this.makeVertexBuffer();\n            this.indexBuffer = this.makeIndexBuffer();\n            for (let layerName of instancing_types_1.sceneLayerNames) {\n                for (let model of this.modelsByLayer[layerName].values()) {\n                    model.setup(this.shader.sizeLocation);\n                }\n            }\n        }\n        makeVertexBuffer() {\n            let gl = this.gl.gl;\n            if (!gl) {\n                throw new Error(\"Cannot make vertex buffer: no webgl context\");\n            }\n            let positions = [0, 0, 1, 0, 1, 1, 0, 1];\n            let buffer = this.gl.makeBindBuffer(gl.ARRAY_BUFFER);\n            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n            return buffer;\n        }\n        makeIndexBuffer() {\n            let gl = this.gl.gl;\n            if (!gl) {\n                throw new Error(\"Cannot make index buffer: no webgl context\");\n            }\n            let indices = [0, 1, 2, 0, 2, 3];\n            let buffer = this.gl.makeBindBuffer(gl.ELEMENT_ARRAY_BUFFER);\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\n            return buffer;\n        }\n        makeVao(posBuffer) {\n            let gl = this.gl.gl;\n            if (!gl) {\n                throw new Error(\"Cannot make vertex array object: no webgl context\");\n            }\n            let vao = gl.createVertexArray();\n            if (!vao) {\n                throw new Error(\"No vertex array object is created.\");\n            }\n            gl.bindVertexArray(vao);\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n            gl.enableVertexAttribArray(this.shader.vertexLocation);\n            gl.vertexAttribPointer(this.shader.vertexLocation, 2, gl.FLOAT, false, 0, 0);\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n            gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);\n            gl.enableVertexAttribArray(this.shader.positionLocation);\n            gl.vertexAttribPointer(this.shader.positionLocation, 3, gl.FLOAT, false, 0, 0);\n            gl.vertexAttribDivisor(this.shader.positionLocation, 1);\n            return vao;\n        }\n        incrementModelRefCount(def) {\n            this.getInstancedModel(def).referenceCount++;\n        }\n        decrementModelRefCount(def) {\n            let model = this.getInstancedModel(def);\n            if ((--model.referenceCount) < 1) {\n                this.markModelForDeletion(def);\n            }\n        }\n        getModel(def) {\n            return this.getInstancedModel(def).addModel();\n        }\n        getInstancedModel(def) {\n            let im = this.allModels.get(def);\n            if (im) {\n                this.deletionQueue.removeValue(def);\n            }\n            else {\n                im = this.createModel(def);\n                this.modelsByLayer[def.layer].set(def, im);\n                this.allModels.set(def, im);\n            }\n            return im;\n        }\n        createModel(def) {\n            def.packSize || (def.packSize = this.defaultInstancingParams.packSize);\n            def.compactionRate || (def.compactionRate = this.defaultInstancingParams.compactionRate);\n            return new instanced_model_1.InstancedModel(def, this.makeVaoBinded, this.gl, this, this.shader.sizeLocation);\n        }\n        onSingleModelDeleted(model) {\n            if (!this.modelsInDefragSchedule.has(model)) {\n                this.modelsInDefragSchedule.add(model);\n                this.defragSchedule.addToTail(model);\n            }\n        }\n        tryCompact() {\n            let model;\n            let compactionsCount = 0;\n            while (true) {\n                model = this.defragSchedule.removeHead();\n                if (model === undefined) {\n                    return;\n                }\n                this.modelsInDefragSchedule.delete(model);\n                if (model.tryCompact()) {\n                    compactionsCount++;\n                    if (compactionsCount >= this.params.maxCompactionsPerTick) {\n                        return;\n                    }\n                }\n            }\n        }\n        markModelForDeletion(def) {\n            if (!this.deletionQueue.contains(def)) {\n                let defWithTick = def;\n                defWithTick.tickAddedToDelQueue = context_1.context.board.ticksPassed;\n                this.deletionQueue.addToTail(defWithTick);\n                if (this.deletionQueue.size > this.params.deletionQueueSizeHardLimit) {\n                    this.deleteModel(this.deletionQueue.removeHead());\n                }\n            }\n        }\n        tryDeleteModelsOnTimeout() {\n            let tickLimit = context_1.context.board.ticksPassed - this.params.deletionTimeout;\n            while (this.deletionQueue.size > this.params.deletionQueueSizeSoftLimit) {\n                let head = this.deletionQueue.showHead();\n                if (!head || (head.tickAddedToDelQueue || 0) > tickLimit) {\n                    return;\n                }\n                this.deleteModel(head);\n            }\n        }\n        deleteModel(def) {\n            let model = this.allModels.get(def);\n            if (!model) {\n                throw new Error(\"Cannot delete model for def \" + JSON.stringify(def) + \": no model is present.\");\n            }\n            this.allModels.delete(def);\n            this.modelsByLayer[def.layer].delete(def);\n            model.delete();\n        }\n        draw() {\n            let gl = this.gl.gl;\n            gl.activeTexture(gl.TEXTURE0);\n            gl.uniform1i(this.shader.imgLocation, 0);\n            for (let layer of instancing_types_1.sceneLayerNames) {\n                for (let model of this.modelsByLayer[layer].values()) {\n                    model.draw();\n                }\n            }\n        }\n        doCleanupTickTasks() {\n            this.tryCompact();\n            this.tryDeleteModelsOnTimeout();\n        }\n    }\n    exports.InstancedModelController = InstancedModelController;\n}\n"],["/engine/graphics/instancing/instancing_types","function (exports, require) {\n    const sceneLayerObj = {\n        terrain: 1,\n        ore: 2,\n        belt: 3,\n        belt_item: 4,\n        building: 5,\n        critter: 6,\n        projectile: 7\n    };\n    exports.sceneLayerNames = Object.entries(sceneLayerObj)\n        .sort((a, b) => a[1] - b[1])\n        .map(([k]) => k);\n}\n"],["/engine/graphics/instancing/shader_controller","function (exports, require) {\n    class ShaderController {\n        constructor(gl, vertexShaderCode, fragmentShaderCode) {\n            this.gl = gl;\n            this.vertexShaderCode = vertexShaderCode;\n            this.fragmentShaderCode = fragmentShaderCode;\n            this.vertexLocation = 0;\n            this.positionLocation = 0;\n            this.sizeLocation = 0;\n            this.imgLocation = 0;\n            this.cameraLocation = 0;\n            this.screenLocation = 0;\n        }\n        setup() {\n            if (!this.gl.gl) {\n                throw new Error(\"Cannot setup shaders: no webgl context\");\n            }\n            let { program } = this.gl.makeProgram(this.vertexShaderCode, this.fragmentShaderCode);\n            this.gl.gl.useProgram(program);\n            this.vertexLocation = this.gl.getAttribLocation(\"vertex\");\n            this.positionLocation = this.gl.getAttribLocation(\"position\");\n            this.sizeLocation = this.gl.getUniformLocation(\"size\");\n            this.imgLocation = this.gl.getUniformLocation(\"image\");\n            this.cameraLocation = this.gl.getUniformLocation(\"camera\");\n            this.screenLocation = this.gl.getUniformLocation(\"screen\");\n        }\n    }\n    exports.ShaderController = ShaderController;\n}\n"],["/engine/graphics/instancing/shaders","function (exports, require) {\n    exports.vertexShaderCode = `#version 300 es\n\n// описание размеров текстуры, которую мы рисуем\n// width, height, offsetX, offsetY\nuniform vec4 size;\n\n// center x, center y, zoom\nuniform vec3 camera;\n\n// размеры экрана\n// чтобы при растягивании экрана квадратное оставалось квадратным\n// теоретически, размер экрана можно было бы задавать через context.viewport()\n// но это не очень хорошо, т.к. рисуются лишние примитивы за границами экрана\n// x multiplier, y multiplier\nuniform vec2 screen;\n\n// описание позиции предмета, который мы рисуем\n// x, y, rotation (против часовой)\nin vec3 position;\n\nin vec2 vertex;\nout vec2 texCoord;\n\nvoid main() {\n\ttexCoord = vertex;\n\n\tfloat s = sin(position[2]);\n\tfloat c = cos(position[2]);\n\tmat2 rotMatrix = mat2(c, -s, s, c);\n\tvec2 halfSize = size.xy / 2.0;\n\t\n\t// растягиваем согласно переданным размерам\n\tvec2 result = vec2(vertex.x * size.x, vertex.y * size.y);\n\n\t// поворачиваем вокруг центра\n\tresult = ((result - halfSize) * rotMatrix) + halfSize;\n\n\t// двигаем его туда, где он должен быть\n\tresult = result + position.xy + size.zw;\n\n\t// в этот момент в result лежат полные правильные внутриигровые координаты точки\n\t// и нам нужно их преобразовать в координаты пространства камеры\n\n\t// сдвигаем относительно камеры\n\tresult = result - camera.xy;\n\n\t// применяем зум и размеры экрана, преобразуя игровые координаты в координаты камеры\n\t// * 2 здесь потому, что пространство экрана у opengl от -1 до 1, т.е. экран длиной 2\n\t// а у нас значение зума определено как размер 1 внутриигровой единицы пространства\n\tresult = result * camera.z * 2.0 / screen;\n\n\tgl_Position = vec4(result, 0, 1);\n}`;\n    exports.fragmentShaderCode = `#version 300 es\nprecision highp float;\n\nuniform sampler2D image;\nin vec2 texCoord;\nout vec4 outColor;\n\nvoid main() {\n\toutColor = texture(image, texCoord);\n}`;\n}\n"],["/engine/graphics/object_model_mapping",["/engine/context","/generic/class_utils"],{"exports":["ObjectModelMapping"]},"function (exports, require, context_1, class_utils_1) {\n    class ObjectModelMapping {\n        constructor() {\n            this.finalized = false;\n            this.map = new Map();\n        }\n        checkNotFinalized() {\n            if (this.finalized) {\n                throw new Error(\"Cannot alter mapping: already finalized.\");\n            }\n        }\n        wireupAndFinalize() {\n            this.checkNotFinalized();\n            for (let cls of this.map.keys()) {\n                let defs = this.map.get(cls);\n                (0, class_utils_1.forEachConstructorParent)(cls, supercls => {\n                    let superdefs = this.map.get(supercls);\n                    if (superdefs) {\n                        defs.push(...superdefs);\n                    }\n                });\n                defs = [...new Set(defs)];\n                this.map.set(cls, defs);\n            }\n            this.finalized = true;\n        }\n        define(cls, def) {\n            this.checkNotFinalized();\n            let arr = this.map.get(cls);\n            if (!arr) {\n                arr = [];\n                this.map.set(cls, arr);\n            }\n            arr.push(def);\n        }\n        increment(cls) {\n            let defs = this.map.get(cls);\n            if (defs) {\n                for (let i = 0; i < defs.length; i++) {\n                    context_1.context.scene.controller.incrementModelRefCount(defs[i]);\n                }\n            }\n        }\n        decrement(cls) {\n            let defs = this.map.get(cls);\n            if (defs) {\n                for (let i = 0; i < defs.length; i++) {\n                    context_1.context.scene.controller.decrementModelRefCount(defs[i]);\n                }\n            }\n        }\n    }\n    exports.ObjectModelMapping = ObjectModelMapping;\n}\n"],["/engine/graphics/scene",["/engine/graphics/gl_utils","/engine/graphics/instancing/instanced_model_controller","/engine/graphics/instancing/shaders","/engine/graphics/instancing/shader_controller","/engine/quad_tree/area_watching_quad_tree","/generic/utils","/engine/context"],{"exports":["Scene"]},"function (exports, require, gl_utils_1, instanced_model_controller_1, shaders_1, shader_controller_1, area_watching_quad_tree_1, utils_1, context_1) {\n    class Scene {\n        constructor(container = document.body) {\n            this.container = container;\n            this.widthPx = 0;\n            this.heightPx = 0;\n            this.needViewportUpdate = true;\n            this.graphicTickingObjects = new Set();\n            this.drawableObjects = new area_watching_quad_tree_1.AreaWatchingQuadTree(8, obj => this.addObject(obj), obj => this.removeObject(obj));\n            this.gl = new gl_utils_1.GlUtils(() => this.setup());\n            (0, utils_1.watchResize)(container, () => this.needViewportUpdate = true);\n            (0, utils_1.watchDevicePixelRatio)(() => this.needViewportUpdate = true);\n            this.shader = new shader_controller_1.ShaderController(this.gl, shaders_1.vertexShaderCode, shaders_1.fragmentShaderCode);\n            this.controller = new instanced_model_controller_1.InstancedModelController({\n                compactionRate: 0.5,\n                packSize: 32\n            }, this.gl, this.shader);\n            this.gl.setup();\n        }\n        setup() {\n            this.container.querySelectorAll(\"canvas\").forEach(oldCanvas => oldCanvas.remove());\n            this.container.appendChild(this.gl.canvas);\n            this.shader.setup();\n            this.controller.setup();\n            this.needViewportUpdate = true;\n        }\n        onCameraChanged() {\n            if (!this.gl.gl || !this.gl.canvas) {\n                return;\n            }\n            let zoom = context_1.context.camera.zoom;\n            let x = context_1.context.camera.x;\n            let y = context_1.context.camera.y;\n            let w = this.gl.canvas.clientWidth;\n            let h = this.gl.canvas.clientHeight;\n            let vw = w / zoom;\n            let vh = h / zoom;\n            let vx = x - (vw / 2);\n            let vy = y - (vh / 2);\n            this.drawableObjects.setWatchedRectangle(vx - 4, vy - 4, vx + vw + 4, vy + vh + 4);\n            this.gl.gl.uniform3f(this.shader.cameraLocation, x, y, zoom);\n        }\n        updateViewport() {\n            if (!this.gl.gl) {\n                return;\n            }\n            let { width, height } = this.gl.setViewportSizeByCanvas();\n            this.widthPx = width;\n            this.heightPx = height;\n            this.gl.gl.uniform2f(this.shader.screenLocation, width, height);\n            this.onCameraChanged();\n        }\n        addObject(object) {\n            object.onGraphicAdded();\n            if (object.onGraphicTick) {\n                this.graphicTickingObjects.add(object);\n            }\n        }\n        removeObject(object) {\n            if (object.onGraphicRemoved) {\n                object.onGraphicRemoved();\n            }\n            object.model.delete();\n            object.model = null;\n            if (object.onGraphicTick) {\n                this.graphicTickingObjects.delete(object);\n            }\n        }\n        tick(deltaTime) {\n            if (!this.gl.gl) {\n                return;\n            }\n            context_1.context.performeter.enterBlock(\"graphic_object_tick\");\n            for (let obj of this.graphicTickingObjects) {\n                obj.onGraphicTick(deltaTime);\n            }\n            context_1.context.performeter.exitBlock();\n            if (this.needViewportUpdate) {\n                this.needViewportUpdate = false;\n                this.updateViewport();\n            }\n            context_1.context.performeter.enterBlock(\"clear\");\n            this.gl.gl.clearColor(0, 0, 0, 1);\n            this.gl.gl.clear(this.gl.gl.COLOR_BUFFER_BIT);\n            context_1.context.performeter.exitEnterBlock(\"controller_draw\");\n            this.controller.draw();\n            context_1.context.performeter.exitEnterBlock(\"controller_cleanup\");\n            this.controller.doCleanupTickTasks();\n            context_1.context.performeter.exitBlock();\n        }\n    }\n    exports.Scene = Scene;\n}\n"],["/engine/inertial_object_controller","function (exports, require) {\n    class InertialObjectControllerImpl {\n        constructor() {\n            this.movingObjects = new Set();\n        }\n        onSpeedChanged(obj) {\n            if (obj.canMoveOnTick()) {\n                this.movingObjects.add(obj);\n            }\n            else {\n                this.movingObjects.delete(obj);\n            }\n        }\n        tick(deltaTime) {\n            for (let obj of this.movingObjects) {\n                obj.moveOnTick(deltaTime);\n                if (!obj.canMoveOnTick()) {\n                    this.movingObjects.delete(obj);\n                }\n            }\n        }\n    }\n    exports.InertialObjectControllerImpl = InertialObjectControllerImpl;\n}\n"],["/engine/input_controller",["/engine/context"],{"exports":["InputControllerImpl"]},"function (exports, require, context_1) {\n    class InputControllerImpl {\n        constructor() {\n            this.shiftIsDown = false;\n            this.altIsDown = false;\n            this.ctrlIsDown = false;\n            this.downKeys = new Set();\n            this.events = [];\n            this.lastMouseMoveEvent = null;\n            window.addEventListener(\"blur\", () => {\n                this.shiftIsDown = false;\n                this.altIsDown = false;\n                this.ctrlIsDown = false;\n                this.downKeys.forEach(key => {\n                    this.addEvent(false, key);\n                });\n                this.downKeys.clear();\n                this.lastMouseMoveEvent = null;\n            }, { capture: false, passive: true });\n            window.addEventListener(\"keydown\", e => {\n                if (e.repeat) {\n                    return;\n                }\n                let code = fixKeyboardCode(e.code);\n                switch (code) {\n                    case \"control\":\n                        this.ctrlIsDown = true;\n                        break;\n                    case \"alt\":\n                        this.altIsDown = true;\n                        break;\n                    case \"shift\":\n                        this.shiftIsDown = true;\n                        break;\n                    default:\n                        this.downKeys.add(code);\n                        this.addEvent(true, code);\n                        break;\n                }\n            }, { capture: false, passive: true });\n            window.addEventListener(\"keyup\", e => {\n                let code = fixKeyboardCode(e.code);\n                switch (e.key) {\n                    case \"control\":\n                        this.ctrlIsDown = false;\n                        break;\n                    case \"alt\":\n                        this.altIsDown = false;\n                        break;\n                    case \"shift\":\n                        this.shiftIsDown = false;\n                        break;\n                    default:\n                        this.downKeys.delete(code);\n                        this.addEvent(false, code);\n                        break;\n                }\n            }, { capture: false, passive: true });\n            window.addEventListener(\"mousemove\", e => {\n                this.lastMouseMoveEvent = e;\n            }, { capture: false, passive: true });\n            window.addEventListener(\"click\", e => {\n                e.preventDefault();\n                return false;\n            }, { capture: false, passive: false });\n            window.addEventListener(\"contextmenu\", e => {\n                e.preventDefault();\n                return false;\n            }, { capture: false, passive: false });\n            window.addEventListener(\"wheel\", e => {\n                let delta = (e.deltaX || 0) + (e.deltaY || 0) + (e.deltaZ || 0);\n                let zoomAmountPerWheel = Math.sqrt(Math.sqrt(2));\n                context_1.context.camera.zoomRelative(delta > 0 ? 1 / zoomAmountPerWheel : zoomAmountPerWheel);\n            }, { capture: false, passive: true });\n            addMouseMoveHandlers(window, e => {\n                if (e.buttons & 2) {\n                    let coords = this.extractWorldCoords(e);\n                    void coords;\n                }\n            });\n        }\n        get worldCursorPosition() {\n            if (!this.lastMouseMoveEvent) {\n                return null;\n            }\n            return this.extractWorldCoords(this.lastMouseMoveEvent);\n        }\n        addEvent(down, inputType) {\n            this.events.push({\n                shift: this.shiftIsDown,\n                alt: this.altIsDown,\n                ctrl: this.ctrlIsDown,\n                down,\n                input: inputType\n            });\n        }\n        takeEvents() {\n            let res = this.events;\n            this.events = [];\n            return res;\n        }\n        extractWorldCoords(event) {\n            let x = event.clientX * window.devicePixelRatio;\n            let y = -event.clientY * window.devicePixelRatio;\n            x -= context_1.context.scene.widthPx / 2;\n            y += context_1.context.scene.heightPx / 2;\n            x /= context_1.context.camera.zoom;\n            y /= context_1.context.camera.zoom;\n            x += context_1.context.camera.x;\n            y += context_1.context.camera.y;\n            return { x, y };\n        }\n    }\n    exports.InputControllerImpl = InputControllerImpl;\n    function addMouseMoveHandlers(target, handler) {\n        let lastEvent = null;\n        let moveZoomHandler = () => lastEvent && handler(lastEvent);\n        let upHandler = () => {\n            target.removeEventListener(\"mouseup\", upHandler);\n            target.removeEventListener(\"mousemove\", handler);\n            context_1.context.camera.onMove.remove(moveZoomHandler);\n            context_1.context.camera.onZoom.remove(moveZoomHandler);\n        };\n        target.addEventListener(\"mousedown\", e => {\n            lastEvent = e;\n            handler(e);\n            target.addEventListener(\"mouseup\", upHandler, { capture: false, passive: true });\n            target.addEventListener(\"mousemove\", e => {\n                lastEvent = e;\n                handler(lastEvent);\n            }, { capture: false, passive: true });\n            context_1.context.camera.onMove(moveZoomHandler);\n            context_1.context.camera.onZoom(moveZoomHandler);\n        }, { capture: false, passive: true });\n    }\n    function fixKeyboardCode(raw) {\n        raw = raw.toLowerCase();\n        if (raw.startsWith(\"key\")) {\n            return raw.substring(3);\n        }\n        else if (raw.endsWith(\"left\")) {\n            return raw.substring(0, raw.length - 4);\n        }\n        else if (raw.endsWith(\"right\")) {\n            return raw.substring(0, raw.length - 5);\n        }\n        else {\n            return raw;\n        }\n    }\n}\n"],["/engine/input_processor","function (exports, require) {\n    class InputProcessorImpl {\n        constructor() {\n            this.actions = new Map();\n            this.activeHoldActions = new Set();\n        }\n        setActions(defs) {\n            this.actions.clear();\n            defs.forEach(def => {\n                let input = { mode: \"down\", ...def, input: parseInputSpec(def.input) };\n                if (!isValidAction(input)) {\n                    console.warn(\"Action is NOT valid, skipping: \" + JSON.stringify(input));\n                    return;\n                }\n                let arr = this.actions.get(input.input.input);\n                if (arr) {\n                    arr.push(input);\n                }\n                else {\n                    this.actions.set(input.input.input, [input]);\n                }\n            });\n            for (let v of this.actions.values()) {\n                v.sort((a, b) => modifiersCount(a.input) - modifiersCount(b.input));\n            }\n        }\n        findAction(input) {\n            let arr = this.actions.get(input.input);\n            if (!arr) {\n                return null;\n            }\n            for (let action of arr) {\n                if ((!action.input.alt || input.alt)\n                    && (!action.input.ctrl || input.ctrl)\n                    && !action.input.shift || input.shift) {\n                    return action;\n                }\n            }\n            return null;\n        }\n        onTick(deltaTime, inputs) {\n            for (let input of inputs) {\n                let action = this.findAction(input);\n                if (!action) {\n                    continue;\n                }\n                switch (action.mode) {\n                    case \"up\":\n                        if (!input.down) {\n                            action.action(deltaTime);\n                        }\n                        break;\n                    case \"down\":\n                        if (input.down) {\n                            action.action(deltaTime);\n                        }\n                        break;\n                    case \"hold\":\n                        if (input.down) {\n                            this.activeHoldActions.add(action);\n                        }\n                        else {\n                            this.activeHoldActions.delete(action);\n                        }\n                        break;\n                }\n            }\n            let groups = new Set();\n            for (let action of this.activeHoldActions) {\n                if (action.groupName) {\n                    if (groups.has(action.groupName)) {\n                        continue;\n                    }\n                    else {\n                        groups.add(action.groupName);\n                    }\n                }\n                action.action(deltaTime);\n            }\n        }\n    }\n    exports.InputProcessorImpl = InputProcessorImpl;\n    function isValidAction(action) {\n        if (action.mode === \"hold\" && modifiersCount(action.input) > 0) {\n            return false;\n        }\n        return true;\n    }\n    function parseInputSpec(input) {\n        input = input.toLowerCase().trim().replace(/\\s*\\+\\s*/g, \"+\");\n        let result = { shift: false, alt: false, ctrl: false, input: \"\" };\n        while (true) {\n            if (input.startsWith(\"alt+\")) {\n                result.alt = true;\n                input = input.substring(\"alt+\".length);\n            }\n            else if (input.startsWith(\"ctrl+\")) {\n                result.ctrl = true;\n                input = input.substring(\"ctrl+\".length);\n            }\n            else if (input.startsWith(\"shift+\")) {\n                result.shift = true;\n                input = input.substring(\"shift+\".length);\n            }\n            else {\n                break;\n            }\n        }\n        result.input = input;\n        return result;\n    }\n    function modifiersCount(spec) {\n        return (spec.alt ? 1 : 0) + (spec.shift ? 1 : 0) + (spec.ctrl ? 1 : 0);\n    }\n}\n"],["/engine/object_tasker",["/engine/context"],{"exports":["ObjectTaskerImpl"]},"function (exports, require, context_1) {\n    const ethalonTickLength = 1 / 60;\n    class ObjectTaskerImpl {\n        constructor() {\n            this.tasksById = new Map();\n            this.tasksByTicks = new Map();\n            this.taskId = 1;\n        }\n        schedule(obj, timeToComplete, data) {\n            let finishTime = context_1.context.board.timePassed + timeToComplete;\n            let finishTick = Math.ceil(finishTime / ethalonTickLength);\n            let id = this.taskId++;\n            let task = { obj, finishTime, finishTick, data, id };\n            let timeMap = this.tasksByTicks.get(finishTick);\n            if (!timeMap) {\n                timeMap = new Map();\n                this.tasksByTicks.set(finishTick, timeMap);\n            }\n            timeMap.set(id, task);\n            this.tasksById.set(id, task);\n            return id;\n        }\n        unschedule(id) {\n            let task = this.tasksById.get(id);\n            this.tasksById.delete(id);\n            this.tasksByTicks.get(task.finishTick).delete(id);\n        }\n        tick(deltaTime) {\n            let currentTickFinishedAt = Math.floor((context_1.context.board.timePassed + deltaTime) / ethalonTickLength);\n            let lastTickFinishedAt = Math.floor(context_1.context.board.timePassed / ethalonTickLength);\n            for (let currentTick = lastTickFinishedAt + 1; currentTick <= currentTickFinishedAt; currentTick++) {\n                let map = this.tasksByTicks.get(currentTick);\n                if (!map) {\n                    continue;\n                }\n                let tickPefectTime = currentTick * ethalonTickLength;\n                for (let task of map.values()) {\n                    let freeTime = tickPefectTime - task.finishTime;\n                    task.obj.onTaskCompleted(task.data, freeTime);\n                    this.tasksById.delete(task.id);\n                }\n                this.tasksByTicks.delete(currentTick);\n            }\n        }\n    }\n    exports.ObjectTaskerImpl = ObjectTaskerImpl;\n}\n"],["/engine/object_ticker","function (exports, require) {\n    class ObjectTickerImpl {\n        constructor() {\n            this.knownOrderNums = [];\n            this.lists = new Map();\n        }\n        tick(deltaTime) {\n            for (let i of this.knownOrderNums) {\n                for (let obj of this.lists.get(i)) {\n                    obj.onTick(deltaTime);\n                }\n            }\n        }\n        update(obj) {\n            let tickOrder = obj.getTickOrder();\n            if (tickOrder !== null) {\n                this.add(obj, tickOrder);\n            }\n            else {\n                this.remove(obj);\n            }\n        }\n        remove(obj) {\n            if (obj.registeredTickOrder !== null) {\n                this.lists.get(obj.registeredTickOrder).delete(obj);\n                obj.registeredTickOrder = null;\n            }\n        }\n        add(obj, tickOrder) {\n            if (obj.registeredTickOrder === tickOrder) {\n                return;\n            }\n            if (obj.registeredTickOrder !== null) {\n                this.lists.get(obj.registeredTickOrder).delete(obj);\n            }\n            let list = this.lists.get(tickOrder);\n            if (!list) {\n                list = new Set();\n                this.lists.set(tickOrder, list);\n                this.knownOrderNums.push(tickOrder);\n                this.knownOrderNums.sort((a, b) => a - b);\n            }\n            list.add(obj);\n            obj.registeredTickOrder = tickOrder;\n        }\n    }\n    exports.ObjectTickerImpl = ObjectTickerImpl;\n}\n"],["/engine/quad_tree/area_watching_quad_tree",["/engine/quad_tree/quad_tree"],"function (exports, require, quad_tree_1) {\n    class AreaWatchingQuadTree extends quad_tree_1.QuadTree {\n        constructor(discretization, onItemAppear, onItemDisappear) {\n            super(discretization);\n            this.onItemAppear = onItemAppear;\n            this.onItemDisappear = onItemDisappear;\n            this.watchedBuckets = new Map();\n            this.lowX = 0;\n            this.lowY = 0;\n            this.highX = 0;\n            this.highY = 0;\n        }\n        setWatchedRectangle(lowX, lowY, highX, highY) {\n            lowX = this.bucketCenterCoord(lowX);\n            lowY = this.bucketCenterCoord(lowY);\n            highX = this.bucketCenterCoord(highX);\n            highY = this.bucketCenterCoord(highY);\n            if (lowX !== this.lowX || lowY !== this.lowY || highX !== this.highX || highY !== this.highY) {\n                this.lowX = lowX;\n                this.lowY = lowY;\n                this.highX = highX;\n                this.highY = highY;\n                this.rebuildBucketList();\n            }\n        }\n        rebuildBucketList() {\n            let newBucketKeys = new Set();\n            for (let x = this.lowX; x <= this.highX; x += this.discretization) {\n                for (let y = this.lowY; y <= this.highY; y += this.discretization) {\n                    let key = bucketKey(x, y);\n                    newBucketKeys.add(key);\n                    if (!this.watchedBuckets.has(key)) {\n                        let bucket = this.getBucketAt(x, y);\n                        if (bucket) {\n                            this.addBucket(key, bucket);\n                        }\n                        else {\n                            this.watchedBuckets.set(key, null);\n                        }\n                    }\n                }\n            }\n            for (let [key, bucket] of this.watchedBuckets) {\n                if (!newBucketKeys.has(key)) {\n                    if (bucket) {\n                        this.removeBucket(key, bucket);\n                    }\n                    else {\n                        this.watchedBuckets.delete(key);\n                    }\n                }\n            }\n        }\n        createBucket(x, y) {\n            let bucket = new QuadTreeBucketWithTogglableWatcher(this.onItemAppear, this.onItemDisappear);\n            if (x >= this.lowX && x <= this.highX && y >= this.lowY && y <= this.highY) {\n                this.addBucket(bucketKey(x, y), bucket);\n            }\n            return bucket;\n        }\n        addBucket(key, bucket) {\n            bucket.setWatcherEnabled(true);\n            this.watchedBuckets.set(key, bucket);\n            for (let item of bucket) {\n                this.onItemAppear(item);\n            }\n        }\n        removeBucket(key, bucket) {\n            bucket.setWatcherEnabled(false);\n            this.watchedBuckets.delete(key);\n            for (let item of bucket) {\n                this.onItemDisappear(item);\n            }\n        }\n        isInArea(obj) {\n            return obj.x >= this.lowX && obj.x <= this.highX && obj.y >= this.lowY && obj.y <= this.highY;\n        }\n    }\n    exports.AreaWatchingQuadTree = AreaWatchingQuadTree;\n    let bucketKey = (x, y) => (x < 0 ? -x + 0x2000000 : x) + ((y < 0 ? -y + 0x2000000 : y) * 0x4000000);\n    function decodeBucketKey(key) {\n        let y = Math.floor(key / 0x4000000);\n        let x = key % 0x4000000;\n        y = y > 0x2000000 ? -(y - 0x2000000) : y;\n        x = x > 0x2000000 ? -(x - 0x2000000) : x;\n        return { x, y };\n    }\n    void decodeBucketKey;\n    class QuadTreeBucketWithTogglableWatcher extends quad_tree_1.QuadTreeBucketImpl {\n        constructor(onAdd, onRemove) {\n            super();\n            this.onAdd = onAdd;\n            this.onRemove = onRemove;\n            this.enabled = false;\n            this.justDelete = Set.prototype.delete.bind(this);\n            this.justAdd = Set.prototype.add.bind(this);\n            this.setWatcherEnabled(false);\n        }\n        setWatcherEnabled(enabled) {\n            this.enabled = enabled;\n            if (enabled) {\n                this.add = v => {\n                    this.onAdd(v);\n                    return Set.prototype.add.call(this, v);\n                };\n                this.delete = v => {\n                    this.onRemove(v);\n                    return Set.prototype.delete.call(this, v);\n                };\n            }\n            else {\n                this.add = this.justAdd;\n                this.delete = this.justDelete;\n            }\n        }\n        move(value, target) {\n            if (this.enabled && target.enabled) {\n                this.justDelete(value);\n                target.justAdd(value);\n            }\n            else {\n                super.move(value, target);\n            }\n        }\n    }\n}\n"],["/engine/quad_tree/quad_tree","function (exports, require) {\n    function isBucket(x) {\n        return !(\"links\" in x);\n    }\n    class QuadTreeBucketImpl extends Set {\n        move(value, target) {\n            this.delete(value);\n            target.add(value);\n        }\n    }\n    exports.QuadTreeBucketImpl = QuadTreeBucketImpl;\n    class QuadTree {\n        constructor(discretization) {\n            this.discretization = discretization;\n            this.roots = [null, null, null, null];\n            if (discretization < 0 || discretization % 2) {\n                throw new Error(\"Incorrect quad tree discretization value: \" + discretization);\n            }\n            this.halfDiscretization = Math.round(discretization / 2);\n        }\n        rootNodeIndex(x, y) {\n            return (x < 0 ? 2 : 0) + (y < 0 ? 1 : 0);\n        }\n        oppositeNodeIndex(i) {\n            return (i > 1 ? i - 2 : i + 2);\n        }\n        createBucket(x, y) {\n            void x, y;\n            return new QuadTreeBucketImpl();\n        }\n        forEach(handler) {\n            this.roots.forEach(root => {\n                if (root) {\n                    this.forEachChild(root, handler);\n                }\n            });\n        }\n        toArray() {\n            let result = [];\n            this.forEach(v => result.push(v));\n            return result;\n        }\n        forEachChild(parent, handler) {\n            parent.links.forEach(child => {\n                if (!child) {\n                    return;\n                }\n                if (isBucket(child)) {\n                    for (let item of child) {\n                        handler(item);\n                    }\n                }\n                else {\n                    this.forEachChild(child, handler);\n                }\n            });\n        }\n        forEachItemInCircle(x, y, radius, handler) {\n            let minX = this.bucketCenterCoord(x - radius);\n            let minY = this.bucketCenterCoord(y - radius);\n            let maxX = this.bucketCenterCoord(x + radius);\n            let maxY = this.bucketCenterCoord(y + radius);\n            let radius2 = radius ** 2;\n            let trimRadius2 = (radius + this.halfDiscretization) ** 2;\n            for (let leafCenterX = minX; leafCenterX < maxX; leafCenterX += this.discretization) {\n                for (let leafCenterY = minY; leafCenterY < maxY; leafCenterY += this.discretization) {\n                    let distanceToCenter2 = ((leafCenterX - x) ** 2) + ((leafCenterY - y) ** 2);\n                    if (distanceToCenter2 > trimRadius2) {\n                        continue;\n                    }\n                    let bucket = this.getBucketAt(leafCenterX, leafCenterY);\n                    if (!bucket) {\n                        continue;\n                    }\n                    for (let item of bucket) {\n                        let dist2 = (item.x ** 2) + (item.y ** 2);\n                        if (dist2 < radius2) {\n                            handler(item);\n                        }\n                    }\n                }\n            }\n        }\n        floorCoord(coord) {\n            return Math.floor(coord / this.discretization) * this.discretization;\n        }\n        bucketCenterCoord(coord) {\n            let neg = coord < 0;\n            if (neg) {\n                coord = -coord;\n            }\n            let res = (Math.floor(coord / this.discretization) * this.discretization) + this.halfDiscretization;\n            return neg ? -res : res;\n        }\n        getBucketAt(x, y) {\n            let rootIndex = this.rootNodeIndex(x, y);\n            x = Math.abs(x);\n            y = Math.abs(y);\n            let node = this.roots[rootIndex];\n            if (node) {\n                let rootSize = isBucket(node) ? this.discretization : node.size;\n                if (x > rootSize || y > rootSize) {\n                    return null;\n                }\n            }\n            while (node && !isBucket(node)) {\n                let index = 0;\n                if (x > node.halfSize) {\n                    x -= node.halfSize;\n                }\n                else {\n                    index += 2;\n                }\n                if (y > node.halfSize) {\n                    y -= node.halfSize;\n                }\n                else {\n                    index += 1;\n                }\n                node = node.links[index];\n            }\n            return node;\n        }\n        getOrCreateBucketAt(x, y) {\n            let rootIndex = this.rootNodeIndex(x, y);\n            let root = this.roots[rootIndex];\n            if (!root) {\n                root = {\n                    links: [null, null, null, null],\n                    size: this.discretization * 2,\n                    halfSize: this.discretization\n                };\n                this.roots[rootIndex] = root;\n            }\n            let absX = Math.abs(x);\n            let absY = Math.abs(y);\n            let rootSize = root.size;\n            while (absX > rootSize || absY > rootSize) {\n                this.roots[rootIndex] = root = {\n                    links: [null, null, null, root],\n                    size: rootSize * 2,\n                    halfSize: rootSize\n                };\n                rootSize = root.size;\n            }\n            let node = root;\n            while (true) {\n                if (isBucket(node)) {\n                    return node;\n                }\n                let index = 0;\n                if (absX > node.halfSize) {\n                    absX -= node.halfSize;\n                }\n                else {\n                    index += 2;\n                }\n                if (absY > node.halfSize) {\n                    absY -= node.halfSize;\n                }\n                else {\n                    index += 1;\n                }\n                let nextNode = node.links[index];\n                if (!nextNode) {\n                    if (node.halfSize === this.discretization) {\n                        let bucket = this.createBucket(this.bucketCenterCoord(x), this.bucketCenterCoord(y));\n                        node.links[index] = bucket;\n                        return bucket;\n                    }\n                    else {\n                        let subNode = {\n                            links: [null, null, null, null],\n                            size: node.halfSize,\n                            halfSize: Math.round(node.halfSize / 2)\n                        };\n                        node.links[index] = subNode;\n                        node = subNode;\n                    }\n                }\n                else {\n                    node = nextNode;\n                }\n            }\n        }\n        add(item) {\n            this.getOrCreateBucketAt(item.x, item.y).add(item);\n        }\n        remove(item) {\n            return this.removeFrom(item, item.x, item.y);\n        }\n        removeFrom(item, x, y) {\n            let bucket = this.getBucketAt(x, y);\n            if (bucket) {\n                bucket.delete(item);\n            }\n        }\n        afterMove(item, oldX, oldY) {\n            if (this.floorCoord(oldX) === this.floorCoord(item.x) && this.floorCoord(oldY) === this.floorCoord(item.y)) {\n                return;\n            }\n            let bucketFrom = this.getBucketAt(oldX, oldY);\n            let bucketTo = this.getOrCreateBucketAt(item.x, item.y);\n            bucketFrom.move(item, bucketTo);\n        }\n    }\n    exports.QuadTree = QuadTree;\n}\n"],["/engine/quad_tree/rectangle_quad_tree",["/engine/quad_tree/quad_tree"],"function (exports, require, quad_tree_1) {\n    class RectangleQuadTree extends quad_tree_1.QuadTree {\n        forEachItemPresentAt(x, y, handler) {\n            for (let dx = -this.discretization; dx <= 0; dx += this.discretization) {\n                for (let dy = -this.discretization; dy <= 0; dy += this.discretization) {\n                    let bucket = this.getBucketAt(x + dx, y + dy);\n                    if (!bucket) {\n                        continue;\n                    }\n                    for (let item of bucket) {\n                        if (item.x <= x && item.x + item.effectiveWidth >= x && item.y <= y && item.y + item.effectiveHeight >= y) {\n                            handler(item);\n                        }\n                    }\n                }\n            }\n        }\n        findFirstItemAt(x, y) {\n            for (let dx = 0; dx >= -this.discretization; dx -= this.discretization) {\n                for (let dy = 0; dy >= -this.discretization; dy -= this.discretization) {\n                    let bucket = this.getBucketAt(x + dx, y + dy);\n                    if (!bucket) {\n                        continue;\n                    }\n                    for (let item of bucket) {\n                        if (item.x <= x && item.x + item.effectiveWidth >= x && item.y <= y && item.y + item.effectiveHeight >= y) {\n                            return item;\n                        }\n                    }\n                }\n            }\n            return null;\n        }\n        findFirstItemAtWithOffset(x, y, offset = 0.5) {\n            return this.findFirstItemAt(x + offset, y + offset);\n        }\n    }\n    exports.RectangleQuadTree = RectangleQuadTree;\n}\n"],["/engine/world_object",["/engine/context","/engine/graphics/object_model_mapping"],{"exports":["WorldObjectBaseImpl","objectModelMapping"]},"function (exports, require, context_1, object_model_mapping_1) {\n    exports.objectModelMapping = new object_model_mapping_1.ObjectModelMapping();\n    class WorldObjectBaseImpl {\n        constructor(x, y) {\n            this.x = x;\n            this.y = y;\n            this.model = null;\n        }\n        static registerModel(def) {\n            exports.objectModelMapping.define(this, def);\n            return def;\n        }\n        move(x, y) {\n            let oldX = this.x;\n            let oldY = this.y;\n            this.x = x;\n            this.y = y;\n            context_1.context.scene.drawableObjects.afterMove(this, oldX, oldY);\n            if (this.model) {\n                this.onGraphicMoved();\n            }\n        }\n        onGraphicMoved() {\n        }\n        onAdded() {\n            context_1.context.scene.drawableObjects.add(this);\n            exports.objectModelMapping.increment(this.constructor);\n        }\n        onRemoved() {\n            context_1.context.scene.drawableObjects.remove(this);\n            exports.objectModelMapping.decrement(this.constructor);\n        }\n        onGraphicAdded() {\n        }\n        onGraphicRemoved() {\n        }\n    }\n    exports.WorldObjectBaseImpl = WorldObjectBaseImpl;\n}\n"],["/entities/critter/player_character",["/engine/context","/engine/entities/inertial_object"],{"exports":["Player","playerCharacterAcceleration"]},"function (exports, require, context_1, inertial_object_1) {\n    var _a;\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.Player = exports.playerCharacterAcceleration = void 0;\n    exports.playerCharacterAcceleration = 500;\n    class Player extends inertial_object_1.InertialObject {\n        constructor() {\n            super(...arguments);\n            this.deceleration = exports.playerCharacterAcceleration;\n        }\n        onGraphicAdded() {\n            this.model = context_1.context.scene.controller.getModel(Player.model);\n            this.model.setPositionRotation(this.x, this.y, 0);\n            super.onGraphicAdded();\n        }\n    }\n    exports.Player = Player;\n    _a = Player;\n    Player.model = _a.registerModel({\n        path: \"/player.svg\",\n        width: 1,\n        height: 1,\n        layer: \"critter\",\n        offsetX: -0.5,\n        offsetY: -0.5,\n        packSize: 1\n    });\n}\n"],["/entities/terrain/floor",["/engine/context","/engine/entities/terrain"],"function (exports, require, context_1, terrain_1) {\n    var _a;\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.Floor = void 0;\n    class Floor extends terrain_1.Terrain {\n        constructor() {\n            super(...arguments);\n            this.width = 1;\n            this.height = 1;\n        }\n        onGraphicAdded() {\n            this.model = context_1.context.scene.controller.getModel(Floor.model);\n            super.onGraphicAdded();\n        }\n    }\n    exports.Floor = Floor;\n    _a = Floor;\n    Floor.model = _a.registerModel({ path: \"/floor.svg\" });\n}\n"],["/generic/class_utils","function (exports, require) {\n    function forEachConstructorParent(constr, callback) {\n        while (true) {\n            let proto = Object.getPrototypeOf(constr.prototype);\n            if (!proto) {\n                return;\n            }\n            constr = proto.constructor;\n            callback(constr);\n        }\n    }\n    exports.forEachConstructorParent = forEachConstructorParent;\n}\n"],["/generic/event","function (exports, require) {\n    function makeEvent() {\n        let listeners = [];\n        let result = ((listener) => {\n            listeners.push(listener);\n        });\n        result.remove = listener => listeners = listeners.filter(x => x !== listener);\n        result.fire = async (args) => {\n            let oldListeners = [...listeners];\n            await Promise.all(oldListeners.map(listener => Promise.resolve(listener(args))));\n        };\n        return result;\n    }\n    exports.makeEvent = makeEvent;\n}\n"],["/generic/linked_list","function (exports, require) {\n    class LinkedList {\n        constructor() {\n            this.size = 0;\n            this.tail = null;\n            this.head = null;\n        }\n        addToTail(value) {\n            let newTail = { prev: null, next: this.tail, value: value };\n            if (this.tail) {\n                this.tail.prev = newTail;\n            }\n            this.tail = newTail;\n            if (!this.head) {\n                this.head = newTail;\n            }\n            this.size++;\n        }\n        addToHead(value) {\n            let newHead = { prev: this.head, next: null, value };\n            if (this.head) {\n                this.head.next = newHead;\n            }\n            this.head = newHead;\n            if (!this.tail) {\n                this.tail = newHead;\n            }\n            this.size++;\n        }\n        removeHead() {\n            if (!this.head) {\n                return undefined;\n            }\n            let res = this.head.value;\n            this.removeElement(this.head);\n            return res;\n        }\n        removeTail() {\n            if (!this.tail) {\n                return undefined;\n            }\n            let res = this.tail.value;\n            this.removeElement(this.tail);\n            return res;\n        }\n        addAllToTail(otherQueue) {\n            if (!otherQueue.head) {\n                return;\n            }\n            if (!this.head) {\n                this.head = otherQueue.head;\n                this.tail = otherQueue.tail;\n                this.size = otherQueue.size;\n                return;\n            }\n            this.tail.prev = otherQueue.head;\n            this.tail.prev.next = this.tail;\n            this.tail = otherQueue.tail;\n            this.size += otherQueue.size;\n        }\n        showHead() {\n            return this.head ? this.head.value : undefined;\n        }\n        showNextToHead() {\n            let res = this.head;\n            if (res) {\n                res = res.prev;\n            }\n            return res ? res.value : undefined;\n        }\n        showTail() {\n            return this.tail ? this.tail.value : undefined;\n        }\n        removeFirst(condition) {\n            let current = this.tail;\n            while (current) {\n                if (!condition(current.value)) {\n                    current = current.next;\n                    continue;\n                }\n                this.removeElement(current);\n                return current.value;\n            }\n            return null;\n        }\n        clear() {\n            this.size = 0;\n            this.head = this.tail = null;\n        }\n        removeElement(el) {\n            if (el.prev) {\n                el.prev.next = el.next;\n            }\n            else {\n                this.tail = el.next;\n            }\n            if (el.next) {\n                el.next.prev = el.prev;\n            }\n            else {\n                this.head = el.prev;\n            }\n            this.size--;\n        }\n        forEachTailToHead(handler) {\n            let curr = this.tail;\n            while (curr) {\n                handler(curr.value);\n                curr = curr.next;\n            }\n        }\n        forEachHeadToTail(handler) {\n            let curr = this.head;\n            while (curr) {\n                handler(curr.value);\n                curr = curr.prev;\n            }\n        }\n        [Symbol.iterator]() {\n            let current = this.tail;\n            return {\n                next() {\n                    if (!current) {\n                        return { done: true, value: undefined };\n                    }\n                    else {\n                        let v = current.value;\n                        current = current.next;\n                        return { done: false, value: v };\n                    }\n                }\n            };\n        }\n    }\n    exports.LinkedList = LinkedList;\n}\n"],["/generic/perfometer","function (exports, require) {\n    class Perfometer {\n        constructor(autoprintAfterNthTick = -1) {\n            this.autoprintAfterNthTick = autoprintAfterNthTick;\n            this.root = this.makeBlock(null);\n            this.currentBlock = this.root;\n            this.ticksPassed = 0;\n            this.startTime = performance.now();\n        }\n        tick() {\n            this.ticksPassed++;\n            if (this.ticksPassed === this.autoprintAfterNthTick) {\n                let now = performance.now();\n                this.print(now - this.startTime);\n                this.reset();\n                this.startTime = now;\n                this.ticksPassed = 0;\n            }\n        }\n        makeBlock(parent) {\n            return {\n                subblocks: {}, parent: parent,\n                timeStart: -1, timeSum: 0,\n                enterCount: 0\n            };\n        }\n        enterBlock(name) {\n            let nextBlock = this.currentBlock.subblocks[name];\n            if (!nextBlock) {\n                nextBlock = this.makeBlock(this.currentBlock);\n                this.currentBlock.subblocks[name] = nextBlock;\n            }\n            nextBlock.timeStart = performance.now();\n            nextBlock.enterCount++;\n            this.currentBlock = nextBlock;\n        }\n        exitBlock() {\n            this.currentBlock.timeSum += performance.now() - this.currentBlock.timeStart;\n            let parent = this.currentBlock.parent;\n            if (!parent) {\n                throw new Error(\"No parent! Blocks are all messed up.\");\n            }\n            this.currentBlock = parent;\n        }\n        exitEnterBlock(name) {\n            this.exitBlock();\n            this.enterBlock(name);\n        }\n        print(realTimePassed) {\n            let table = {};\n            let fullTime = 0;\n            for (let name in this.root.subblocks) {\n                fullTime += this.root.subblocks[name].timeSum;\n            }\n            this.forEachBlock((block, name, depth) => {\n                name = new Array(depth + 1).join(\"-\") + name;\n                table[name] = {\n                    \"parent %\": strip((block.timeSum / block.parent.timeSum) * 100),\n                    \"full %\": strip((block.timeSum / fullTime) * 100),\n                    \"ms per enter\": strip(block.timeSum / block.enterCount),\n                    tps: strip(block.enterCount / (realTimePassed / 1000))\n                };\n            });\n            console.table(table);\n        }\n        reset() {\n            this.root = this.makeBlock(null);\n            this.currentBlock = this.root;\n        }\n        forEachBlock(callback, start = this.root, currentDepth = 0) {\n            for (let name in start.subblocks) {\n                let subblock = start.subblocks[name];\n                callback(subblock, name, currentDepth);\n                this.forEachBlock(callback, subblock, currentDepth + 1);\n            }\n        }\n    }\n    exports.Perfometer = Perfometer;\n    function strip(v) {\n        return Math.round(v * 100) / 100;\n    }\n}\n"],["/generic/set_list",["/generic/linked_list"],"function (exports, require, linked_list_1) {\n    class SetList extends linked_list_1.LinkedList {\n        constructor() {\n            super(...arguments);\n            this.map = new Map();\n        }\n        addToTail(value) {\n            if (!this.map.has(value)) {\n                super.addToTail(value);\n                this.map.set(value, this.tail);\n            }\n        }\n        addToHead(value) {\n            if (!this.map.has(value)) {\n                super.addToHead(value);\n                this.map.set(value, this.head);\n            }\n        }\n        addAllToTail() {\n            throw new Error(\"Operation not supported for SetList\");\n        }\n        contains(value) {\n            return this.map.has(value);\n        }\n        removeValue(value) {\n            let el = this.map.get(value);\n            if (!el) {\n                return false;\n            }\n            this.removeElement(el);\n            return true;\n        }\n        removeElement(el) {\n            super.removeElement(el);\n            this.map.delete(el.value);\n        }\n        clear() {\n            super.clear();\n            this.map.clear();\n        }\n    }\n    exports.SetList = SetList;\n}\n"],["/generic/utils","function (exports, require) {\n    function waitDocumentLoaded() {\n        return new Promise(ok => {\n            let check = () => {\n                if (document.readyState === \"interactive\") {\n                    document.removeEventListener(\"readystatechange\", check, false);\n                    ok();\n                    return true;\n                }\n                return false;\n            };\n            if (check()) {\n                return;\n            }\n            document.addEventListener(\"readystatechange\", check, false);\n        });\n    }\n    exports.waitDocumentLoaded = waitDocumentLoaded;\n    function watchResize(el, handler) {\n        let requestAnimationFrame = window.requestAnimationFrame || ((cb) => window.setTimeout(cb, ~~(1000 / 60)));\n        let style = \"position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;\";\n        let styleChild = \"position: absolute; left: 0; top: 0; transition: 0s;\";\n        let wrap = document.createElement(\"div\");\n        wrap.classList.add(\"resize-sensor\");\n        wrap.style.cssText = style;\n        let expandWrap = document.createElement(\"div\");\n        expandWrap.style.cssText = style;\n        let expandChild = document.createElement(\"div\");\n        expandChild.style.cssText = styleChild;\n        expandWrap.appendChild(expandChild);\n        wrap.appendChild(expandWrap);\n        let shrinkWrap = document.createElement(\"div\");\n        shrinkWrap.style.cssText = style;\n        let shrinkChild = document.createElement(\"div\");\n        shrinkChild.style.cssText = styleChild + \"width: 200%; height: 200%;\";\n        shrinkWrap.appendChild(shrinkChild);\n        wrap.appendChild(shrinkWrap);\n        el.appendChild(wrap);\n        if (wrap.offsetParent !== el) {\n            el.style.position = \"relative\";\n        }\n        let dirty, rafId, newWidth, newHeight;\n        let lastWidth = el.offsetWidth;\n        let lastHeight = el.offsetHeight;\n        let reset = () => {\n            expandChild.style.width = \"100000px\";\n            expandChild.style.height = \"100000px\";\n            expandWrap.scrollLeft = 100000;\n            expandWrap.scrollTop = 100000;\n            shrinkWrap.scrollLeft = 100000;\n            shrinkWrap.scrollTop = 100000;\n        };\n        reset();\n        let onScroll = () => {\n            newWidth = el.offsetWidth;\n            newHeight = el.offsetHeight;\n            dirty = newWidth !== lastWidth || newHeight !== lastHeight;\n            if (dirty && !rafId && handler) {\n                rafId = requestAnimationFrame(() => {\n                    rafId = 0;\n                    if (!dirty) {\n                        return;\n                    }\n                    lastWidth = newWidth;\n                    lastHeight = newHeight;\n                    handler && handler();\n                });\n            }\n            reset();\n        };\n        expandWrap.addEventListener(\"scroll\", onScroll);\n        shrinkWrap.addEventListener(\"scroll\", onScroll);\n        return () => {\n            expandWrap.parentElement && expandWrap.parentElement.removeChild(expandWrap);\n            shrinkWrap.parentElement && shrinkWrap.parentElement.removeChild(shrinkWrap);\n            expandWrap.removeEventListener(\"scroll\", onScroll);\n            shrinkWrap.removeEventListener(\"scroll\", onScroll);\n        };\n    }\n    exports.watchResize = watchResize;\n    function watchDevicePixelRatio(callback) {\n        let currentRatio = window.devicePixelRatio;\n        let media = matchMedia(`(resolution: ${currentRatio}dppx)`);\n        let updatePixelRatio = () => {\n            let pr = window.devicePixelRatio;\n            if (pr !== currentRatio) {\n                callback(pr);\n                currentRatio = pr;\n            }\n            media = matchMedia(`(resolution: ${pr}dppx)`);\n            media.addEventListener(\"change\", updatePixelRatio, { once: true });\n        };\n        try {\n            updatePixelRatio();\n            return () => media.removeEventListener(\"change\", updatePixelRatio);\n        }\n        catch (e) {\n            console.warn(\"Failed to subscribe to devicePixelRatio changes: \" + e);\n            return () => {\n            };\n        }\n    }\n    exports.watchDevicePixelRatio = watchDevicePixelRatio;\n}\n"],["/input_actions",["/engine/context","/entities/critter/player_character"],"function (exports, require, context_1, player_character_1) {\n    const movePlayerGroupName = \"move_player\";\n    function isMovePlayerAction(action) {\n        return action.groupName === movePlayerGroupName;\n    }\n    function movePlayer(deltaTime) {\n        let xDir = 0, yDir = 0;\n        for (let action of context_1.context.inputProcessor.activeHoldActions) {\n            if (!isMovePlayerAction(action)) {\n                continue;\n            }\n            xDir += action.data.x;\n            yDir += action.data.y;\n        }\n        if (xDir === 0 && yDir === 0) {\n            return;\n        }\n        context_1.context.playerCharacter.push(player_character_1.playerCharacterAcceleration * deltaTime, Math.atan2(yDir, xDir));\n    }\n    function makeMovePlayerAction(input, data) {\n        return {\n            input, mode: \"hold\", groupName: movePlayerGroupName, action: movePlayer, data\n        };\n    }\n    exports.inputActions = [\n        makeMovePlayerAction(\"w\", { x: 0, y: 1 }),\n        makeMovePlayerAction(\"a\", { x: -1, y: 0 }),\n        makeMovePlayerAction(\"s\", { x: 0, y: -1 }),\n        makeMovePlayerAction(\"d\", { x: 1, y: 0 })\n    ];\n}\n"],["/main",["/engine/context","/engine/world_object","/entities/terrain/floor","/generic/utils","/input_actions"],"function (exports, require, context_1, world_object_1, floor_1, utils_1, input_actions_1) {\n    async function main() {\n        await (0, utils_1.waitDocumentLoaded)();\n        if (processUnsupported()) {\n            return;\n        }\n        (0, context_1.createContext)(document.body);\n        context_1.context.inputProcessor.setActions(input_actions_1.inputActions);\n        world_object_1.objectModelMapping.wireupAndFinalize();\n        for (let x = -5; x <= 5; x++) {\n            for (let y = -5; y <= 5; y++) {\n                context_1.context.board.addObject(new floor_1.Floor(x, y, 0));\n            }\n        }\n        context_1.context.camera.zoomTo(64);\n        context_1.context.board.addObject(context_1.context.playerCharacter);\n        context_1.context.board.start();\n        context_1.context.camera.follow(context_1.context.playerCharacter);\n    }\n    exports.main = main;\n    function processUnsupported() {\n        let list = getUnsupportedTechList();\n        if (list.length === 0) {\n            return false;\n        }\n        let div = document.createElement(\"div\");\n        div.style.whiteSpace = \"preserve\";\n        div.style.margin = \"auto\";\n        div.style.padding = \"2em\";\n        let msg = \"Your browser does not support some of technologies this game uses, like:\\n\\n\\t\";\n        msg += list.join(\"\\n\\t\") + \"\\n\\n\";\n        msg += \"Update your browser or give up.\";\n        div.textContent = msg;\n        document.body.appendChild(div);\n        return true;\n    }\n    function getUnsupportedTechList() {\n        let result = [];\n        if (!document.createElement(\"canvas\").getContext(\"webgl2\")) {\n            result.push(\"WebGL2\");\n        }\n        if (!window.requestAnimationFrame) {\n            result.push(\"RequestAnimationFrame\");\n        }\n        return result;\n    }\n}\n"]]
,
{"entryPoint":{"module":"/main","function":"main"}},eval);