{"mappings":"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","sources":["src/common/binder/binder.ts","src/common/binder/mutation_binder.ts","src/common/box.ts","src/common/node_data_attacher.ts"],"sourcesContent":["import {MutationBinder} from \"common/binder/mutation_binder\"\nimport {isRBox, RBox} from \"common/box\"\nimport {makeNodeDataAttacher} from \"common/node_data_attacher\"\n\n/** Binder is a way to access various lifecycle events of DOM nodes\n * Through that it can help with subscription to various stuff like boxes */\nexport interface Binder {\n\tonNodeInserted(handler: () => void): void\n\tonNodeRemoved(handler: () => void): void\n\tonNodeInsertedOnce(handler: () => void): void\n\tonNodeRemovedOnce(handler: () => void): void\n\tclearOnNodeInserted(handler: () => void): void\n\tclearOnNodeRemoved(handler: () => void): void\n\twatch<T>(box: RBox<T>, handler: (value: T) => void): () => void\n\twatchAndRun<T>(box: RBox<T>, handler: (value: T) => void): () => void\n\tonResize(handler: () => void): () => void\n\treadonly isInDom: boolean\n}\n\nconst noValue = Symbol()\ntype NoValue = typeof noValue\n\ninterface WatchedBox<T = unknown>{\n\treadonly box: RBox<T>\n\thandler(value: T): void\n\tlastKnownValue: T | NoValue\n\tunsub: (() => void) | null\n}\n\nexport class BinderImpl implements Binder {\n\tprivate insertedHandlers: null | (() => void)[] = null\n\tprivate removedHandlers: null | (() => void)[] = null\n\tprivate watchedBoxes: null | WatchedBox[] = null\n\tprivate resizeObserver: ResizeObserver | null = null\n\tprivate resizeHandlers: null | (() => void)[] = null\n\tprivate lastKnownSize: {w: number, h: number} | null = null\n\tisInDom: boolean\n\n\tconstructor(readonly el: Node) {\n\t\tthis.isInDom = nodeIsInDom(el)\n\t}\n\n\tprivate get element(): Element {\n\t\tconst el = this.el\n\t\tif(!(el instanceof Element)){\n\t\t\tthrow new Error(\"Expected to have node of class Element, but it's not: \" + el)\n\t\t}\n\t\treturn el\n\t}\n\n\tonNodeInserted(handler: () => void): void {\n\t\t(this.insertedHandlers ||= []).push(handler)\n\t}\n\tonNodeRemoved(handler: () => void): void {\n\t\t(this.removedHandlers ||= []).push(handler)\n\t}\n\n\tonNodeInsertedOnce(handler: () => void): void {\n\t\tconst wrappedHandler = () => {\n\t\t\ttry {\n\t\t\t\thandler()\n\t\t\t} finally {\n\t\t\t\tthis.clearOnNodeInserted(wrappedHandler)\n\t\t\t}\n\t\t}\n\n\t\tthis.onNodeInserted(wrappedHandler)\n\t}\n\tonNodeRemovedOnce(handler: () => void): void {\n\t\tconst wrappedHandler = () => {\n\t\t\ttry {\n\t\t\t\thandler()\n\t\t\t} finally {\n\t\t\t\tthis.clearOnNodeRemoved(wrappedHandler)\n\t\t\t}\n\t\t}\n\n\t\tthis.onNodeRemoved(wrappedHandler)\n\t}\n\n\tclearOnNodeInserted(handler: () => void): void {\n\t\tthis.insertedHandlers = dropItemFromArray(this.insertedHandlers, handler)\n\t}\n\tclearOnNodeRemoved(handler: () => void): void {\n\t\tthis.removedHandlers = dropItemFromArray(this.removedHandlers, handler)\n\t}\n\n\tfireNodeInserted(): void {\n\t\tthis.isInDom = true\n\t\tconst boxes = this.watchedBoxes\n\t\tif(boxes){\n\t\t\tfor(let i = 0; i < boxes.length; i++){\n\t\t\t\tconst box = boxes[i]!\n\t\t\t\tconst value = box.box()\n\t\t\t\tif(box.lastKnownValue !== value){\n\t\t\t\t\tthis.invokeBoxHandler(value, box)\n\t\t\t\t}\n\t\t\t\tthis.subToBox(box)\n\t\t\t}\n\t\t}\n\n\t\tthis.updateResizeObserver()\n\n\t\tfireAll(this.insertedHandlers)\n\t}\n\n\tfireNodeRemoved(): void {\n\t\tthis.isInDom = false\n\t\tconst boxes = this.watchedBoxes\n\t\tif(boxes){\n\t\t\tfor(let i = 0; i < boxes.length; i++){\n\t\t\t\tconst box = boxes[i]!\n\t\t\t\tbox.unsub!()\n\t\t\t}\n\t\t}\n\n\t\tthis.updateResizeObserver()\n\n\t\tfireAll(this.removedHandlers)\n\t}\n\n\tprivate invokeBoxHandler<T>(value: T, box: WatchedBox<T>): void {\n\t\tbox.handler(value)\n\t\tbox.lastKnownValue = value\n\t}\n\n\tprivate subToBox(box: WatchedBox): void {\n\t\tbox.unsub = box.box.subscribe(v => this.invokeBoxHandler(v, box))\n\t}\n\n\tprivate _subscribe<T>(box: RBox<T>, handler: (value: T) => void): {unsub(): void, watchedBox: WatchedBox} {\n\t\tconst watchedBox: WatchedBox = {\n\t\t\tbox,\n\t\t\thandler,\n\t\t\tlastKnownValue: noValue,\n\t\t\tunsub: null\n\t\t}\n\t\tif(this.isInDom){\n\t\t\tthis.subToBox(watchedBox)\n\t\t}\n\t\t(this.watchedBoxes ||= []).push(watchedBox)\n\t\treturn {\n\t\t\tunsub: () => {\n\t\t\t\tthis.watchedBoxes = dropItemFromArray(this.watchedBoxes, watchedBox)\n\t\t\t},\n\t\t\twatchedBox\n\t\t}\n\t}\n\n\twatch<T>(box: RBox<T>, handler: (value: T) => void): () => void {\n\t\treturn this._subscribe(box, handler).unsub\n\t}\n\n\twatchAndRun<T>(box: T | RBox<T>, handler: (value: T) => void): () => void {\n\t\tif(isRBox(box)){\n\t\t\tconst {unsub, watchedBox} = this._subscribe(box, handler)\n\t\t\tthis.invokeBoxHandler(box(), watchedBox)\n\t\t\treturn unsub\n\t\t} else {\n\t\t\thandler(box)\n\t\t\treturn () => {\n\t\t\t\t// noop!\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate callResizeHandlers(): void {\n\t\tif(!this.resizeHandlers){\n\t\t\treturn\n\t\t}\n\t\tconst w = this.element.clientWidth\n\t\tconst h = this.element.clientHeight\n\t\tif(this.lastKnownSize){\n\t\t\tif(this.lastKnownSize.w === w && this.lastKnownSize.h === h){\n\t\t\t\treturn\n\t\t\t}\n\t\t\tthis.lastKnownSize.w = w\n\t\t\tthis.lastKnownSize.h = h\n\t\t} else {\n\t\t\tthis.lastKnownSize = {w, h}\n\t\t}\n\n\t\tfor(const handler of this.resizeHandlers){\n\t\t\thandler()\n\t\t}\n\t}\n\n\tprivate updateResizeObserver(): void {\n\t\tif(this.isInDom && this.resizeHandlers){\n\t\t\tif(!this.resizeObserver){\n\t\t\t\tthis.lastKnownSize = {w: this.element.clientWidth, h: this.element.clientHeight}\n\t\t\t\tthis.resizeObserver = new ResizeObserver(this.callResizeHandlers.bind(this))\n\t\t\t\tthis.resizeObserver.observe(this.element)\n\t\t\t}\n\t\t} else if(this.resizeObserver){\n\t\t\tthis.resizeObserver.unobserve(this.element)\n\t\t\tthis.resizeObserver.disconnect()\n\t\t\tthis.resizeObserver = null\n\t\t\tthis.lastKnownSize = null\n\t\t}\n\t}\n\n\tonResize(handler: () => void): () => void {\n\t\tif(!this.resizeHandlers){\n\t\t\tthis.resizeHandlers = []\n\t\t}\n\t\tthis.resizeHandlers.push(handler)\n\n\t\tthis.updateResizeObserver()\n\n\t\treturn () => {\n\t\t\tthis.resizeHandlers = this.resizeHandlers?.filter(x => x !== handler) ?? null\n\t\t\tif(this.removedHandlers?.length === 0){\n\t\t\t\tthis.resizeHandlers = null\n\t\t\t\tthis.updateResizeObserver()\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nconst binderStorage = makeNodeDataAttacher<BinderImpl>(\"__binder_of_this_node\")\nconst mutationBinder = new MutationBinder(binderStorage)\n\nexport function getBinder(el: Node): Binder {\n\tmutationBinder.init()\n\tlet binder = binderStorage.get(el)\n\tif(!binder){\n\t\tbinder = new BinderImpl(el)\n\t\tbinderStorage.set(el, binder)\n\t}\n\treturn binder\n}\n\n// yeah, not very effective\n// though in real applications removal of something from watch list is not frequent operation\n// so, whatever\nfunction dropItemFromArray<T>(arr: T[] | null, item: T): T[] | null {\n\tif(!arr || (arr.length === 1 && arr[0] === item)){\n\t\treturn null\n\t}\n\tconst result = [] as T[]\n\tfor(let i = 0; i < arr.length; i++){\n\t\tconst el = arr[i]!\n\t\tif(el !== item){\n\t\t\tresult.push(el)\n\t\t}\n\t}\n\treturn result\n}\n\nfunction nodeIsInDom(node: Node): boolean {\n\tlet parent = node.parentNode\n\twhile(parent){\n\t\tif(parent === document.body){\n\t\t\treturn true\n\t\t}\n\t\tparent = parent.parentNode\n\t}\n\treturn false\n}\n\nfunction fireAll(handlers: (() => void)[] | null): void {\n\tif(!handlers){\n\t\treturn\n\t}\n\tfor(let i = 0; i < handlers.length; i++){\n\t\thandlers[i]!()\n\t}\n}","import {BinderImpl} from \"common/binder/binder\"\nimport {NodeDataAttacher} from \"common/node_data_attacher\"\n\nexport class MutationBinder {\n\tprivate observer: MutationObserver | null = null\n\n\tconstructor(private readonly binders: NodeDataAttacher<BinderImpl>) {}\n\n\tinit(): void {\n\t\tif(!this.observer){\n\t\t\tthis.observer = new MutationObserver(this.doWithRecords.bind(this))\n\t\t\tthis.observer.observe(document.body, {childList: true, subtree: true})\n\t\t}\n\t}\n\n\tprivate collectEligibleNodes(nodes: Node[]): Set<Node> {\n\t\tconst result = new Set<Node>()\n\t\twhile(true){\n\t\t\tconst node = nodes.pop()\n\t\t\tif(!node){\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif(this.binders.has(node)){\n\t\t\t\tresult.add(node)\n\t\t\t}\n\t\t\tconst children = node.childNodes\n\t\t\tfor(let i = 0; i < children.length; i++){\n\t\t\t\tnodes.push(children[i]!)\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n\n\tprivate doWithRecords(records: MutationRecord[]): void {\n\t\tconst addedNodesArr = [] as Node[]\n\t\tconst removedNodesArr = [] as Node[]\n\t\tfor(let i = 0; i < records.length; i++){\n\t\t\tconst record = records[i]!\n\t\t\tfor(let j = 0; j < record.addedNodes.length; j++){\n\t\t\t\taddedNodesArr.push(record.addedNodes[j]!)\n\t\t\t}\n\t\t\tfor(let j = 0; j < record.addedNodes.length; j++){\n\t\t\t\tremovedNodesArr.push(record.removedNodes[j]!)\n\t\t\t}\n\t\t}\n\n\t\tconst addedNodes = this.collectEligibleNodes(addedNodesArr)\n\t\tconst removedNodes = this.collectEligibleNodes(removedNodesArr)\n\n\t\t// TODO: can optimise here maybe? to not check twice for nodes that was both inserted and removed\n\t\t// also this whole algo feels slow\n\t\tfor(const node of addedNodes){\n\t\t\tif(removedNodes.has(node)){\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tthis.binders.get(node)!.fireNodeInserted()\n\t\t}\n\n\t\tfor(const node of removedNodes){\n\t\t\tif(addedNodes.has(node)){\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tthis.binders.get(node)!.fireNodeRemoved()\n\t\t}\n\t}\n}","type SubscriberHandlerFn<T = unknown> = (value: T) => void\ntype UnsubscribeFn = () => void\n\n\ninterface RBoxFields<T>{\n\t/** Subscribe to receive new value every time it changes\n\t * Returns function that will remove the subscription */\n\tsubscribe(handler: SubscriberHandlerFn<T>): UnsubscribeFn\n\n\t/** Get a box that will update every time value of this box updates\n\t * It is different from `viewBox(mapper)` because mapped box will only depend on source box\n\t * (`viewBox(mapper)` will depend on all the boxes that mapper calls, which may be more than just this) */\n\tmap<R>(mapper: (value: T) => R): RBox<R>\n\n\t/* Those methods are similar to wbox's ones, just those produce readonly boxes */\n\tprop<K extends keyof T>(propKey: K): RBox<T[K]>\n\twrapElements<E, K>(this: RBox<E[]>, getKey: (element: E) => K): RBox<RBox<E>[]>\n}\ntype RBoxCallSignature<T> = () => T\n\n/** Readonly box. You can only look at the value and subscribe to it, but not change that value directly.\n * Behind this interface could be writeable box, or viewBox, or something else entirely. */\nexport type RBox<T> = RBoxCallSignature<T> & RBoxFields<T>\n\n\ninterface WBoxFields<T> extends RBoxFields<T>{\n\t/** Make property box, a box that contains a value of a property of an object of the value from the current box.\n\t * New box will be linked with the source box, so they will update accordingly. */\n\tprop<K extends keyof T>(propKey: K): WBox<T[K]>\n\n\t/** If this box contains array, make a rbox that contains each element of this array wrapped in box\n\t *\n\t * Elements are bound to the values, not to the indices, so if the array is reordered - same values will stay in the same boxes\n\t * Similarity of values is checked by keys. Key is what @param getKey returns.\n\t * The only constraint on what key should be is it should be unique across the array. And it is compared by value.\n\t * So you can have object-keys, they just must be the same objects every time, otherwise it won't work well.\n\t * If original array is shrinked, excess boxes are detached from it and will always throw on read/write of the value,\n\t * even if array grows again with values having same keys.\n\t *\n\t * Can behave weirdly/inconsistently if there are no subscribers to this box or children boxes. */\n\twrapElements<E, K>(this: WBox<E[]>, getKey: (element: E) => K): RBox<WBox<E>[]>\n\n\t/** This really helps Typescript sometimes better infer stuff */\n\treadonly thisHelpsTypings?: true\n}\ntype WBoxCallSignature<T> = RBoxCallSignature<T> & ((newValue: T) => T)\n\n/** Writeable box. Box that you can put value in, as well as look at value inside it and subscribe to it. */\nexport type WBox<T> = WBoxCallSignature<T> & WBoxFields<T>\n\n\nexport type RBoxOrValue<T> = T | RBox<T>\nexport type MaybeRBoxed<T> = [T] extends [RBox<unknown>] ? T : T | RBox<T>\nexport type WBoxOrValue<T> = T | WBox<T>\n\n/** Make a simple writeable box */\nexport const box: <T>(value: T) => WBox<T> = makeValueBox\n/** Make a viewBox, a box that recalculates its value each time any of dependencies changed\n * In most of cases you can safely omit @param explicitDependencyList\n * dependency list will be inferred automatically for you from the computing function */\nexport const viewBox: <T>(computingFn: () => T, explicitDependencyList?: readonly RBox<unknown>[]) => RBox<T> = makeViewBox\n\nexport function isWBox<T>(x: unknown): x is WBox<T> {\n\treturn x instanceof ValueBox\n}\n\nexport function isRBox<T>(x: unknown): x is RBox<T> {\n\treturn x instanceof BoxBase\n}\n\nexport function unbox<T>(x: RBox<T> | T): T\nexport function unbox<T>(x: RBox<T> | T | undefined): T | undefined\nexport function unbox<T>(x: RBox<T> | T | null): T | null\nexport function unbox<T>(x: RBox<T> | T | null | undefined): T | null | undefined\nexport function unbox<T>(x: RBox<T> | T): T {\n\treturn isRBox(x) ? x() : x\n}\n\n\n/*\n============================================================================================\n====== Here public part of box interface ends. Below are gory implementation details. ======\n============================================================================================\n*/\n\ntype AnyBoxImpl<T> = ViewBox<T> | ValueBox<T>\n\ntype NoValue = symbol\nconst noValue: NoValue = Symbol()\n\ninterface ExternalSubscriber<T>{\n\tlastKnownRevision: number\n\tlastKnownValue: T\n\thandler: SubscriberHandlerFn<T>\n}\n\ninterface InternalSubscriber<T> extends ExternalSubscriber<T>{\n\t// those props are here to compare if we should notify when pushing updates\n\tbox: RBoxBase<unknown>\n}\n\n/** Stack of boxes that are currently computing their value\n * Each box that can possibly want to call other boxes should put an item on top of the stack\n * That way, proper dependency graph can be built */\nclass BoxNotificationStack {\n\tprivate notificationStack: (Set<AnyBoxImpl<unknown>> | null)[] = []\n\twithAccessNotifications<R>(action: () => R, onAccess: Set<AnyBoxImpl<unknown>> | null): R {\n\t\tthis.notificationStack.push(onAccess)\n\t\tlet result: R\n\t\ttry {\n\t\t\tresult = action()\n\t\t} finally {\n\t\t\tthis.notificationStack.pop()\n\t\t}\n\t\treturn result\n\t}\n\n\tnotifyOnAccess<T>(v: AnyBoxImpl<T>): void {\n\t\tconst stackTop = this.notificationStack[this.notificationStack.length - 1]\n\t\tif(stackTop){\n\t\t\tstackTop.add(v as AnyBoxImpl<unknown>)\n\t\t}\n\t}\n}\n\n/** Having a function and a prototype, make a function with this prototype and its properties\n * Unfortunately, this implies that constructor of the parent function cannot be called on the function\n * because since ES6 classes can't be called like regular functions and there is no known workaround\n * But any properties defined on the prototype will be copied to the function instance, so it's not too bad\n * Also the function won't receive proper `this` object. This can be done at the cost of performance; I don't need it that hard */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction addPrototypeToFunction<R, A extends never[], F extends (this: null, ...args: A) => R, I extends object>(fn: F, obj: I): I & F {\n\tObject.setPrototypeOf(fn, Object.getPrototypeOf(obj)) // set up the prototype\n\tObject.assign(fn, obj) // clone the properties\n\treturn fn as I & F\n}\n\n\nconst notificationStack = new BoxNotificationStack()\n\n/** Base for every Box */\nabstract class BoxBase<T> {\n\n\t/** Revision is incremented each time value changes\n\t *\n\t * This value must never be visible outside of this box.\n\t * It can only be used to prevent repeated calls of subscribers.\n\t *\n\t * It is very tempting to use revision number to check if value is changed or not\n\t * However, it can go wrong when value does not change until you explicitly check\n\t * For example, consider viewBox that depends on viewBox\n\t * When there is no subscribers, first viewBox will never change, regardless of its sources\n\t * And if you're only relying on revision number to check if it is changed, you'll be wrong */\n\tprivate revision = 1\n\n\t/** Internal subscribers are subscribers that make up a graph of boxes */\n\tprivate internalSubscribers = new Set<InternalSubscriber<T>>()\n\t/** External subscribers are subscribers that receive data outside of boxes graph */\n\tprivate externalSubscribers = new Set<ExternalSubscriber<T>>()\n\n\tconstructor(public value: T | NoValue) {}\n\n\thaveSubscribers(): boolean {\n\t\treturn this.internalSubscribers.size > 0 || this.externalSubscribers.size > 0\n\t}\n\n\t/** After box is disposed, it should not be used anymore\n\t * This is reserved for very special cases and cannot really be used on any kind of box */\n\tdispose(): void {\n\t\tthis.value = noValue\n\t\tfor(const sub of this.internalSubscribers){\n\t\t\tsub.box.dispose()\n\t\t}\n\t}\n\n\tdoSubscribe<B>(external: boolean, handler: SubscriberHandlerFn<T>, box?: RBoxBase<B>): UnsubscribeFn {\n\t\tconst value = this.value\n\t\tif(value === noValue){\n\t\t\tthrow new Error(\"Cannot subscribe to box: no value!\")\n\t\t}\n\n\t\tif(external){\n\t\t\tconst sub: ExternalSubscriber<T> = {\n\t\t\t\thandler,\n\t\t\t\tlastKnownRevision: this.revision,\n\t\t\t\tlastKnownValue: value as T\n\t\t\t}\n\t\t\tthis.externalSubscribers.add(sub)\n\t\t\treturn () => {\n\t\t\t\tthis.externalSubscribers.delete(sub)\n\t\t\t}\n\t\t} else {\n\t\t\tif(!box){\n\t\t\t\tthrow new Error(\"Assertion failed\")\n\t\t\t}\n\t\t\tconst sub: InternalSubscriber<T> = {\n\t\t\t\thandler, box: box as RBoxBase<unknown>,\n\t\t\t\tlastKnownRevision: this.revision,\n\t\t\t\tlastKnownValue: value as T\n\t\t\t}\n\t\t\tthis.internalSubscribers.add(sub)\n\t\t\treturn () => this.internalSubscribers.delete(sub)\n\t\t}\n\t}\n\n\tsubscribe(handler: SubscriberHandlerFn<T>): UnsubscribeFn {\n\t\treturn this.doSubscribe(true, handler)\n\t}\n\n\ttryChangeValue<B>(value: T, box?: RBoxBase<B>): void {\n\t\t// yes, objects can be changed without the change of reference, so this check will fail on such change\n\t\t// it is explicit decision. that way, better performance can be achieved.\n\t\t// because it's much better to explicitly ask user to tell us if something is changed or not\n\t\t// (by cloning the object, changing the clone and setting the clone back into the box)\n\t\t// otherwise (in cases of large box graphs) it may lead to awfully degraded performance\n\t\tconst valueChanged = this.value !== value\n\t\tthis.value = value\n\t\tif(valueChanged){\n\t\t\tthis.revision++\n\t\t\tthis.notify(value, box)\n\t\t}\n\t}\n\n\tnotify<B>(value: T, box: RBoxBase<B> | undefined): void {\n\t\tconst valueRevision = this.revision\n\n\t\tfor(const sub of this.internalSubscribers){\n\t\t\t// if the notification came from the same box - we should not notify it again\n\t\t\tif(sub.box === box){\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tthis.maybeCallSubscriber(sub, value, valueRevision)\n\t\t}\n\n\t\tif(valueRevision < this.revision){\n\t\t\t// this simple cutoff will only work well for external subscribers\n\t\t\t// for anything else there is a risk of not invoking a subscriber at all\n\t\t\t// (this check is a simple optimisation and can be turned off without noticeable change in behaviour)\n\t\t\treturn\n\t\t}\n\n\t\tfor(const sub of this.externalSubscribers){\n\t\t\tthis.maybeCallSubscriber(sub, value, valueRevision)\n\t\t}\n\n\t}\n\n\tprivate maybeCallSubscriber(sub: ExternalSubscriber<T>, value: T, valueRevision: number): void {\n\t\tif(sub.lastKnownRevision > valueRevision){\n\t\t\treturn\n\t\t}\n\n\t\t// revision update should be strictly BEFORE content diff cutoff\n\t\t// because if we detect that value is the same and there is previous notify iteration running with different value,\n\t\t// then, without updating revision, that older iteration will invoke the handler with outdated value\n\t\t// which is big no-no\n\t\tsub.lastKnownRevision = valueRevision\n\t\tif(sub.lastKnownValue === value){\n\t\t\treturn\n\t\t}\n\t\tsub.lastKnownValue = value\n\t\tsub.handler(value)\n\t}\n\n\tmap<R>(this: RBox<T>, mapper: (value: T) => R): RBox<R> {\n\t\treturn makeViewBox(() => mapper(this()), [this])\n\t}\n\n\twrapElements<E, K>(this: ViewBox<E[]> | ValueBox<E[]>, getKey: (element: E) => K): ViewBox<ValueBox<E>[]> {\n\t\treturn makeViewBoxByClassInstance<ValueBox<E>[], ArrayValueWrapViewBox<E, K>>(new ArrayValueWrapViewBox(this, getKey))\n\t}\n\n}\n\ntype RBoxBase<T> = BoxBase<T> & RBox<T>\n\n/** Just a box that just contains value */\nclass ValueBox<T> extends (BoxBase as {\n\tnew<T>(value: T | NoValue): BoxBase<T> & WBoxCallSignature<T> & RBoxCallSignature<T>\n})<T> implements WBoxFields<T> {\n\n\tprop<K extends keyof T>(propKey: K): WBox<T[K]> {\n\t\t// by the way, I could store propbox in some sort of map in the parent valuebox\n\t\t// and later, if someone asks for propbox for the same field, I'll give them the same propbox\n\t\t// this will simplify data logistics a little and possibly reduce memory consumption\n\t\t// however, I don't want to do that because it's relatively rare case - to have two propboxes on same field at the same time\n\t\t// and storing a reference to them in the parent will make them uneligible for GC, which is not very good\n\t\t// (not very bad either, there's a finite amount of them. but it's still something to avoid)\n\t\tif(Array.isArray(this.value)){\n\t\t\tthrow new Error(\"You should not use prop() to get values of elements of the array. Use wrapElements() instead.\")\n\t\t}\n\t\treturn makeUpstreamBox(new FixedPropValueBox(this, propKey))\n\t}\n\n}\n\n/** Box that is subscribed to one other box only when it has its own subscriber(s)\n * Usually that other box is viewed as upstream; source of data that this box is derived from */\nabstract class ValueBoxWithUpstream<T, U = unknown, B extends ValueBox<U> = ValueBox<U>> extends ValueBox<T> {\n\n\tprivate upstreamUnsub: UnsubscribeFn | null = null\n\tconstructor(readonly upstream: B, value: T | NoValue) {\n\t\tsuper(value)\n\t}\n\n\tprotected abstract extractValueFromUpstream(upstreamObject: U): T\n\tprotected abstract buildUpstreamValue(value: T): U\n\n\tprotected fetchValueFromUpstream(): T {\n\t\treturn this.extractValueFromUpstream(this.getUpstreamValue())\n\t}\n\n\tprotected shouldBeSubscribed(): boolean {\n\t\treturn this.haveSubscribers()\n\t}\n\n\tprotected doOnUpstreamChange(upstreamValue: U): void {\n\t\tconst ourValue = this.extractValueFromUpstream(upstreamValue)\n\t\tthis.tryChangeValue(ourValue, this.upstream)\n\t}\n\n\tprotected notifyUpstreamOnChange(value: T): void {\n\t\tconst upstreamObject = this.buildUpstreamValue(value)\n\t\tthis.upstream.tryChangeValue(upstreamObject, this)\n\t}\n\n\tprotected getUpstreamValue(): U {\n\t\t// if we are called from view calc function - we should prevent view to access our upstream box\n\t\t// so view will only subscribe to this box, but not to the parent\n\t\treturn notificationStack.withAccessNotifications(this.upstream, null)\n\t}\n\n\tgetBoxValue(): T {\n\t\t// just checking if we have value before returning it is not enough\n\t\t// sometimes when we have value we can be not subscribed\n\t\t// that means that our value can be outdated and we need to fetch new one regardless\n\t\tif(this.value !== noValue && this.upstreamUnsub !== null){\n\t\t\treturn this.value as T\n\t\t} else {\n\t\t\treturn this.fetchValueFromUpstream()\n\t\t}\n\t}\n\n\ttryUpdateUpstreamSub(): void {\n\t\tconst shouldBeSub = this.shouldBeSubscribed()\n\t\tif(shouldBeSub && !this.upstreamUnsub){\n\t\t\tthis.subToUpstream()\n\t\t} else if(!shouldBeSub && this.upstreamUnsub){\n\t\t\tthis.unsubFromUpstream()\n\t\t}\n\t}\n\n\tprivate unsubFromUpstream() {\n\t\tif(!this.upstreamUnsub){\n\t\t\tthrow new Error(\"Assertion failed\")\n\t\t}\n\t\tthis.upstreamUnsub()\n\t\tthis.upstreamUnsub = null\n\t\tthis.value = this.getEmptyValue()\n\t}\n\n\tprivate subToUpstream(): void {\n\t\tif(this.upstreamUnsub){\n\t\t\tthrow new Error(\"Assertion failed\")\n\t\t}\n\t\tif(this.value === noValue){\n\t\t\tthis.value = this.getBoxValue()\n\t\t}\n\t\tthis.upstreamUnsub = this.upstream.doSubscribe(false, this.doOnUpstreamChange.bind(this), this)\n\t}\n\n\toverride doSubscribe<B>(external: boolean, handler: SubscriberHandlerFn<T>, box?: RBoxBase<B>): UnsubscribeFn {\n\t\tif(this.value === noValue){\n\t\t\tthis.value = this.getBoxValue()\n\t\t}\n\t\tconst unsub = super.doSubscribe(external, handler, box)\n\t\tthis.tryUpdateUpstreamSub()\n\t\treturn () => {\n\t\t\tunsub()\n\t\t\tthis.tryUpdateUpstreamSub()\n\t\t}\n\t}\n\n\toverride notify<B>(value: T, box: RBoxBase<B> | undefined): void {\n\t\t// it's kinda out of place, but anyway\n\t\t// if this box have no subscribers - it should never store value\n\t\t// because it also don't subscribe to upstream in that case (because amount of subscriptions should be minimised)\n\t\tif(!this.shouldBeSubscribed()){\n\t\t\tthis.value = this.getEmptyValue()\n\t\t}\n\n\t\t// this is also a little out of place\n\t\t// think of this block as a notification to parent that child value is changed\n\t\t// (although this is not conventional call to subscription)\n\t\tif(box as unknown !== this.upstream){\n\t\t\tthis.notifyUpstreamOnChange(value)\n\t\t}\n\n\t\tsuper.notify(value, box)\n\t}\n\n\tprotected getEmptyValue(): T | NoValue {\n\t\treturn noValue\n\t}\n\n}\n\nclass FixedPropValueBox<U, K extends keyof U> extends ValueBoxWithUpstream<U[K], U> {\n\n\tconstructor(upstream: ValueBox<U>, protected readonly propKey: K) {\n\t\tsuper(upstream, noValue)\n\t}\n\n\tprotected override extractValueFromUpstream(upstreamObject: U): U[K] {\n\t\treturn upstreamObject[this.propKey]\n\t}\n\n\tprotected override buildUpstreamValue(value: U[K]): U {\n\t\tconst upstreamObject = this.getUpstreamValue()\n\t\tif(Array.isArray(upstreamObject)){\n\t\t\tthrow new Error(`Upstream object is an array! Cannot properly clone it to set the property \"${this.propKey.toString()}\" value.`)\n\t\t}\n\t\treturn {\n\t\t\t...upstreamObject,\n\t\t\t[this.propKey]: value\n\t\t}\n\t}\n\n}\n\nfunction makeUpstreamBox<T, U, B>(instance: ValueBoxWithUpstream<T, U> & B): ValueBoxWithUpstream<T, U> & B {\n\n\tfunction upstreamValueBox(...args: T[]): T {\n\t\tif(args.length === 0){\n\t\t\tnotificationStack.notifyOnAccess(result)\n\t\t} else {\n\t\t\tresult.tryChangeValue(args[0]!)\n\t\t}\n\n\t\treturn result.getBoxValue()\n\t}\n\n\tconst result = addPrototypeToFunction(upstreamValueBox, instance)\n\n\treturn result\n}\n\nfunction makeValueBox<T>(value: T): ValueBox<T> {\n\n\tfunction valueBox(...args: T[]): T {\n\t\tif(args.length < 1){\n\t\t\tnotificationStack.notifyOnAccess(result)\n\t\t} else {\n\t\t\tresult.tryChangeValue(args[0]!)\n\t\t}\n\n\t\tif(result.value === noValue){\n\t\t\t// should never happen\n\t\t\tthrow new Error(\"After executing valueBox the value is absent!\")\n\t\t}\n\n\t\treturn result.value as T\n\t}\n\n\tconst result = addPrototypeToFunction(valueBox, new ValueBox(value))\n\n\treturn result\n}\n\n\nabstract class ViewBox<T> extends (BoxBase as {\n\tnew<T>(value: T | NoValue): BoxBase<T> & RBoxCallSignature<T>\n})<T> implements RBoxFields<T> {\n\n\t/*\n\tHere it gets a little tricky.\n\tLifetime of the view is by definition lower than lifetime of values it depends on\n\t(because those values are referenced through closure expression of the view)\n\tBut when every external reference to the view is gone, it should be eligible to get GCed\n\twhich is not possible if it stays subscribed, because subscription will hold a reference to the view\n\t(it is btw typical \"lapsed listeners\" problem)\n\n\tTo avoid this we employ the following tactics:\n\t1. view don't store ANYTHING when noone is subscribed (no list of dependencies, no value, nothing)\n\tin this mode view just calls computing function when asked for the value\n\t2. when we HAVE subscribers to view - value is stored, list of dependencies is stored\n\tview returns stored value when asked for value in this mode\n\n\tThis way, you only need to remove all subscribers from view for it to be eligible to be GCed\n\t*/\n\tprivate subDisposers: UnsubscribeFn[] = []\n\tprivate onDependencyListUpdated: null | (() => void) = null\n\n\tprivate boundCalcVal: (() => T) | null = null\n\tprotected abstract calculateValue(): T\n\n\tconstructor(private readonly explicitDependencyList: readonly RBox<unknown>[] | undefined) {\n\t\tsuper(noValue)\n\t}\n\n\tprivate subDispose(): void {\n\t\tthis.subDisposers.forEach(x => x())\n\t\tthis.subDisposers.length = 0\n\t}\n\n\tprivate shouldRecalcValue(): boolean {\n\t\tif(this.value === noValue){\n\t\t\treturn true // no value? let's recalculate\n\t\t}\n\n\t\tif(this.subDisposers.length === 0){\n\t\t\t// we are not subscribed to anyone\n\t\t\t// that means calcFunction either is constant expression, or depends on some plain variables that can change\n\t\t\t// better recalculate\n\t\t\treturn true\n\t\t}\n\n\t\treturn false // we have value, no need to do anything\n\t}\n\n\tprivate recalcValueAndResubscribe(forceSubscribe: boolean): void {\n\t\t// we preserve list of our old subscriptions to drop them only at the end of the method\n\t\t// we do that because some box implementations can change its internal state dramatically when they have 0 subs\n\t\t// and to prevent them going back and forth, we first create new subscribers, and only then let go old ones\n\t\tconst oldSubDisposers = [...this.subDisposers]\n\n\t\tlet newValue: T\n\t\tlet depList: readonly AnyBoxImpl<unknown>[]\n\t\tconst calc = this.boundCalcVal ||= this.calculateValue.bind(this)\n\t\tif(!this.explicitDependencyList){\n\t\t\tconst boxesAccessed = new Set<AnyBoxImpl<unknown>>()\n\t\t\tnewValue = notificationStack.withAccessNotifications(calc, boxesAccessed)\n\t\t\tdepList = [...boxesAccessed]\n\t\t} else {\n\t\t\tnewValue = notificationStack.withAccessNotifications(calc, null)\n\t\t\tdepList = this.explicitDependencyList as AnyBoxImpl<unknown>[]\n\t\t}\n\n\t\t// we can safely not pass a box here\n\t\t// because box is only used to prevent notifications to go back to original box\n\t\t// and we should never be subscribed to itself, because it's not really possible\n\t\tthis.tryChangeValue(newValue)\n\n\t\t// this check is here because as a result of recalculation we may lose all of our subscribers\n\t\t// and therefore we don't need to be subscribed to anything anymore\n\t\t// (that's the case with array wrap)\n\t\tif(forceSubscribe || this.haveSubscribers()){\n\t\t\tif(depList.length > 0){\n\t\t\t\tconst doOnDependencyUpdated = this.onDependencyListUpdated ||= () => this.recalcValueAndResubscribe(false)\n\t\t\t\tfor(let i = 0; i < depList.length; i++){\n\t\t\t\t\tthis.subDisposers.push(depList[i]!.doSubscribe(false, doOnDependencyUpdated, this))\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.value = noValue\n\t\t}\n\t\tfor(const subDisposer of oldSubDisposers){\n\t\t\tsubDisposer()\n\t\t}\n\t\t// ew. maybe there is some more efficient structure for that...?\n\t\tthis.subDisposers = this.subDisposers.slice(oldSubDisposers.length)\n\t}\n\n\toverride doSubscribe<B>(external: boolean, handler: SubscriberHandlerFn<T>, box?: RBoxBase<B> | undefined): UnsubscribeFn {\n\t\tif(!this.haveSubscribers()){\n\t\t\t// because we must have a value before doSubscribe can be called\n\t\t\t// and also we will have a sub right now, might as well prepare for that\n\t\t\tthis.recalcValueAndResubscribe(true)\n\t\t}\n\t\tconst unsub = super.doSubscribe(external, handler, box)\n\t\treturn () => {\n\t\t\tunsub()\n\t\t\tif(!this.haveSubscribers()){\n\t\t\t\tthis.subDispose()\n\t\t\t\tthis.value = noValue\n\t\t\t}\n\t\t}\n\t}\n\n\tgetValue(): T {\n\t\tnotificationStack.notifyOnAccess(this)\n\n\t\tif(!this.shouldRecalcValue()){\n\t\t\treturn this.value as T\n\t\t}\n\n\t\tconst calc = this.boundCalcVal ||= this.calculateValue.bind(this)\n\t\treturn notificationStack.withAccessNotifications(calc, null)\n\t}\n\n\tprop<K extends keyof T>(propKey: K): RBox<T[K]> {\n\t\treturn this.map(v => v[propKey])\n\t}\n\n}\n\nclass ComputingFnViewBox<T> extends ViewBox<T> {\n\n\tconstructor(protected readonly calculateValue: () => T, explicitDependencyList: readonly RBox<unknown>[] | undefined) {\n\t\tsuper(explicitDependencyList)\n\t}\n\n}\n\nfunction makeViewBox<T>(computingFn: () => T, explicitDependencyList?: readonly RBox<unknown>[]): ViewBox<T> {\n\treturn makeViewBoxByClassInstance<T, ViewBox<T>>(new ComputingFnViewBox(computingFn, explicitDependencyList))\n}\n\nfunction makeViewBoxByClassInstance<T, B extends ViewBox<T>>(instance: B): B {\n\tfunction viewBox(): T {\n\t\treturn result.getValue()\n\t}\n\n\tconst result = addPrototypeToFunction(viewBox, instance)\n\treturn result\n}\n\nclass ArrayValueWrapViewBox<T, K> extends ViewBox<ValueBox<T>[]> {\n\n\tprivate readonly childMap = new Map<K, ArrayElementValueBox<T, K>>()\n\n\tconstructor(readonly upstream: ViewBox<T[]> | ValueBox<T[]>, private readonly getKey: (value: T) => K) {\n\t\tsuper([upstream])\n\t}\n\n\tprotected override calculateValue(): ValueBox<T>[] {\n\t\tif(typeof(this) !== \"function\"){\n\t\t\tthrow new Error(\"Assertion failed\")\n\t\t}\n\t\tconst outdatedKeys = new Set(this.childMap.keys())\n\n\t\tconst upstreamArray = notificationStack.withAccessNotifications(this.upstream, null)\n\t\tif(!Array.isArray(upstreamArray)){\n\t\t\tthrow new Error(\"Assertion failed: upstream value is not array for array-wrap box\")\n\t\t}\n\t\tconst result = upstreamArray.map((item, index) => {\n\t\t\tconst key = this.getKey(item)\n\t\t\tlet box = this.childMap.get(key)\n\t\t\tif(box){\n\t\t\t\tif(!outdatedKeys.has(key)){\n\t\t\t\t\tthrow new Error(\"Constraint violated, key is not unique: \" + key)\n\t\t\t\t}\n\t\t\t\tbox.index = index\n\t\t\t\tbox.tryChangeValue(item, this)\n\t\t\t} else {\n\t\t\t\tbox = makeUpstreamBox(new ArrayElementValueBox(key, index, item, this))\n\t\t\t\tthis.childMap.set(key, box)\n\t\t\t}\n\n\t\t\toutdatedKeys.delete(key)\n\n\t\t\treturn box\n\t\t})\n\n\t\tfor(const key of outdatedKeys){\n\t\t\tconst box = this.childMap.get(key)!\n\t\t\tbox.dispose()\n\t\t\tthis.childMap.delete(key)\n\t\t}\n\n\t\treturn result\n\t}\n\n\ttryUpdateChildrenValues(): void {\n\t\tthis.calculateValue()\n\t}\n\n\tnotifyValueChanged(value: T, box: ArrayElementValueBox<T, K>): void {\n\t\tif(!isWBox(this.upstream)){\n\t\t\t// should be prevented by typechecker anyway\n\t\t\tthrow new Error(\"You cannot change the value of upstream array in readonly box through wrap-box\")\n\t\t}\n\n\t\tconst key = this.getKey(value)\n\t\tconst existingBox = this.childMap.get(key)\n\t\tconst oldBoxKey = box.key\n\t\tif(!existingBox){\n\t\t\tthis.childMap.delete(box.key)\n\t\t\tthis.childMap.set(key, box)\n\t\t\tbox.key = key\n\t\t} else if(existingBox !== box){\n\t\t\tthrow new Error(\"Constraint violated, key is not unique: \" + key)\n\t\t}\n\n\t\t// Q: why do we search for key here?\n\t\t// A: see explaination in element wrap impl\n\t\t// (in short, index could change between updates, that's why we don't rely on them)\n\t\tlet upstreamValue = notificationStack.withAccessNotifications(this.upstream, null)\n\t\tupstreamValue = [...upstreamValue]\n\t\tlet index = -1\n\t\tif(this.haveSubscribers()){\n\t\t\t// if we are subscribed - we can use index, it is guaranteed to be consistent with the upstream\n\t\t\t// it is optimisation anyway; if it will cause trouble - we always can just search for the key every time\n\t\t\tindex = box.index\n\t\t} else {\n\t\t\tfor(let i = 0; i < upstreamValue.length; i++){\n\t\t\t\tconst item = upstreamValue[i]!\n\t\t\t\tconst itemKey = this.getKey(item)\n\t\t\t\tif(itemKey === oldBoxKey){\n\t\t\t\t// we can just break on the first found key, I'm just all about assertions\n\t\t\t\t// btw maybe this assertion will break some of legitimate use cases..?\n\t\t\t\t\tif(index >= 0){\n\t\t\t\t\t\tthrow new Error(\"Constraint violated, key is not unique: \" + oldBoxKey)\n\t\t\t\t\t}\n\t\t\t\t\tindex = i\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(index < 0){\n\t\t\t\t// value with old key is not found\n\t\t\t\t// that means the box was detached before it received an update\n\t\t\t\tbox.dispose()\n\t\t\t\tbox.throwDetachedError()\n\t\t\t}\n\t\t}\n\n\t\tupstreamValue[index] = value\n\t\tthis.upstream.tryChangeValue(upstreamValue, this)\n\t}\n\n}\n\nclass ArrayElementValueBox<T, K> extends ValueBoxWithUpstream<T, ValueBox<T>[], ArrayValueWrapViewBox<T, K>> {\n\n\tprivate disposed = false\n\n\tconstructor(public key: K, public index: number, value: T, upstream: ArrayValueWrapViewBox<T, K>) {\n\t\tsuper(upstream, value)\n\t}\n\n\toverride dispose(): void {\n\t\tthis.disposed = true\n\t\t// update of sub may or may not set empty value (if there is no sub)\n\t\t// let's set it explicitly\n\t\tthis.value = noValue\n\t\tthis.tryUpdateUpstreamSub()\n\t\tsuper.dispose()\n\t}\n\n\tprotected override shouldBeSubscribed(): boolean {\n\t\treturn !this.disposed && super.shouldBeSubscribed()\n\t}\n\n\tprotected override fetchValueFromUpstream(): T {\n\t\t// this is bad, but I don't see a better solution\n\t\t// thing is, when you're not subscribed - you have absolutely zero guarantees that upstream did not change\n\t\t// (and you can't be always subscribed because it will create memory leak)\n\t\t// this has two consequences:\n\t\t// 1. you can't rely that `index` stays the same\n\t\t// (so you cannot just grab upstream, take value on the index and expect it to be the value you're after)\n\t\t// 2. you can't rely that your value is still in the array at all\n\t\t// (so you may become detached at arbitrary moment, possibly with outdated value)\n\t\t// we combat those two consequences with following countermeasures:\n\t\t// 1. when we need to get the value, we ALWAYS receive value from wrapper box. no exceptions.\n\t\t// alternative to that will be grabbing upstream array, iterating over each item and checking for key equality\n\t\t// but this will be terrible for performance\n\t\t// 2. we forbid accessing detached values at all\n\t\t// this is bad because two things: it can unexpectedly break, and it is inconsistent\n\t\t// I mean, who knows when exactly value disappeared from upstream array if we was not subscribed to it?\n\t\t// noone knows! and by that reason box may become detached (if update happened during absence of value),\n\t\t// or not (if it did not happen, or happened after value with the same key appears in array again)\n\t\t// what can go wrong, usage-wise?\n\t\t// well, if user stores element wrapper boxes - he should be prepared that sometimes they can throw\n\t\tthis.checkNotDisposed()\n\t\tthis.upstream.tryUpdateChildrenValues()\n\t\tthis.checkNotDisposed() // second check, we may become disposed after update\n\t\treturn this.value as T\n\t}\n\n\tprivate checkNotDisposed(): void {\n\t\tif(this.disposed){\n\t\t\tthis.throwDetachedError()\n\t\t}\n\t}\n\n\tthrowDetachedError(): void {\n\t\tthrow new Error(\"Element wrap box for key \" + anythingToString(this.key) + \" is no longer attached to an upstream box, because upstream box does not have this key, or did not have this key in some time in the past after this box was created.\")\n\t}\n\n\tprotected override extractValueFromUpstream(): T {\n\t\tthrow new Error(\"This method should never be called on this box\")\n\t}\n\n\tprotected override buildUpstreamValue(): ValueBox<T>[] {\n\t\tthrow new Error(\"This method should never be called on this box\")\n\t}\n\n\tprotected override doOnUpstreamChange(): void {\n\t\t// nothing. upstream will put value into this box by itself\n\t\t// element box must never subscribe to upstream-of-upstream array-box directly, or pull values by itself\n\t\t// this way its index can sometimes be outdated and he can pull wrong value from upstream\n\t\t// instead, element box must force parent view to subscribe to upstream\n\t\t// so parent view can handle down proper index and value at the same time\n\t\t// so, we still subscribe to upstream, just so it is subscribed to upstream-of-upstream and deliver updates\n\t}\n\n\tprotected notifyUpstreamOnChange(value: T): void {\n\t\tthis.checkNotDisposed()\n\t\tthis.upstream.notifyValueChanged(value, this)\n\t}\n\n\tprotected override getEmptyValue(): NoValue | T {\n\t\treturn this.disposed ? noValue : this.value\n\t}\n\n}\n\nfunction anythingToString(x: unknown): string {\n\tif(typeof(x) === \"symbol\"){\n\t\treturn x.toString()\n\t} else {\n\t\treturn x + \"\"\n\t}\n}","export interface NodeDataAttacher<T> {\n\tget(node: Node): T | undefined\n\tset(node: Node, value: T): void\n\tdelete(node: Node): boolean\n\thas(node: Node): boolean\n}\n\nexport function makeNodeDataAttacher<T>(key: string): NodeDataAttacher<T> {\n\treturn typeof(WeakMap) === \"undefined\" ? new PropNodeDataAttacher(key) : new WeakMapNodeDataAttacher()\n}\n\nclass WeakMapNodeDataAttacher<T> implements NodeDataAttacher<T> {\n\n\tprivate readonly map = new WeakMap<Node, T>()\n\n\tget(node: Node): T | undefined {\n\t\treturn this.map.get(node)\n\t}\n\n\tset(node: Node, value: T): void {\n\t\tthis.map.set(node, value)\n\t}\n\n\tdelete(node: Node): boolean {\n\t\treturn this.map.delete(node)\n\t}\n\n\thas(node: Node): boolean {\n\t\treturn this.map.has(node)\n\t}\n\n}\n\n// fallback for when weakmap is not available\nclass PropNodeDataAttacher<T> implements NodeDataAttacher<T> {\n\n\tconstructor(readonly key: string) {}\n\n\tget(node: Node): T | undefined {\n\t\treturn (node as Node & Record<string, T>)[this.key]\n\t}\n\n\tset(node: Node, value: T): void {\n\t\t(node as Node & Record<string, T>)[this.key] = value\n\t}\n\n\tdelete(node: Node): boolean {\n\t\tconst hasValue = this.has(node)\n\t\tdelete(node as Node & Record<string, T>)[this.key]\n\t\treturn hasValue\n\t}\n\n\thas(node: Node): boolean {\n\t\treturn this.key in node\n\t}\n\n}"],"names":["$aCiCs","parcelRequire","$ec1a4e88f7232e38$var$noValue","Symbol","$ec1a4e88f7232e38$export$f1c386966361cb4b","constructor","el","insertedHandlers","removedHandlers","watchedBoxes","resizeObserver","resizeHandlers","lastKnownSize","this","isInDom","node","parent","parentNode","document","body","$ec1a4e88f7232e38$var$nodeIsInDom","element","Element","Error","onNodeInserted","handler","push","onNodeRemoved","onNodeInsertedOnce","wrappedHandler","clearOnNodeInserted","onNodeRemovedOnce","clearOnNodeRemoved","$ec1a4e88f7232e38$var$dropItemFromArray","fireNodeInserted","boxes","i","length","box","value","lastKnownValue","invokeBoxHandler","subToBox","updateResizeObserver","$ec1a4e88f7232e38$var$fireAll","fireNodeRemoved","unsub","subscribe","v","_subscribe","watchedBox","watch","watchAndRun","$hsvBG","isRBox","callResizeHandlers","w","clientWidth","h","clientHeight","ResizeObserver","bind","observe","unobserve","disconnect","onResize","filter","x","$ec1a4e88f7232e38$var$binderStorage","$gc7tN","makeNodeDataAttacher","$ec1a4e88f7232e38$var$mutationBinder","MutationBinder","$ec1a4e88f7232e38$export$cea74a7209884f00","init","binder","get","set","arr","item","result","handlers","$695512ce11bf5a1b$export$7140fce7acc49c5c","binders","observer","MutationObserver","doWithRecords","childList","subtree","collectEligibleNodes","nodes","Set","pop","has","add","children","childNodes","records","addedNodesArr","removedNodesArr","record","j","addedNodes","j1","removedNodes","node1","$f5c28d2dcb4e1f77$export$827f4ee28efc37","$f5c28d2dcb4e1f77$var$addPrototypeToFunction","args","$f5c28d2dcb4e1f77$var$notificationStack","notifyOnAccess","tryChangeValue","$f5c28d2dcb4e1f77$var$noValue","$f5c28d2dcb4e1f77$var$ValueBox","$f5c28d2dcb4e1f77$export$74473745afe6cecc","$f5c28d2dcb4e1f77$var$BoxBase","$f5c28d2dcb4e1f77$export$c1d3dacf4f169228","fn","obj","Object","setPrototypeOf","getPrototypeOf","assign","notificationStack","withAccessNotifications","action","onAccess","stackTop","revision","internalSubscribers","externalSubscribers","haveSubscribers","size","dispose","sub","doSubscribe","external","lastKnownRevision","delete","sub1","valueChanged","notify","valueRevision","maybeCallSubscriber","map","mapper","$f5c28d2dcb4e1f77$var$makeViewBox","wrapElements","getKey","$f5c28d2dcb4e1f77$var$makeViewBoxByClassInstance","$f5c28d2dcb4e1f77$var$ArrayValueWrapViewBox","prop","propKey","Array","isArray","$f5c28d2dcb4e1f77$var$makeUpstreamBox","$f5c28d2dcb4e1f77$var$FixedPropValueBox","$f5c28d2dcb4e1f77$var$ValueBoxWithUpstream","upstream","super","upstreamUnsub","fetchValueFromUpstream","extractValueFromUpstream","getUpstreamValue","shouldBeSubscribed","doOnUpstreamChange","upstreamValue","ourValue","notifyUpstreamOnChange","upstreamObject","buildUpstreamValue","getBoxValue","tryUpdateUpstreamSub","shouldBeSub","subToUpstream","unsubFromUpstream","getEmptyValue","toString","instance","$f5c28d2dcb4e1f77$var$ViewBox","explicitDependencyList","subDisposers","onDependencyListUpdated","boundCalcVal","subDispose","forEach","shouldRecalcValue","recalcValueAndResubscribe","forceSubscribe","oldSubDisposers","newValue","depList","calc","calculateValue","boxesAccessed","doOnDependencyUpdated","subDisposer","slice","getValue","$f5c28d2dcb4e1f77$var$ComputingFnViewBox","computingFn","childMap","Map","outdatedKeys","keys","upstreamArray","index","key","$f5c28d2dcb4e1f77$var$ArrayElementValueBox","tryUpdateChildrenValues","notifyValueChanged","existingBox","oldBoxKey","throwDetachedError","disposed","checkNotDisposed","$8a7ba224764c5aa0$export$cfd492373f61d2e7","WeakMap","$8a7ba224764c5aa0$var$PropNodeDataAttacher","$8a7ba224764c5aa0$var$WeakMapNodeDataAttacher","hasValue"],"version":3,"file":"digger.de2df654.js.map"}