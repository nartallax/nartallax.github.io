{"mappings":"2TAAA,IAAAA,EAAAC,EAAA,SAEA,MAAMC,EAAU,iBAEHC,EAAQC,IACpB,MAAMC,EAAK,IAAIC,EAA2B,gBAEpCC,GAAoB,EAAAP,EAAAQ,KAAI,CAC7BA,IAAK,QAASC,MAAO,CACpBC,YAAa,sBACbC,KAAM,OACNC,MAAOC,aAAaX,IAAY,MAG5BY,GAAU,EAAAd,EAAAQ,KAAI,CACnBA,IAAK,QAASC,MAAO,CACpBC,YAAa,kBACbC,KAAM,UAIRP,EAAKW,YAAYR,GACjBH,EAAKW,YAAYD,GAEZ,WACJA,EAAQF,YAAcP,EAAGW,IAAId,IAAY,EAC1C,EAFK,GAIL,MAAMe,EAAuB,KAC5BJ,aAAaX,GAAWK,EAAkBK,KAAK,EAE1CM,EAAc,KACdb,EAAGc,IAAIjB,EAASY,EAAQF,MAAK,EAGnC,IAAI,MAAOQ,EAAOC,IAAa,CAAC,CAACd,EAAmBU,GAAuB,CAACH,EAASI,IACpFE,EAAME,iBAAiB,UAAWD,GAClCD,EAAME,iBAAiB,SAAUD,GACjCD,EAAME,iBAAiB,QAASD,EACjC,EAKD,MAAMf,EACLiB,YAAqBC,G,YAAAA,E,KACJC,UAAY,E,KACZC,UAAY,eAFS,CAI9BC,QAAQtB,GACf,MAAMuB,EAAQvB,EAAGwB,kBAAkBC,KAAKJ,WACxC,OAAO,IAAIK,SAAQ,CAACC,EAASC,KAC5BL,EAAMM,YAAYC,QAAUC,GAAKH,EAAOG,GACxCR,EAAMM,YAAYG,WAAa,IAAML,GAAA,GAEvC,CAEAM,cACC,OAAO,IAAIP,SAAQ,CAACC,EAASC,KAC5B,MAAMM,EAAMC,OAAOC,UAAUC,KAAKZ,KAAKN,OAAQM,KAAKL,WACpDc,EAAIJ,QAAUC,IACbH,EAAOG,EAAA,EAERG,EAAII,UAAYP,IACfJ,EAAQI,EAAGQ,OAAeC,OAAM,EAEjCN,EAAIO,gBAAkBR,MAAMF,IAC3B,MAAM/B,EAAK+B,EAAGQ,OAAeC,aACvBf,KAAKH,QAAQtB,GACnB2B,EAAQ3B,EAAA,CACT,GAEF,CAEAiC,oBAA+BjC,EAAiB0C,GAC/C,MAAMb,EAAc7B,EAAG6B,YAAY,CAACJ,KAAKJ,WAAY,aAC/CE,EAAQM,EAAYc,YAAYlB,KAAKJ,WAC3C,IAAImB,EAAmB,KACnBI,GAAY,EACZC,GAAc,EACdC,EAA6C,KAEjD,MAAMC,EAAgB,IAAIrB,SAAW,CAACC,EAASC,KAC9CkB,EAAgBnB,EAChBE,EAAYG,WAAa,KACxBa,GAAc,EACXD,GACFjB,EAAQa,EAAA,EAGVX,EAAYC,QAAUC,GAAKH,EAAOG,EAAA,IASnC,OANAS,QAAeE,EAASnB,EAAOM,GAC/Be,GAAY,EACTC,GACFC,EAAeN,GAGTO,CACR,CAEQC,kBAAkBzB,EAAuB0B,EAAa1C,GAE7D,MAAM2C,EAAU3B,EAAM4B,IAAI5C,EAAO0C,GACjC,OAAO,IAAIvB,SAAQ,CAACC,EAASC,KAC5BsB,EAAQpB,QAAUC,GAAKH,EAAOG,GAC9BmB,EAAQZ,UAAY,IAAMX,GAAA,GAE5B,CAEQyB,kBAAkB7B,EAAuB0B,GAChD,MAAMC,EAAU3B,EAAMZ,IAAIsC,GAC1B,OAAO,IAAIvB,SAAQ,CAACC,EAASC,KAC5BsB,EAAQpB,QAAUC,GAAKH,EAAOG,GAC9BmB,EAAQZ,UAAYP,GAAKJ,EAAQI,EAAGQ,OAAeC,OAAM,GAE3D,CAEQa,qBAAqB9B,EAAuB0B,GACnD,MAAMC,EAAU3B,EAAM+B,OAAOL,GAC7B,OAAO,IAAIvB,SAAQ,CAACC,EAASC,KAC5BsB,EAAQpB,QAAUC,GAAKH,EAAOG,GAC9BmB,EAAQZ,UAAY,IAAMX,CAAA,GAE5B,CAEAM,UAAUgB,GACT,MAAMjD,QAAWyB,KAAK8B,QACtB,aAAa9B,KAAK+B,cAAcxD,GAAIiC,MAAMV,SAC5BE,KAAK2B,kBAAkB7B,EAAO0B,IAE7C,CAEAhB,UAAUgB,EAAa1C,GACtB,MAAMP,QAAWyB,KAAK8B,cAChB9B,KAAK+B,cAAcxD,GAAIiC,MAAMV,UAC5BE,KAAKuB,kBAAkBzB,EAAO0B,EAAK1C,EAAA,GAE3C,CAEA0B,aAAagB,GACZ,MAAMjD,QAAWyB,KAAK8B,cAChB9B,KAAK+B,cAAcxD,GAAIiC,MAAMV,UAC5BE,KAAK4B,qBAAqB9B,EAAO0B,EAAA,GAEzC,E","sources":["src/sketches/embedding_with_localstorage/embedding_with_localstorage.ts"],"sourcesContent":["import {tag} from \"@nartallax/cardboard-dom\"\n\nconst testKey = \"test_value_key\"\n\nexport const main = (root: HTMLElement) => {\n\tconst db = new KVIndexedDbWrapper<string>(\"test_db_name\")\n\n\tconst localStorageInput = tag({\n\t\ttag: \"input\", attrs: {\n\t\t\tplaceholder: \"Local storage value\",\n\t\t\ttype: \"text\",\n\t\t\tvalue: localStorage[testKey] ?? \"\"\n\t\t}\n\t})\n\tconst dbInput = tag({\n\t\ttag: \"input\", attrs: {\n\t\t\tplaceholder: \"indexeddb value\",\n\t\t\ttype: \"text\"\n\t\t}\n\t})\n\n\troot.appendChild(localStorageInput)\n\troot.appendChild(dbInput)\n\n\tvoid(async() => {\n\t\tdbInput.value = await db.get(testKey) ?? \"\"\n\t})()\n\n\tconst onLocalStorageChange = () => {\n\t\tlocalStorage[testKey] = localStorageInput.value\n\t}\n\tconst onIDBChange = () => {\n\t\tvoid db.set(testKey, dbInput.value)\n\t}\n\n\tfor(const [input, onChange] of [[localStorageInput, onLocalStorageChange], [dbInput, onIDBChange]] as const){\n\t\tinput.addEventListener(\"keydown\", onChange)\n\t\tinput.addEventListener(\"change\", onChange)\n\t\tinput.addEventListener(\"paste\", onChange)\n\t}\n}\n\n/** Wrapper around IndexedDB which makes it work as key-value storage\nIndexedDB API is convoluted, and it's nice to reduce it to a few simple operations */\nclass KVIndexedDbWrapper<T> {\n\tconstructor(readonly dbName: string) {}\n\tprivate readonly dbVersion = 1\n\tprivate readonly storeName = \"default_store\"\n\n\tprivate migrate(db: IDBDatabase): Promise<void> {\n\t\tconst store = db.createObjectStore(this.storeName)\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tstore.transaction.onerror = e => reject(e)\n\t\t\tstore.transaction.oncomplete = () => resolve()\n\t\t})\n\t}\n\n\tprivate async getDb(): Promise<IDBDatabase> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst req = window.indexedDB.open(this.dbName, this.dbVersion)\n\t\t\treq.onerror = e => {\n\t\t\t\treject(e)\n\t\t\t}\n\t\t\treq.onsuccess = e => {\n\t\t\t\tresolve((e.target as any).result)\n\t\t\t}\n\t\t\treq.onupgradeneeded = async e => {\n\t\t\t\tconst db = (e.target as any).result as IDBDatabase\n\t\t\t\tawait this.migrate(db)\n\t\t\t\tresolve(db)\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate async inTransaction<R>(db: IDBDatabase, callback: (store: IDBObjectStore, transaction: IDBTransaction) => Promise<R>): Promise<R> {\n\t\tconst transaction = db.transaction([this.storeName], \"readwrite\")\n\t\tconst store = transaction.objectStore(this.storeName)\n\t\tlet result: R | null = null\n\t\tlet hasResult = false\n\t\tlet hasComplete = false\n\t\tlet resolveResult: ((value: R) => void) | null = null\n\n\t\tconst resultPromise = new Promise<R>((resolve, reject) => {\n\t\t\tresolveResult = resolve\n\t\t\ttransaction.oncomplete = () => {\n\t\t\t\thasComplete = true\n\t\t\t\tif(hasResult){\n\t\t\t\t\tresolve(result as R)\n\t\t\t\t}\n\t\t\t}\n\t\t\ttransaction.onerror = e => reject(e)\n\t\t})\n\n\t\tresult = await callback(store, transaction)\n\t\thasResult = true\n\t\tif(hasComplete){\n\t\t\tresolveResult!(result)\n\t\t}\n\n\t\treturn resultPromise\n\t}\n\n\tprivate performPutRequest(store: IDBObjectStore, key: string, value: T): Promise<void> {\n\t\t// put = upsert\n\t\tconst request = store.put(value, key)\n\t\treturn new Promise((resolve, reject) => {\n\t\t\trequest.onerror = e => reject(e)\n\t\t\trequest.onsuccess = () => resolve()\n\t\t})\n\t}\n\n\tprivate performGetRequest(store: IDBObjectStore, key: string): Promise<T> {\n\t\tconst request = store.get(key)\n\t\treturn new Promise((resolve, reject) => {\n\t\t\trequest.onerror = e => reject(e)\n\t\t\trequest.onsuccess = e => resolve((e.target as any).result)\n\t\t})\n\t}\n\n\tprivate performDeleteRequest(store: IDBObjectStore, key: string): Promise<void> {\n\t\tconst request = store.delete(key)\n\t\treturn new Promise((resolve, reject) => {\n\t\t\trequest.onerror = e => reject(e)\n\t\t\trequest.onsuccess = () => resolve\n\t\t})\n\t}\n\n\tasync get(key: string): Promise<T | undefined> {\n\t\tconst db = await this.getDb()\n\t\treturn await this.inTransaction(db, async store => {\n\t\t\treturn await this.performGetRequest(store, key)\n\t\t})\n\t}\n\n\tasync set(key: string, value: T): Promise<void> {\n\t\tconst db = await this.getDb()\n\t\tawait this.inTransaction(db, async store => {\n\t\t\tawait this.performPutRequest(store, key, value)\n\t\t})\n\t}\n\n\tasync delete(key: string): Promise<void> {\n\t\tconst db = await this.getDb()\n\t\tawait this.inTransaction(db, async store => {\n\t\t\tawait this.performDeleteRequest(store, key)\n\t\t})\n\t}\n}"],"names":["$7sHgZ","parcelRequire","$bc9d46958b90a41e$var$testKey","$bc9d46958b90a41e$export$f22da7240b7add18","root","db","$bc9d46958b90a41e$var$KVIndexedDbWrapper","localStorageInput","tag","attrs","placeholder","type","value","localStorage","dbInput","appendChild","get","onLocalStorageChange","onIDBChange","set","input","onChange","addEventListener","constructor","dbName","dbVersion","storeName","migrate","store","createObjectStore","this","Promise","resolve","reject","transaction","onerror","e","oncomplete","async","req","window","indexedDB","open","onsuccess","target","result","onupgradeneeded","callback","objectStore","hasResult","hasComplete","resolveResult","resultPromise","performPutRequest","key","request","put","performGetRequest","performDeleteRequest","delete","getDb","inTransaction"],"version":3,"file":"embedding_with_localstorage.09cf0ed4.js.map"}