{"mappings":"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","sources":["src/sketches/wave_function_collapse/wave_function_collapse.ts","src/common/perfometer.ts","src/common/tag.ts","src/common/classname.ts","src/sketches/wave_function_collapse/color_array_display.ts","src/common/color_utils.ts","src/sketches/wave_function_collapse/pattern_input.ts","src/common/input_utils.ts","src/sketches/wave_function_collapse/wave_function_collapse.module.scss","src/sketches/wave_function_collapse/wave_function_collapse_algo.ts","src/common/bitmap.ts"],"sourcesContent":["import {performeter} from \"common/perfometer\"\nimport {tag} from \"common/tag\"\nimport {ColorArrayDisplay} from \"sketches/wave_function_collapse/color_array_display\"\nimport {PatternInput} from \"sketches/wave_function_collapse/pattern_input\"\nimport {waveFunctionCollapse} from \"sketches/wave_function_collapse/wave_function_collapse_algo\"\nimport * as css from \"./wave_function_collapse.module.scss\"\n\nconst islandsSource = [[0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898], [0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898], [0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898], [0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898], [0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898], [0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 16754689, 16754689, 16754689, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898], [0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 16754689, 16754689, 16754689, 16754689, 16754689, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898], [0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 16754689, 16754689, 16771843, 16771843, 16771843, 16754689, 16754689, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898], [0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 16754689, 16771843, 16771843, 14817887, 16771843, 16771843, 16754689, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898], [0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 16754689, 16754689, 16771843, 16771843, 16771843, 16771843, 16754689, 16754689, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898], [0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 16754689, 16771843, 16771843, 14817887, 16771843, 16754689, 16754689, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898], [0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 16754689, 16754689, 16771843, 16771843, 16754689, 16754689, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898], [0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 16754689, 16754689, 16754689, 16754689, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898], [0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 16754689, 16754689, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898], [0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898], [0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898], [0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898], [0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898], [0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898], [0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898, 0x006898]] as const\n\nexport function main(root: HTMLElement): void {\n\tconst patternInput = new PatternInput({\n\t\tpalette: [0x53bc01, 0xffeb03, 0xffa801, 0xf93a1d, 0xe21a5f, 0x572c62, 0xa1ccd3, 0x006898],\n\t\tdefaultValue: 0x53bc01,\n\t\theight: 20,\n\t\twidth: 20,\n\t\tscale: 10\n\t})\n\n\tconst display = new ColorArrayDisplay(10)\n\n\troot.appendChild(tag({\n\t\tclass: css[\"wave-function-collapse-root\"]\n\t}, [\n\t\ttag([\n\t\t\tpatternInput.root,\n\t\t\ttag({tagName: \"button\", text: \"Collapse!\", on: {click: run}})\n\t\t]),\n\t\tdisplay.root\n\t]))\n\n\tfor(let x = 0; x < islandsSource.length; x++){\n\t\tconst row = islandsSource[x]!\n\t\tfor(let y = 0; y < row.length; y++){\n\t\t\tpatternInput.set(x, y, row[y]!)\n\t\t}\n\t}\n\n\tfunction run(): void {\n\t\tconst source = patternInput.getPattern()\n\t\tconst result = waveFunctionCollapse({\n\t\t\tflip: true,\n\t\t\trotate: true,\n\t\t\tsourceSample: source,\n\t\t\tpatternSize: 3,\n\t\t\trandomSeed: 12345,\n\t\t\tresultSize: {width: 50, height: 50}\n\t\t})\n\t\tdisplay.draw(result)\n\t\tperformeter.print()\n\t\tperformeter.reset()\n\t}\n}","interface Block {\n\tparent: Block | null\n\tsubblocks: Record<string, Block>\n\ttimeStart: number\n\ttimeSum: number\n\tenterCount: number\n}\n\ninterface BlockToPrint {\n\t\"ms per enter\": number\n\t\"full %\": number\n\t\"parent %\": number\n}\n\nclass Perfometer {\n\n\tprivate root: Block = this.makeBlock(null)\n\tprivate currentBlock: Block = this.root\n\n\tprivate makeBlock(parent: Block | null): Block {\n\t\treturn {\n\t\t\tsubblocks: {}, parent: parent,\n\t\t\ttimeStart: -1, timeSum: 0,\n\t\t\tenterCount: 0\n\t\t}\n\t}\n\n\tenterBlock(name: string): void {\n\t\tlet nextBlock = this.currentBlock.subblocks[name]\n\t\tif(!nextBlock){\n\t\t\tnextBlock = this.makeBlock(this.currentBlock)\n\t\t\tthis.currentBlock.subblocks[name] = nextBlock\n\t\t}\n\t\tnextBlock.timeStart = performance.now()\n\t\tnextBlock.enterCount++\n\t\tthis.currentBlock = nextBlock\n\t}\n\n\texitBlock(): void {\n\t\tthis.currentBlock.timeSum += performance.now() - this.currentBlock.timeStart\n\t\tconst parent = this.currentBlock.parent\n\t\tif(!parent){\n\t\t\tthrow new Error(\"No parent! Blocks are all messed up.\")\n\t\t}\n\t\tthis.currentBlock = parent\n\t}\n\n\texitEnterBlock(name: string): void {\n\t\tthis.exitBlock()\n\t\tthis.enterBlock(name)\n\t}\n\n\tprint(): void {\n\t\tconst table: Record<string, BlockToPrint> = {}\n\t\tlet fullTime = 0\n\t\tfor(const name in this.root.subblocks){\n\t\t\tfullTime += this.root.subblocks[name]!.timeSum\n\t\t}\n\n\t\tthis.forEachBlock((block, name, depth) => {\n\t\t\tname = new Array(depth + 1).join(\"-\") + name\n\t\t\ttable[name] = {\n\t\t\t\t\"parent %\": strip((block.timeSum / block.parent!.timeSum) * 100),\n\t\t\t\t\"full %\": strip((block.timeSum / fullTime) * 100),\n\t\t\t\t\"ms per enter\": strip(block.timeSum / block.enterCount)\n\t\t\t}\n\t\t})\n\n\t\tconsole.table(table)\n\t}\n\n\treset(): void {\n\t\tthis.root = this.makeBlock(null)\n\t\tthis.currentBlock = this.root\n\t}\n\n\tprivate forEachBlock(callback: (block: Block, name: string, depth: number) => void, start: Block = this.root, currentDepth = 0): void {\n\t\tfor(const name in start.subblocks){\n\t\t\tconst subblock = start.subblocks[name]!\n\t\t\tcallback(subblock, name, currentDepth)\n\t\t\tthis.forEachBlock(callback, subblock, currentDepth + 1)\n\t\t}\n\t}\n\n}\n\nexport const performeter = new Perfometer()\n\nfunction strip(v: number): number {\n\treturn Math.round(v * 100) / 100\n}","import {Binder, getBinder} from \"common/binder/binder\"\nimport {isRBox, MaybeRBoxed, RBox, unbox, WBox} from \"common/box\"\nimport {ClassNameParts, makeClassname} from \"common/classname\"\nimport {FieldsOfObjectWithType, WritableKeysOf} from \"common/type_utils\"\n\ntype CssStyleAssignableKeys = WritableKeysOf<CSSStyleDeclaration> & FieldsOfObjectWithType<CSSStyleDeclaration, string>\n\ninterface TagDescription<K extends string = string, ThisType = unknown> {\n\treadonly tagName?: K\n\treadonly text?: MaybeRBoxed<string | number>\n\treadonly attrs?: {\n\t\treadonly [attrName: string]: MaybeRBoxed<string | number | undefined | null>\n\t}\n\treadonly on?: {\n\t\treadonly [k in keyof GlobalEventHandlersEventMap]?: (this: ThisType, evt: GlobalEventHandlersEventMap[k]) => void\n\t}\n\treadonly class?: ClassNameParts\n}\n\nexport interface HTMLTagDescription<K extends keyof HTMLElementTagNameMap = keyof HTMLElementTagNameMap> extends TagDescription<K, HTMLElementTagNameMap[K]> {\n\n\treadonly style?: {\n\t\treadonly [k in CssStyleAssignableKeys]?: MaybeRBoxed<string | number>\n\t}\n}\n\nexport type SVGTagDescription<K extends keyof SVGElementTagNameMap = keyof SVGElementTagNameMap> = TagDescription<K, SVGElementTagNameMap[K]>\n\ntype ChildArray = (Element | null | undefined)[] | RBox<(Element | null | undefined)[]>\n\n// typings are weird here, had to cast\nfunction resolveArgs<K>(a?: K | ChildArray, b?: ChildArray): [K, ChildArray | undefined] {\n\tif(!a){\n\t\treturn [{} as K, b]\n\t} else if(Array.isArray(a) || isRBox(a)){\n\t\treturn [{} as K, a as ChildArray]\n\t} else {\n\t\treturn [a as K, b]\n\t}\n}\n\nfunction populateTag<K extends string, T>(tagBase: Element, description: TagDescription<K, T>, children?: ChildArray): Binder | null {\n\tlet binder: Binder | null = null\n\n\tif(description.text){\n\t\tconst text = description.text\n\t\tif(isRBox(text)){\n\t\t\t(binder ||= getBinder(tagBase)).watch<string | number>(text, text => {\n\t\t\t\ttagBase.textContent = text + \"\"\n\t\t\t})\n\t\t}\n\t\ttagBase.textContent = unbox(text) + \"\"\n\t}\n\n\tif(description.on){\n\t\tfor(const evtName in description.on){\n\t\t\tconst handler = description.on[evtName as keyof GlobalEventHandlersEventMap]\n\t\t\t// I don't want to construct elaborat solid type here\n\t\t\t// I know the type will be correct, because it is enforced by function parameter type\n\t\t\t// so just be Any and that's it\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\ttagBase.addEventListener(evtName, handler as any, {passive: true, capture: false})\n\t\t}\n\t}\n\n\tfor(const k in description.attrs){\n\t\tconst v = description.attrs[k]\n\t\tif(isRBox(v)){\n\t\t\t(binder ||= getBinder(tagBase)).watch<string | number | null | undefined>(v, v => {\n\t\t\t\tif(v === null || v === undefined){\n\t\t\t\t\ttagBase.removeAttribute(k)\n\t\t\t\t} else {\n\t\t\t\t\ttagBase.setAttribute(k, v + \"\")\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\tconst vv = unbox(v)\n\t\tif(v !== null && v !== undefined){\n\t\t\ttagBase.setAttribute(k, vv + \"\")\n\t\t}\n\t}\n\n\tif(children){\n\t\tconst setChildren = (children: (Element | null | undefined)[]) => {\n\t\t\tconst childTags = children.filter(x => !!x) as Element[]\n\t\t\tupdateChildren(tagBase, childTags)\n\t\t}\n\n\t\tif(isRBox(children)){\n\t\t\t(binder ||= getBinder(tagBase)).watch(children, children => {\n\t\t\t\tsetChildren(children)\n\t\t\t})\n\t\t}\n\t\tsetChildren(unbox(children))\n\t}\n\n\tif(description.class){\n\t\tbinder = makeClassname(\n\t\t\tbinder,\n\t\t\ttagBase,\n\t\t\tdescription.class,\n\t\t\t// using classList here because on svg elements .className is readonly (in runtime)\n\t\t\tclassname => tagBase.classList.value = classname\n\t\t) || binder\n\t}\n\n\treturn binder\n}\n\nexport function tag(): HTMLDivElement\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(description: HTMLTagDescription<K>): HTMLElementTagNameMap[K]\nexport function tag(children: ChildArray): HTMLDivElement\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(description: HTMLTagDescription<K>, children: ChildArray): HTMLElementTagNameMap[K]\n\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(a?: HTMLTagDescription<K> | ChildArray, b?: ChildArray): HTMLElementTagNameMap[K] {\n\tconst [description, children] = resolveArgs(a, b)\n\n\tconst tagBase = document.createElement(description.tagName || \"div\")\n\n\tlet binder = populateTag(tagBase, description, children)\n\n\tif(description.style){\n\t\tfor(const k in description.style){\n\t\t\tconst v = description.style[k as CssStyleAssignableKeys]\n\t\t\tif(isRBox(v)){\n\t\t\t\t(binder ||= getBinder(tagBase)).watch<string | number>(v, v => {\n\t\t\t\t\ttagBase.style[k] = v + \"\"\n\t\t\t\t})\n\t\t\t}\n\t\t\ttagBase.style[k] = unbox(description.style[k]!) + \"\"\n\t\t}\n\t}\n\n\treturn tagBase as HTMLElementTagNameMap[K]\n}\n\nexport function svgTag(): SVGGElement\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(description: SVGTagDescription<K>): SVGElementTagNameMap[K]\nexport function svgTag(children: ChildArray): SVGGElement\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(description: SVGTagDescription<K>, children: ChildArray): SVGElementTagNameMap[K]\n\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(a?: SVGTagDescription<K> | ChildArray, b?: ChildArray): SVGElementTagNameMap[K] {\n\tconst [description, children] = resolveArgs(a, b)\n\n\tconst tagBase = document.createElementNS(\"http://www.w3.org/2000/svg\", description.tagName || \"g\")\n\n\tif(description.tagName === \"svg\"){\n\t\ttagBase.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\")\n\t}\n\n\tpopulateTag(tagBase, description, children)\n\n\treturn tagBase as SVGElementTagNameMap[K]\n}\n\nfunction updateChildren(parent: Element, newChildren: readonly Element[]): void {\n\tfor(let i = 0; i < newChildren.length; i++){\n\t\tconst childTag = newChildren[i]!\n\t\tconst x = parent.childNodes[i]\n\t\tif(x === childTag){\n\t\t\tcontinue\n\t\t}\n\t\tif(x){\n\t\t\tparent.insertBefore(childTag, x)\n\t\t} else {\n\t\t\tparent.appendChild(childTag)\n\t\t}\n\t}\n\n\twhile(parent.childNodes[newChildren.length]){\n\t\tparent.childNodes[newChildren.length]!.remove()\n\t}\n}\n\n/** Cached renderer for list of elements\n * Won't re-render an element if already has one for the value */\nexport function renderArray<T, K, E extends Element>(src: WBox<T[]>, getKey: (value: T) => K, render: (value: WBox<T>) => E): RBox<E[]>\nexport function renderArray<T, K, E extends Element>(src: RBox<T[]>, getKey: (value: T) => K, render: (value: RBox<T>) => E): RBox<E[]>\nexport function renderArray<T, K, E extends Element>(src: MaybeRBoxed<readonly T[]>, getKey: (value: T) => K, render: (value: MaybeRBoxed<T>) => E): E[]\nexport function renderArray<T, K, E extends Element>(src: MaybeRBoxed<readonly T[]> | WBox<T[]>, getKey: (value: T) => K, render: (value: WBox<T> | T) => E): Node[] | RBox<Node[]> {\n\tif(Array.isArray(src)){\n\t\treturn src.map(el => render(el))\n\t}\n\n\tconst map = new Map<WBox<T>, E>()\n\n\treturn (src as WBox<T[]>).wrapElements(getKey).map(itemBoxes => {\n\t\tconst leftoverBoxes = new Set(map.keys())\n\n\t\tconst result = itemBoxes.map(itemBox => {\n\t\t\tleftoverBoxes.delete(itemBox)\n\t\t\tlet el = map.get(itemBox)\n\t\t\tif(!el){\n\t\t\t\tel = render(itemBox)\n\t\t\t\tmap.set(itemBox, el)\n\t\t\t}\n\t\t\treturn el\n\t\t})\n\n\t\tfor(const oldBox of leftoverBoxes){\n\t\t\tmap.delete(oldBox)\n\t\t}\n\n\t\treturn result\n\t})\n}","import {Binder, getBinder} from \"common/binder/binder\"\nimport {isRBox, MaybeRBoxed, unbox} from \"common/box\"\n\ntype ClassNamePart = MaybeRBoxed<string | null | undefined> | Record<string, MaybeRBoxed<boolean | undefined>>\nexport type ClassNameParts = ClassNamePart | ClassNamePart[]\n\n/** Utility function that assembles classname from parts */\nexport function makeClassname(binder: Binder | null, node: Node, parts: ClassNameParts, callback: (className: string) => void): Binder | null {\n\tconst arr = Array.isArray(parts) ? parts : [parts]\n\tfor(const item of arr){\n\t\tif(isRBox(item)){\n\t\t\t(binder ||= getBinder(node)).watch(item, makeClassnameAndCallTheCallback)\n\t\t} else if(item && typeof(item) === \"object\"){\n\t\t\tfor(const key in item){\n\t\t\t\tconst bool = item[key]\n\t\t\t\tif(isRBox(bool)){\n\t\t\t\t\t(binder ||= getBinder(node)).watch(bool, makeClassnameAndCallTheCallback)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction makeClassnameAndCallTheCallback() {\n\t\tconst result = []\n\t\tfor(const item of arr){\n\t\t\tif(item && typeof(item) === \"object\"){\n\t\t\t\tfor(const classname in item){\n\t\t\t\t\tif(unbox(item[classname])){\n\t\t\t\t\t\tresult.push(classname)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst classname = unbox(item)\n\t\t\t\tif(classname){\n\t\t\t\t\tresult.push(classname)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcallback(result.join(\" \"))\n\t}\n\n\tmakeClassnameAndCallTheCallback()\n\n\treturn binder\n}","import {rgbNumberToColorString} from \"common/color_utils\"\nimport {tag} from \"common/tag\"\n\nexport class ColorArrayDisplay {\n\n\treadonly root: HTMLElement\n\tprivate readonly context: CanvasRenderingContext2D\n\n\tconstructor(readonly scale: number) {\n\t\tconst canvas = tag({tagName: \"canvas\"})\n\t\tthis.root = canvas\n\n\t\tconst context = canvas.getContext(\"2d\")\n\t\tif(!context){\n\t\t\tthrow new Error(\"No context\")\n\t\t}\n\t\tthis.context = context\n\t}\n\n\tdraw(values: readonly (readonly number[])[]): void {\n\t\tconst w = values.length * this.scale\n\t\tconst h = values[0]!.length * this.scale\n\t\tthis.root.setAttribute(\"width\", w + \"\")\n\t\tthis.root.setAttribute(\"height\", h + \"\")\n\t\tthis.root.style.width = w + \"px\"\n\t\tthis.root.style.height = h + \"px\"\n\n\t\tconst s = this.scale\n\t\tfor(let x = 0; x < values.length; x++){\n\t\t\tconst row = values[x]!\n\t\t\tfor(let y = 0; y < row.length; y++){\n\t\t\t\tthis.context.fillStyle = rgbNumberToColorString(row[y]!)\n\t\t\t\tthis.context.fillRect(x * s, y * s, s, s)\n\t\t\t}\n\t\t}\n\t}\n\n}","function twoHex(x: number): string {\n\treturn (x > 0xf ? \"\" : \"0\") + x.toString(16)\n}\n\nexport function rgbNumberToColorString(rgb: number): string {\n\tconst b = rgb & 0xff\n\trgb >>= 8\n\tconst g = rgb & 0xff\n\trgb >>= 8\n\tconst r = rgb & 0xff\n\n\treturn \"#\" + twoHex(r) + twoHex(g) + twoHex(b)\n}","import {rgbNumberToColorString} from \"common/color_utils\"\nimport {addCursorMoveHandler, pointerEventsToOffsetCoords, preventContextMenu} from \"common/input_utils\"\nimport {tag} from \"common/tag\"\nimport {ColorArrayDisplay} from \"sketches/wave_function_collapse/color_array_display\"\nimport * as css from \"./wave_function_collapse.module.scss\"\n\ntype PatternInputParams<T extends number = number> = {\n\treadonly palette: readonly T[]\n\treadonly defaultValue: T\n\treadonly width: number\n\treadonly height: number\n\treadonly scale: number\n}\n\ntype ColorButton<T extends number = number> = {\n\tbutton: HTMLElement\n\tcolor: T\n\tclassName: string\n}\n\nexport class PatternInput<T extends number = number> {\n\treadonly root: HTMLElement\n\n\tprivate readonly display: ColorArrayDisplay\n\tprivate readonly pattern: readonly (T[])[]\n\tprivate primaryCb: ColorButton<T> | null = null\n\t// I had logic around having secondary color on right mouse button\n\t// but turns out mouseevent.buttons can be weird\n\t// so, whatever, I'm not solving this now\n\t// private secondaryCb: ColorButton<T> | null = null\n\n\tconstructor(private readonly params: PatternInputParams<T>) {\n\t\tthis.display = new ColorArrayDisplay(params.scale)\n\n\t\tpreventContextMenu(this.display.root)\n\t\taddCursorMoveHandler({\n\t\t\telement: this.display.root,\n\t\t\tonMove: this.onSetColorAction.bind(this),\n\t\t\tdownIsMove: true\n\t\t})\n\n\t\tthis.pattern = new Array(params.width).fill(null).map(() =>\n\t\t\tnew Array(params.height).fill(params.defaultValue)\n\t\t)\n\n\t\tconst paletteButtons = params.palette.map(color => {\n\t\t\tconst button: HTMLElement = tag({\n\t\t\t\tclass: css[\"pattern-input-palette-item\"],\n\t\t\t\ton: {\n\t\t\t\t\tclick: () => {\n\t\t\t\t\t\tthis.primaryCb = this.selectColor(this.primaryCb, button, color)\n\t\t\t\t\t}\n\t\t\t\t\t// contextmenu: () => {\n\t\t\t\t\t// \tthis.secondaryCb = this.selectColor(this.secondaryCb, button, color)\n\t\t\t\t\t// }\n\t\t\t\t},\n\t\t\t\tstyle: {\n\t\t\t\t\tbackgroundColor: rgbNumberToColorString(color)\n\t\t\t\t}\n\t\t\t})\n\t\t\tpreventContextMenu(button)\n\t\t\tif(color === this.params.defaultValue){\n\t\t\t\tthis.primaryCb = this.selectColor(null, button, color, css[\"selected-primary\"]!)\n\t\t\t\t// this.secondaryCb = this.selectColor(null, button, color, css[\"selected-secondary\"]!)\n\t\t\t}\n\t\t\treturn button\n\t\t})\n\n\t\tthis.root = tag({\n\t\t\tclass: css[\"pattern-input-wrap\"]\n\t\t}, [\n\t\t\tthis.display.root,\n\t\t\ttag({\n\t\t\t\tclass: css[\"pattern-input-palette-wrap\"]\n\t\t\t}, paletteButtons)\n\t\t])\n\n\t\tthis.redrawCanvas()\n\t}\n\n\tprivate redrawCanvas(): void {\n\t\tthis.display.draw(this.pattern)\n\t}\n\n\tprivate onSetColorAction(e: MouseEvent | TouchEvent): void {\n\t\tconst coords = pointerEventsToOffsetCoords(e)\n\t\tif(!coords){\n\t\t\treturn\n\t\t}\n\t\t// let isPrimary: boolean\n\t\t// if(isTouchEvent(e)){\n\t\t// \tisPrimary = true\n\t\t// } else {\n\t\t// \tisPrimary = e.buttons !== 2\n\t\t// }\n\t\tconst cellX = Math.floor(coords.x / this.params.scale)\n\t\tconst cellY = Math.floor(coords.y / this.params.scale)\n\t\tconst row = this.pattern[cellX]\n\t\tif(row && row.length > cellY){\n\t\t\t// const cb = isPrimary ? this.primaryCb : this.secondaryCb\n\t\t\tconst cb = this.primaryCb\n\t\t\tif(cb){\n\t\t\t\tthis.set(cellX, cellY, cb.color)\n\t\t\t}\n\t\t}\n\t}\n\n\tset(x: number, y: number, color: T): void {\n\t\tthis.pattern[x]![y] = color\n\t\tthis.redrawCanvas()\n\t}\n\n\tprivate selectColor(prevCb: ColorButton<T> | null, button: HTMLElement, color: T, dfltClassName = \"selected\"): ColorButton<T> {\n\t\tconst clsName = prevCb?.className ?? dfltClassName\n\t\tif(prevCb){\n\t\t\tprevCb.button.classList.remove(clsName)\n\t\t}\n\t\tconst cb: ColorButton<T> = {\n\t\t\tbutton,\n\t\t\tcolor,\n\t\t\tclassName: clsName\n\t\t}\n\t\tbutton.classList.add(clsName)\n\t\treturn cb\n\t}\n\n\tgetPattern(): number[][] {\n\t\treturn JSON.parse(JSON.stringify(this.pattern))\n\t}\n}","export function pointerEventsToClientCoords(e: MouseEvent | TouchEvent): {x: number, y: number} {\n\tif(isTouchEvent(e)){\n\t\tconst touch = e.touches[0]!\n\t\treturn {\n\t\t\tx: touch.clientX,\n\t\t\ty: touch.clientY\n\t\t}\n\t} else {\n\t\treturn {\n\t\t\tx: e.clientX,\n\t\t\ty: e.clientY\n\t\t}\n\t}\n}\n\nexport function pointerEventsToOffsetCoords(e: MouseEvent | TouchEvent): {x: number, y: number} | null {\n\tif(!(e.target instanceof HTMLElement)){\n\t\treturn null\n\t}\n\n\tconst rect = e.target.getBoundingClientRect() // performance may suck, but whatever\n\tconst coords = pointerEventsToClientCoords(e)\n\tcoords.x -= rect.left\n\tcoords.y -= rect.top\n\treturn coords\n}\n\nexport function isTouchEvent(e: MouseEvent | TouchEvent): e is TouchEvent {\n\treturn !!(e as TouchEvent).touches\n}\n\ntype CursorMoveHandlerParams = {\n\treadonly element: HTMLElement\n\tonMove(e: MouseEvent | TouchEvent): void\n\t/** If true, onMove will be invoked when down event happen */\n\treadonly downIsMove?: boolean\n\t/** If true, onMove will be invoked when up event happen */\n\treadonly upIsMove?: boolean\n}\n\n/** This is a good way to add a mousemove handler to an element */\nexport function addCursorMoveHandler(params: CursorMoveHandlerParams): void {\n\n\tconst onDown = (e: MouseEvent | TouchEvent) => {\n\t\tparams.element.addEventListener(\"mousemove\", params.onMove, {passive: true})\n\t\tparams.element.addEventListener(\"touchmove\", params.onMove, {passive: true})\n\t\twindow.addEventListener(\"mouseup\", onUp, {passive: true})\n\t\twindow.addEventListener(\"touchend\", onUp, {passive: true})\n\t\tif(params.downIsMove){\n\t\t\tparams.onMove(e)\n\t\t}\n\t}\n\n\tconst onUp = (e: MouseEvent | TouchEvent) => {\n\t\tparams.element.removeEventListener(\"mousemove\", params.onMove)\n\t\tparams.element.removeEventListener(\"touchmove\", params.onMove)\n\t\twindow.removeEventListener(\"mouseup\", onUp)\n\t\twindow.removeEventListener(\"touchend\", onUp)\n\t\tif(params.upIsMove){\n\t\t\tparams.onMove(e)\n\t\t}\n\t}\n\n\tparams.element.addEventListener(\"mousedown\", onDown, {passive: true})\n\tparams.element.addEventListener(\"touchstart\", onDown, {passive: true})\n}\n\nexport function preventContextMenu(el: HTMLElement): void {\n\tel.addEventListener(\"contextmenu\", e => {\n\t\te.preventDefault()\n\t\te.stopPropagation()\n\t\treturn false\n\t})\n}",".wave-function-collapse-root {\n\tdisplay: flex;\n\twidth: 100%;\n\theight: 100%;\n\tflex-direction: row;\n\talign-items: center;\n\n\t.pattern-input-wrap {\n\t\tpadding: 1rem;\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\tflex-grow: 0;\n\t\tflex-shrink: 0;\n\t\tmargin-right: 1rem;\n\t}\n\n\t.pattern-input-palette-item {\n\t\twidth: 1.5rem;\n\t\theight: 1.5rem;\n\t\tcursor: pointer;\n\t\tborder: 2px solid #222;\n\t\tborder-radius: 3px;\n\n\t\t&.selected-secondary {\n\t\t\tborder: 3px solid #999;\n\t\t}\n\n\t\t&.selected-primary {\n\t\t\tborder: 3px solid #ccc;\n\t\t}\n\t}\n\n\t.pattern-input-palette-wrap {\n\t\tpadding-top: 1rem;\n\t\tdisplay: flex;\n\t\tflex-direction: row;\n\t\twidth: 100%;\n\t\tjustify-content: center;\n\t\tflex-wrap: wrap;\n\t}\n\n}","import {Bitmap} from \"common/bitmap\"\nimport {performeter} from \"common/perfometer\"\n\ntype WaveFunctionCollapseInput<T = unknown> = {\n\t/** The source sample, from which patterns will be extracted\n\t * indexing: sourceSample[x][y]\n\t * You MUST use same referencially-equal values to represent same logical values\n\t * (that is, if you have two of the same cat in the source - they must both be represented by single instance)\n\t * (this can only matter if you use objects or something like that as T)\n\t * (otherwise it will screw up the pattern extraction) */\n\tsourceSample: T[][]\n\tpatternSize: number\n\tresultSize: {height: number, width: number}\n\tflip: boolean\n\trotate: boolean\n\trandomSeed: number\n}\n\nexport function waveFunctionCollapse<T>(params: WaveFunctionCollapseInput<T>): T[][] {\n\tperformeter.enterBlock(\"init stage\")\n\tconst {patterns, matrix} = init(params)\n\tperformeter.exitEnterBlock(\"collapse stage\")\n\n\twhile(!matrix.isEverythingCollapsed()){\n\t\tconst lowestEntropyPoint = matrix.findMinEntropyCell()\n\t\tif(!lowestEntropyPoint){\n\t\t\tthrow new Error(\"No lowest entropy point!\")\n\t\t}\n\t\tmatrix.collapse(lowestEntropyPoint)\n\t}\n\n\tconst patternIndices = matrix.getResults()\n\n\tperformeter.exitBlock()\n\n\treturn patternIndices.map(row => row.map(patternIndex => {\n\t\tconst pattern = patterns[patternIndex]!\n\t\treturn pattern[0]![0]!\n\t}))\n}\n\ntype XY = {x: number, y: number}\ntype PatternData<T = unknown> = readonly (readonly T[])[]\n// Array(pattern index -> Map(encoded offset -> list of available pattern indices for that offset))\ntype Rules = Map<number, number[]>[]\ntype InitResult<T> = {\n\tmatrix: Matrix\n\toffsets: XY[]\n\tpatterns: PatternData<T>[]\n\tpatternsFreq: number[]\n\trules: Rules\n\trandom(): number\n}\n\n/** Performs the initialization phase of the wfc algorithm, namely - aggregate the patterns from the input_examples image, calculate their frequencies and initiate the coefficient_matrix */\nfunction init<T>(params: WaveFunctionCollapseInput<T>): InitResult<T> {\n\tconst offsets = generateOffsets(params.patternSize)\n\tconst [patterns, patternsFreq] = generatePatternsAndFrequences(params)\n\tconst rules = getRules(patterns, offsets)\n\tconst random = makeRandom(params.randomSeed)\n\tconst matrix = new Matrix(params.resultSize.width, params.resultSize.height, patterns.length, random, rules, offsets, patternsFreq)\n\t// console.log(\"Rules: \", rules)\n\treturn {offsets, patterns, patternsFreq, rules, matrix, random}\n}\n\nfunction getRules<T>(patterns: PatternData<T>[], offsets: XY[]): Rules {\n\tconst result: Rules = new Array(patterns.length).fill(null).map(() => {\n\t\tconst patternsByOffset = new Map<number, number[]>(offsets.map(offset => [encodeOffset(offset), []]))\n\t\treturn patternsByOffset\n\t})\n\t// console.log(\"Patterns\", patterns)\n\n\tfor(const offset of offsets){\n\t\tconst encodedOffset = encodeOffset(offset)\n\t\t// console.log(`Encoded offset (${offset.x}, ${offset.y}) as ${encodedOffset}`)\n\t\tconst flipEncodedOffset = encodeOffset(flipOffset(offset))\n\t\tfor(let aIndex = 0; aIndex < patterns.length; aIndex++){\n\t\t\tconst a = patterns[aIndex]!\n\t\t\tfor(let bIndex = aIndex; bIndex < patterns.length; bIndex++){\n\t\t\t\tconst b = patterns[bIndex]!\n\t\t\t\tif(patternsHaveMatch(a, b, offset)){\n\t\t\t\t\tresult[aIndex]!.get(encodedOffset)!.push(bIndex)\n\t\t\t\t\tresult[bIndex]!.get(flipEncodedOffset)!.push(aIndex)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunction patternsHaveMatch<T>(a: PatternData<T>, b: PatternData<T>, offset: XY): boolean {\n\tconst patternSize = a.length\n\tconst intersectionLengthX = patternSize - Math.abs(offset.x)\n\tconst intersectionLengthY = patternSize - Math.abs(offset.y)\n\n\tconst startXA = Math.min(Math.max(offset.x, 0), patternSize - intersectionLengthX)\n\tconst startYA = Math.min(Math.max(offset.y, 0), patternSize - intersectionLengthY)\n\tconst startXB = Math.min(Math.max(-offset.x, 0), patternSize - intersectionLengthX)\n\tconst startYB = Math.min(Math.max(-offset.y, 0), patternSize - intersectionLengthY)\n\n\tfor(let dx = 0; dx < intersectionLengthX; dx++){\n\t\tfor(let dy = 0; dy < intersectionLengthY; dy++){\n\t\t\tif(a[startXA + dx]![startYA + dy] !== b[startXB + dx]![startYB + dy]){\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\nfunction flipOffset(offset: XY): XY {\n\treturn {x: -offset.x, y: -offset.y}\n}\n\n/** Get the coordinates around a pattern.\n * This function returns a list of all coordinates around a pattern of given size, starting from the top left and ending at the bottom right. The center point (0, 0) is excluded from the list. */\nfunction generateOffsets(patternSize: number): XY[] {\n\tconst result: XY[] = []\n\tfor(let x = -patternSize + 1; x < patternSize; x++){\n\t\tfor(let y = -patternSize + 1; y < patternSize; y++){\n\t\t\tif(x === 0 && y === 0){\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tresult.push({x, y})\n\t\t}\n\t}\n\treturn result\n}\n\nfunction encodeOffset(offset: XY): number {\n\treturn Math.abs(offset.x) << 18 | Math.abs(offset.y) << 2 | (offset.y < 0 ? 0x1 : 0) | (offset.x < 0 ? 0x2 : 0)\n}\n\nfunction encodePosition(position: XY): number {\n\treturn position.x << 16 | position.y\n}\n\nfunction decodePosition(position: number): XY {\n\treturn {\n\t\tx: (position >> 16) & 0xffff,\n\t\ty: position & 0xffff\n\t}\n}\n\nfunction normalizeArray(input: number[]): number[] {\n\tconst sum = input.reduce((a, b) => a + b, 0)\n\treturn input.map(x => x / sum)\n}\n\nfunction generatePatternsAndFrequences<T>(params: WaveFunctionCollapseInput<T>): [PatternData<T>[], number[]] {\n\tlet patterns = getPatternDataFromSource(params)\n\n\tconst hashMap = new Map<number, (PatternData<T> | null)[]>()\n\tconst hasher = new PatternHasher(params.sourceSample)\n\tfor(const pattern of patterns){\n\t\tconst hash = hasher.hash(pattern)\n\t\tlet arr = hashMap.get(hash)\n\t\tif(!arr){\n\t\t\tarr = []\n\t\t\thashMap.set(hash, arr)\n\t\t}\n\t\tarr.push(pattern)\n\t}\n\n\tconst freqMap = new Map<PatternData<T>, number>()\n\tfor(const patterns of hashMap.values()){\n\t\tfor(let i = 0; i < patterns.length; i++){\n\t\t\tconst pattern = patterns[i]\n\t\t\tif(!pattern){\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlet count = 0\n\t\t\tfor(let j = 0; j < patterns.length; j++){\n\t\t\t\tconst otherPattern = patterns[j]\n\t\t\t\tif(!otherPattern){\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif(patternsAreEqual(pattern, otherPattern)){\n\t\t\t\t\tpatterns[j] = null\n\t\t\t\t}\n\t\t\t\tcount++\n\t\t\t}\n\t\t\tfreqMap.set(pattern, count)\n\t\t}\n\t}\n\tpatterns = [...freqMap.keys()]\n\n\tconst freqs: number[] = []\n\tfor(const pattern of patterns){\n\t\tfreqs.push(freqMap.get(pattern)!)\n\t}\n\treturn [patterns, normalizeArray(freqs)]\n}\n\nfunction patternsAreEqual<T>(a: PatternData<T>, b: PatternData<T>): boolean {\n\tfor(let x = 0; x < a.length; x++){\n\t\tconst aRow = a[x]!\n\t\tconst bRow = b[x]!\n\t\tfor(let y = 0; y < aRow.length; y++){\n\t\t\tif(aRow[y] !== bRow[y]){\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\n/** Class that is able to take fast (non-secure) hash from a pattern */\nclass PatternHasher<T> {\n\n\tprivate readonly valueIndices: Map<T, number> = new Map()\n\n\tconstructor(source: WaveFunctionCollapseInput<T>[\"sourceSample\"]) {\n\t\tconst allPossibleValues = [...new Set(flatten(source))]\n\t\tfor(let i = 0; i < allPossibleValues.length; i++){\n\t\t\tthis.valueIndices.set(allPossibleValues[i]!, i)\n\t\t}\n\t}\n\n\thash(pattern: PatternData<T>): number {\n\t\tlet hash = 0\n\n\t\tfor(let x = 0; x < pattern.length; x++){\n\t\t\tconst row = pattern[x]!\n\t\t\tfor(let y = 0; y < row.length; y++){\n\t\t\t\tconst item = row[y]!\n\t\t\t\tconst itemIndex = this.valueIndices.get(item)!\n\t\t\t\thash = ((hash << 5) - hash + (itemIndex * x * y)) | 0\n\t\t\t}\n\t\t}\n\n\t\treturn hash\n\t}\n}\n\nfunction flatten<T>(arr: readonly (readonly T[])[]): T[] {\n\tconst result: T[] = []\n\tfor(const row of arr){\n\t\tresult.push(...row)\n\t}\n\treturn result\n}\n\nfunction getPatternDataFromSource<T>(params: WaveFunctionCollapseInput<T>): PatternData<T>[] {\n\tlet patterns: PatternData<T>[] = []\n\tfor(let x = 0; x < params.sourceSample.length - params.patternSize + 1; x++){\n\t\tconst row = params.sourceSample[x]!\n\t\tfor(let y = 0; y < row.length - params.patternSize + 1; y++){\n\t\t\tpatterns.push(extractSourcePatternAt(params.sourceSample, x, y, params.patternSize))\n\t\t}\n\t}\n\n\tif(params.flip){\n\t\tconst flipped: PatternData<T>[] = []\n\t\tfor(const axis of [\"x\", \"y\"] as const){\n\t\t\tfor(const pattern of patterns){\n\t\t\t\tflipped.push(flipPattern(pattern, axis))\n\t\t\t}\n\t\t}\n\t\tpatterns = [...patterns, ...flipped]\n\t}\n\n\tif(params.rotate){\n\t\tconst rotated: PatternData<T>[] = []\n\t\tfor(const count of [1, 2, 3] as const){\n\t\t\tfor(const pattern of patterns){\n\t\t\t\trotated.push(rotatePattern(pattern, count))\n\t\t\t}\n\t\t}\n\t\tpatterns = [...patterns, ...rotated]\n\t}\n\n\treturn patterns\n}\n\nfunction extractSourcePatternAt<T>(source: WaveFunctionCollapseInput<T>[\"sourceSample\"], x: number, y: number, size: number): PatternData<T> {\n\tconst result: T[][] = []\n\tfor(let dx = 0; dx < size; dx++){\n\t\tconst row = source[x + dx]!\n\t\tresult.push(row.slice(y, y + size))\n\t}\n\treturn result\n}\n\nfunction copyPattern<T>(pattern: PatternData<T>): T[][] {\n\tconst result: T[][] = []\n\tfor(let x = 0; x < pattern.length; x++){\n\t\tresult.push([...pattern[x]!])\n\t}\n\treturn result\n}\n\nfunction flipPattern<T>(pattern: PatternData<T>, axis: \"x\" | \"y\"): PatternData<T> {\n\tconst res = copyPattern(pattern)\n\tconst halfLen = Math.floor(pattern.length / 2)\n\tif(axis === \"x\"){\n\t\tfor(let dx = 0; dx < halfLen; dx++){\n\t\t\tconst rowA = res[dx]!\n\t\t\tconst rowB = res[res.length - dx - 1]!\n\t\t\tfor(let y = 0; y < rowA.length; y++){\n\t\t\t\tconst tmp = rowA[y]!\n\t\t\t\trowA[y] = rowB[y]!\n\t\t\t\trowB[y] = tmp\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor(let x = 0; x < pattern.length; x++){\n\t\t\tconst row = res[x]!\n\t\t\tfor(let dy = 0; dy < halfLen; dy++){\n\t\t\t\tconst tmp = row[dy]!\n\t\t\t\trow[dy] = row[row.length - dy - 1]!\n\t\t\t\trow[row.length - dy - 1] = tmp\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n\nfunction rotatePattern<T>(pattern: PatternData<T>, times: 1 | 2 | 3): PatternData<T> {\n\tconst res = copyPattern(pattern)\n\tconst size = pattern.length\n\tconst halfSize = Math.floor(size / 2)\n\tfor(let i = 0; i < times; i++){\n\t\tfor(let circleOffset = 0; circleOffset < halfSize; circleOffset++){\n\t\t\tconst lastPos = size - circleOffset - 1\n\t\t\tfor(let posOffset = circleOffset; posOffset < size - circleOffset - 1; posOffset++){\n\t\t\t\tconst tmp = res[posOffset]![circleOffset]!\n\t\t\t\tres[posOffset]![circleOffset] = res[lastPos]![posOffset]!\n\t\t\t\tres[lastPos]![posOffset] = res[size - posOffset - 1]![lastPos]!\n\t\t\t\tres[size - posOffset - 1]![lastPos] = res[circleOffset]![size - posOffset - 1]!\n\t\t\t\tres[circleOffset]![size - posOffset - 1] = tmp\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n\nclass Matrix {\n\tprivate readonly entropy: number[]\n\tprivate readonly matrix: Bitmap\n\tprivate readonly collapseMask: Bitmap\n\tprivate readonly patternCount: number\n\tprivate incollapsedCellsCount: number\n\n\tconstructor(\n\t\tprivate readonly width: number,\n\t\tprivate readonly height: number,\n\t\tpatternCount: number,\n\t\tprivate readonly random: () => number,\n\t\tprivate readonly rules: Rules,\n\t\tprivate readonly offsets: XY[],\n\t\tprivate readonly freqs: number[]\n\t) {\n\t\tthis.patternCount = Math.ceil(patternCount / 8) * 8\n\t\tthis.entropy = new Array(width * height).fill(1)\n\t\tthis.matrix = new Bitmap(width * height * this.patternCount)\n\t\tthis.collapseMask = new Bitmap(width * height)\n\t\tthis.incollapsedCellsCount = width * height\n\n\t\tthis.matrix.setAll()\n\t\tconst paddingPatternCount = this.patternCount - patternCount\n\t\tfor(let i = 0; i < width * height; i++){\n\t\t\tconst cellEnd = ((i + 1) * this.patternCount) - 1\n\t\t\tfor(let offset = 0; offset < paddingPatternCount; offset++){\n\t\t\t\tthis.matrix.clear(cellEnd - offset)\n\t\t\t}\n\t\t}\n\t}\n\n\tisEverythingCollapsed(): boolean {\n\t\treturn this.incollapsedCellsCount === 0\n\t}\n\n\tfindMinEntropyCell(): XY | null {\n\t\tlet minEntropy = Number.MAX_SAFE_INTEGER\n\t\tconst cells: number[] = []\n\t\tfor(let i = 0; i < this.entropy.length; i++){\n\t\t\tif(this.collapseMask.get(i)){\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tconst entropy = this.entropy[i]!\n\t\t\tif(entropy < minEntropy){\n\t\t\t\tcells.length = 0\n\t\t\t\tminEntropy = entropy\n\t\t\t}\n\t\t\tif(entropy === minEntropy){\n\t\t\t\tcells.push(i)\n\t\t\t}\n\t\t}\n\t\tif(cells.length === 0){\n\t\t\treturn null\n\t\t}\n\n\t\t// console.log(`Lowest entropy cells are at ${minEntropy}: `, cells.map(index => ({x: index % this.width, y: Math.floor(index / this.width)})))\n\n\t\tconst index = cells.length === 1 ? cells[0]! : cells[Math.floor(this.random() * cells.length)]!\n\t\treturn {x: index % this.width, y: Math.floor(index / this.width)}\n\t}\n\n\tcollapse(cell: XY): void {\n\t\t// console.log(`Collapsing at (${cell.x}, ${cell.y}): \\n${this}`)\n\t\tconst cellIndex = cell.y * this.width + cell.x\n\t\tconst availableValues = this.matrix.getOffsetsAsNumbers(cellIndex * this.patternCount, this.patternCount)\n\t\tif(availableValues.length === 0){\n\t\t\t// should be caught on propagate stage tbh\n\t\t\tthrow new Error(`Cell at (${cell.x}, ${cell.y}) don't have available values`)\n\t\t}\n\t\tthis.collapseMask.set(cellIndex)\n\t\tthis.incollapsedCellsCount--\n\t\tif(availableValues.length === 1){\n\t\t\treturn // it's already kinda collapsed, no action required\n\t\t}\n\t\tconst selectedValue = availableValues[Math.floor(this.random() * availableValues.length)]!\n\t\t// console.log(\"Selected value: \" + selectedValue)\n\t\t// console.log(ruleToString(this.rules[selectedValue]!))\n\t\tfor(const value of availableValues){\n\t\t\tif(value === selectedValue){\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tthis.matrix.clear(cellIndex * this.patternCount + value)\n\t\t}\n\t\tthis.entropy[cellIndex] = 0\n\t\tthis.propagateStartingAt(cell)\n\t}\n\n\tprivate isInBounds(coords: XY): boolean {\n\t\treturn coords.x >= 0 && coords.y >= 0 && coords.x < this.width && coords.y < this.height\n\t}\n\n\tprivate propagateStartingAt(cell: XY): void {\n\t\tconst queue = new SetQueue<number>()\n\t\tqueue.enqueue(encodePosition(cell))\n\n\t\twhile(true){\n\t\t\tconst origCellEncoded = queue.dequeue()\n\t\t\tif(origCellEncoded === undefined || origCellEncoded === null){\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tconst origCell = decodePosition(origCellEncoded)\n\t\t\t// console.log(`Propagating at (${origCell.x}, ${origCell.y})`)\n\n\t\t\tfor(const offset of this.offsets){\n\t\t\t\tconst adjacentCellPos = {x: origCell.x + offset.x, y: origCell.y + offset.y}\n\t\t\t\tif(!this.isInBounds(adjacentCellPos)){\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst adjacentCellIndex = adjacentCellPos.y * this.width + adjacentCellPos.x\n\t\t\t\tif(this.collapseMask.get(adjacentCellIndex)){\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tconst changed = this.propagateToCellByOffset(origCell, offset)\n\t\t\t\tif(changed){\n\t\t\t\t\tqueue.enqueue(encodePosition(adjacentCellPos))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate propagateToCellByOffset(origCell: XY, offset: XY): boolean {\n\t\t// TODO: optimise here\n\t\tconst encodedOffset = encodeOffset(offset)\n\t\tconst origCellIndex = origCell.y * this.width + origCell.x\n\t\tconst origCellPatterns = this.matrix.getOffsetsAsNumbers(origCellIndex * this.patternCount, this.patternCount)\n\t\tconst resultTargetCellPatterns = new Bitmap(this.patternCount)\n\t\tfor(const origPattern of origCellPatterns){\n\t\t\tconst patternsByRule = this.rules[origPattern]!.get(encodedOffset)!\n\t\t\tfor(const targetPattern of patternsByRule){\n\t\t\t\tresultTargetCellPatterns.set(targetPattern)\n\t\t\t}\n\t\t}\n\n\t\tconst targetCell = {x: origCell.x + offset.x, y: origCell.y + offset.y}\n\t\tconst targetCellIndex = targetCell.y * this.width + targetCell.x\n\t\tconst hasChange = this.matrix.and(resultTargetCellPatterns, targetCellIndex * this.patternCount)\n\t\tif(hasChange){\n\t\t\tthis.entropy[targetCellIndex] = this.matrix.getOffsetsAsNumbers(targetCellIndex * this.patternCount, this.patternCount)\n\t\t\t\t.map(pattern => this.freqs[pattern]!)\n\t\t\t\t.reduce((a, b) => a + b, 0)\n\t\t}\n\t\treturn hasChange\n\t}\n\n\tgetResults(): number[][] {\n\t\tconst result: number[][] = []\n\t\tfor(let x = 0; x < this.width; x++){\n\t\t\tconst row: number[] = []\n\t\t\tresult.push(row)\n\t\t\tfor(let y = 0; y < this.height; y++){\n\t\t\t\tconst index = y * this.width + x\n\t\t\t\tconst patterns = this.matrix.getOffsetsAsNumbers(index * this.patternCount, this.patternCount)\n\t\t\t\trow.push(patterns[0]!)\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n\n\ttoString(): string {\n\t\tlet longestCellLen = 0\n\t\tconst result: string[][] = []\n\t\tfor(let y = 0; y < this.height; y++){\n\t\t\tconst row: string[] = []\n\t\t\tresult.push(row)\n\t\t\tfor(let x = 0; x < this.width; x++){\n\t\t\t\tconst index = y * this.width + x\n\t\t\t\tconst patterns = this.matrix.getOffsetsAsNumbers(index * this.patternCount, this.patternCount)\n\t\t\t\tconst str = shortenNumberSpan(patterns)\n\t\t\t\trow.push(str)\n\t\t\t\tlongestCellLen = Math.max(longestCellLen, str.length)\n\t\t\t}\n\t\t}\n\t\treturn result.map(row => row.map(cell => whitePad(cell, longestCellLen)).join(\" | \")).join(\"\\n\")\n\t}\n\n}\n\nfunction whitePad(str: string, len: number): string {\n\twhile(str.length < len){\n\t\tstr += \" \"\n\t}\n\treturn str\n}\n\nfunction makeRandom(seed: number): () => number {\n\tseed ^= 0xDEADBEEF\n\t// Pad seed with Phi, Pi and E.\n\t// https://en.wikipedia.org/wiki/Nothing-up-my-sleeve_number\n\tconst rand = sfc32(0x9E3779B9, 0x243F6A88, 0xB7E15162, seed)\n\tfor(let i = 0; i < 15; i++){\n\t\trand()\n\t}\n\treturn rand\n}\n\nfunction sfc32(a: number, b: number, c: number, d: number) {\n\treturn function() {\n\t\ta >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0\n\t\tlet t = (a + b) | 0\n\t\ta = b ^ b >>> 9\n\t\tb = c + (c << 3) | 0\n\t\tc = (c << 21 | c >>> 11)\n\t\td = d + 1 | 0\n\t\tt = t + d | 0\n\t\tc = c + t | 0\n\t\treturn (t >>> 0) / 4294967296\n\t}\n}\n\nclass SetQueue<T> {\n\tprivate readonly set = new Set<T>()\n\tprivate readonly queue: (T | null)[] = []\n\tprivate pos = 0\n\n\tenqueue(value: T): boolean {\n\t\tif(this.set.has(value)){\n\t\t\treturn false\n\t\t}\n\t\tthis.set.add(value)\n\t\tthis.queue.push(value)\n\t\treturn true\n\t}\n\n\tdequeue(): T | null | undefined {\n\t\tconst result = this.queue[this.pos]\n\t\tthis.queue[this.pos] = null\n\t\tif(this.queue.length > this.pos){\n\t\t\tthis.set.delete(result!)\n\t\t\tthis.pos++\n\t\t}\n\t\treturn result\n\t}\n}\n\n/** Format sequence of numbers in a shorter manner, compressing sequental spans into from-to format */\nfunction shortenNumberSpan(nums: number[]): string {\n\treturn joinSpans(nums, (a, b) => a + 1 === b).map(span => {\n\t\tconst first = span[0]!\n\t\tconst last = span[span.length - 1]!\n\t\tif(first === last){\n\t\t\treturn first + \"\"\n\t\t} else if(first + 1 === last){\n\t\t\treturn first + \",\" + last\n\t\t} else {\n\t\t\treturn first + \"-\" + last\n\t\t}\n\t}).join(\",\")\n}\n\nfunction joinSpans<T>(values: T[], shouldJoin: (a: T, b: T) => boolean): T[][] {\n\tconst result: T[][] = []\n\tif(values.length === 0){\n\t\treturn result\n\t}\n\tlet currentSpan: T[] = [values[0]!]\n\tresult.push(currentSpan)\n\n\tfor(let i = 1; i < values.length; i++){\n\t\tconst v = values[i]!\n\t\tif(shouldJoin(currentSpan[currentSpan.length - 1]!, v)){\n\t\t\tcurrentSpan.push(v)\n\t\t} else {\n\t\t\tcurrentSpan = [v]\n\t\t\tresult.push(currentSpan)\n\t\t}\n\t}\n\n\treturn result\n}","/** An optimized array of bits (booleans) */\nexport class Bitmap {\n\tprivate readonly arr: Uint8Array\n\tconstructor(readonly size: number) {\n\t\tif(size < 0){\n\t\t\tthrow new Error(`Expected non-negative as size, got ${size}`)\n\t\t}\n\n\t\tif(size % 8){\n\t\t\tsize = Math.ceil(size / 8) * 8\n\t\t}\n\n\t\tthis.arr = new Uint8Array(size >> 3)\n\t}\n\n\t/** Set bit at selected index to 1 */\n\tset(index: number): void {\n\t\tconst arr = this.arr\n\t\tconst byteIndex = index >> 3\n\t\tarr[byteIndex] = arr[byteIndex]! | (1 << (index & 0b111))\n\t}\n\n\t/** Set bit at selected index to 0 */\n\tclear(index: number): void {\n\t\tconst arr = this.arr\n\t\tconst byteIndex = index >> 3\n\t\tarr[byteIndex] = arr[byteIndex]! & (~(1 << (index & 0b111)))\n\t}\n\n\t/** Get value of bit at index */\n\tget(index: number): boolean {\n\t\treturn (this.arr[index >> 3]! & (1 << (index & 0b111))) !== 0\n\t}\n\n\t/** Set value of all the bits to 1 */\n\tsetAll(): void {\n\t\tthis.arr.fill(0xff)\n\t}\n\n\t/** Set value of all the bits to 0 */\n\tclearAll(): void {\n\t\tthis.arr.fill(0)\n\t}\n\n\t/** @returns sorted array of offsets within [start, start + length] */\n\tgetOffsetsAsNumbers(start: number, length: number): number[] {\n\t\tif(start & 0x7 || length & 0x7){\n\t\t\tthrow new Error(\"Assertion failed, only byte-aligned start/length is supported\")\n\t\t}\n\t\tconst result: number[] = []\n\t\tlet i = 0\n\t\tfor(let byteOffset = 0; byteOffset < (length >> 3); byteOffset++){\n\t\t\tconst byte = this.arr[(start >> 3) + byteOffset]!\n\t\t\tlet mask = 0x1\n\t\t\twhile(mask !== 0x100){\n\t\t\t\tif(byte & mask){\n\t\t\t\t\tresult.push(i)\n\t\t\t\t}\n\t\t\t\ti++\n\t\t\t\tmask <<= 1\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n\n\t/** Sets to 1 every offset that is present in array of offsets and to 0 everything else\n\t * @param offsets sorted array of offsets\n\t * @returns if anything was changed */\n\tsetOffsetsByNumbers(start: number, length: number, offsets: number[]): boolean {\n\t\tif(start & 0x7 || length & 0x7){\n\t\t\tthrow new Error(\"Assertion failed, only byte-aligned start/length is supported\")\n\t\t}\n\t\tlet hasChange = false\n\t\tlet offset = 0\n\t\tlet offsetIndex = 0\n\t\tlet nextNonzeroOffset = offsets[offsetIndex]\n\t\tfor(let byteOffset = 0; byteOffset < (length >> 3); byteOffset++){\n\t\t\tconst origByte = this.arr[(start >> 3) + byteOffset]!\n\t\t\tlet byte = 0\n\t\t\tlet mask = 0x1\n\t\t\twhile(mask !== 0x100){\n\t\t\t\tconst bit = offset === nextNonzeroOffset ? mask : 0\n\t\t\t\thasChange = hasChange || (origByte & mask) !== bit\n\t\t\t\tif(bit){\n\t\t\t\t\tbyte |= mask\n\t\t\t\t\toffsetIndex++\n\t\t\t\t\tnextNonzeroOffset = offsets[offsetIndex]\n\t\t\t\t}\n\t\t\t\toffset++\n\t\t\t\tmask <<= 1\n\t\t\t}\n\t\t\tthis.arr[(start >> 3) + byteOffset] = byte\n\t\t}\n\t\treturn hasChange\n\t}\n\n\t/** Applies bitwise-and operation to this bitmap; saves result in this bitmap\n\t * Expecting other bitmap to be smaller than this one\n\t * @returns if this bitmap was changed\n\t */\n\tand(other: Bitmap, startThis: number): boolean {\n\t\tif(startThis & 0x7){\n\t\t\tthrow new Error(\"Assertion failed, only byte-aligned start/length is supported\")\n\t\t}\n\t\tlet hasChange = false\n\t\tfor(let byteOffset = 0; byteOffset < other.arr.length; byteOffset++){\n\t\t\tconst thisByte = this.arr[(startThis >> 3) + byteOffset]!\n\t\t\tconst otherByte = other.arr[byteOffset]!\n\t\t\tconst result = thisByte & otherByte\n\t\t\thasChange = hasChange || (result !== thisByte)\n\t\t\tthis.arr[(startThis >> 3) + byteOffset] = result\n\t\t}\n\t\treturn hasChange\n\t}\n\n}"],"names":["$8HcCf","parcelRequire","$02ba7994cbb01639$var$islandsSource","$02ba7994cbb01639$export$f22da7240b7add18","root","patternInput","$ffFvw","PatternInput","palette","defaultValue","height","width","scale","display","$jVGbq","ColorArrayDisplay","appendChild","$aCP3q","tag","class","$9sNwz","tagName","text","on","click","source","getPattern","result","$1OdCr","waveFunctionCollapse","flip","rotate","sourceSample","patternSize","randomSeed","resultSize","draw","performeter","print","reset","x","length","row","y","set","$6f792b9b35387246$export$e1ee22bc4cc102ea","this","makeBlock","currentBlock","parent","subblocks","timeStart","timeSum","enterCount","enterBlock","name","nextBlock","performance","now","exitBlock","Error","exitEnterBlock","table","fullTime","forEachBlock","block","depth","Array","join","$6f792b9b35387246$var$strip","console","callback","start","currentDepth","subblock","v","Math","round","$hIDiW","$4c0fbf616468c6ce$var$resolveArgs","a","b","isArray","$hsvBG","isRBox","$4c0fbf616468c6ce$var$populateTag","tagBase","description","children","binder","getBinder","watch","textContent","unbox","evtName","handler","addEventListener","passive","capture","k","attrs","removeAttribute","setAttribute","vv","setChildren","childTags","filter","newChildren","i","childTag","childNodes","insertBefore","remove","$4c0fbf616468c6ce$var$updateChildren","$jM5hi","makeClassname","classname","classList","value","$4c0fbf616468c6ce$export$2b067c6666111485","document","createElement","style","$4c0fbf616468c6ce$export$e0e99c6b21dfde8d","createElementNS","setAttributeNS","$0d27fb504028ccb8$export$4ded07f8b6ee4cea","node","parts","arr","item","makeClassnameAndCallTheCallback","key","bool","push","classname1","$efatB","$96d2a9ef9a2c2245$export$5640fc17115cf007","constructor","canvas","context","getContext","values","w","h","s","fillStyle","rgbNumberToColorString","fillRect","$fa4a5aa5cdd6ce8e$var$twoHex","toString","$fa4a5aa5cdd6ce8e$export$c5ea230d2f55d434","rgb","g","$013bb80b3ccfc188$export$c5328dac6d89974f","params","primaryCb","$ih12A","preventContextMenu","addCursorMoveHandler","element","onMove","onSetColorAction","bind","downIsMove","pattern","fill","map","paletteButtons","color","button","selectColor","backgroundColor","redrawCanvas","e","coords","pointerEventsToOffsetCoords","cellX","floor","cellY","cb","prevCb","dfltClassName","clsName","className","add","JSON","parse","stringify","$070b40bf88f7afea$export$4eb1c1f17f883a41","target","HTMLElement","rect","getBoundingClientRect","touches","$070b40bf88f7afea$export$c4dfce035d43d1e0","touch","clientX","clientY","$070b40bf88f7afea$export$f9e1fc62131d1b82","left","top","$070b40bf88f7afea$export$80eb02ad18c977f1","onDown","window","onUp","removeEventListener","upIsMove","$070b40bf88f7afea$export$b3002a74c1b9a5fd","el","preventDefault","stopPropagation","$6e3d250e7771e99d$export$b64206a3d550df71","$6e3d250e7771e99d$export$6cc254038363eb2f","$6e3d250e7771e99d$export$9a9aa9ffab568c99","$6e3d250e7771e99d$export$be5cd583167290d2","$6e3d250e7771e99d$export$f9ca6c3b4d310360","$1VHh9","$b29a1f8e2035086d$export$afb809ac55339913","patterns","matrix","offsets","$b29a1f8e2035086d$var$generateOffsets","patternsFreq","$b29a1f8e2035086d$var$extractSourcePatternAt","flipped","axis","$b29a1f8e2035086d$var$flipPattern","rotated","count","pattern1","$b29a1f8e2035086d$var$rotatePattern","$b29a1f8e2035086d$var$getPatternDataFromSource","hashMap","Map","hasher","$b29a1f8e2035086d$var$PatternHasher","hash","get","freqMap","patterns1","j","otherPattern","$b29a1f8e2035086d$var$patternsAreEqual","keys","freqs","pattern2","$b29a1f8e2035086d$var$normalizeArray","$b29a1f8e2035086d$var$generatePatternsAndFrequences","rules","offset","$b29a1f8e2035086d$var$encodeOffset","encodedOffset","flipEncodedOffset","$b29a1f8e2035086d$var$flipOffset","aIndex","bIndex","$b29a1f8e2035086d$var$patternsHaveMatch","$b29a1f8e2035086d$var$getRules","random","seed","rand","c","d","t","$b29a1f8e2035086d$var$makeRandom","$b29a1f8e2035086d$var$Matrix","$b29a1f8e2035086d$var$init","isEverythingCollapsed","lowestEntropyPoint","findMinEntropyCell","collapse","patternIndices","getResults","patternIndex","intersectionLengthX","abs","intersectionLengthY","startXA","min","max","startYA","startXB","startYB","dx","dy","$b29a1f8e2035086d$var$encodePosition","position","input","sum","reduce","aRow","bRow","valueIndices","allPossibleValues","Set","$b29a1f8e2035086d$var$flatten","size","slice","$b29a1f8e2035086d$var$copyPattern","res","halfLen","rowA","rowB","tmp","tmp1","times","halfSize","circleOffset","lastPos","posOffset","patternCount","ceil","entropy","Bitmap","collapseMask","incollapsedCellsCount","setAll","paddingPatternCount","cellEnd","clear","minEntropy","Number","MAX_SAFE_INTEGER","cells","index","cell","cellIndex","availableValues","getOffsetsAsNumbers","selectedValue","propagateStartingAt","isInBounds","queue","$b29a1f8e2035086d$var$SetQueue","enqueue","origCellEncoded","dequeue","origCell","adjacentCellPos","adjacentCellIndex","propagateToCellByOffset","origCellIndex","origCellPatterns","resultTargetCellPatterns","origPattern","patternsByRule","targetPattern","targetCell","targetCellIndex","hasChange","and","longestCellLen","str","shouldJoin","currentSpan","$b29a1f8e2035086d$var$joinSpans","span","first","last","len","$b29a1f8e2035086d$var$whitePad","pos","has","delete","$665dc4e67c6f8c6a$export$3924f7882b5e2b61","Uint8Array","byteIndex","clearAll","byteOffset","byte","mask","setOffsetsByNumbers","offsetIndex","nextNonzeroOffset","origByte","bit","other","startThis","thisByte"],"version":3,"file":"wave_function_collapse.e3d0e729.js.map"}