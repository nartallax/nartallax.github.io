{"mappings":"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","sources":["src/sketches/timer/timer.ts","src/common/tag.ts","src/common/classname.ts","src/sketches/timer/timer.module.scss"],"sourcesContent":["import {tag} from \"common/tag\"\nimport * as css from \"./timer.module.scss\"\n\nconst twoDigis = (x: number): string => x < 10 ? \"0\" + x : \"\" + x\nconst threeDigits = (x: number): string => x < 10 ? \"00\" + x : x < 100 ? \"0\" + x : \"\" + x\n\nfunction formatTime(time: number): string {\n\tif(time < 0){\n\t\treturn \"-\" + formatTime(-time)\n\t}\n\tconst ms = time % 1000\n\ttime = Math.floor(time / 1000)\n\n\tconst s = time % 60\n\ttime = Math.floor(time / 60)\n\n\tconst m = time % 60\n\tconst h = Math.floor(time / 60)\n\treturn `${twoDigis(h)}:${twoDigis(m)}:${twoDigis(s)}.${threeDigits(ms)}`\n}\n\nfunction formatTimeShort(time: number): string {\n\tlet result = formatTime(time).replace(/^[0:]+/, \"\") // lol\n\tif(result.startsWith(\".\")){\n\t\tresult = \"0\" + result\n\t}\n\treturn result\n}\n\nfunction intOrZero(x: string): number {\n\tconst result = parseInt(x)\n\tif(Number.isNaN(result) || !Number.isFinite(result)){\n\t\treturn 0\n\t} else {\n\t\treturn result\n\t}\n}\n\nfunction parseTime(time: string): number {\n\tconst parts = time.split(\":\")\n\tlet msec = 0\n\tif(parts.length > 0){\n\t\tconst lastPart = parts[parts.length - 1]!\n\t\tconst secParts = lastPart.split(\".\")\n\t\tif(secParts.length === 2){\n\t\t\tconst [secondsPart, msecPart] = secParts\n\t\t\tparts[parts.length - 1] = secondsPart!\n\t\t\tmsec += intOrZero(msecPart!)\n\t\t}\n\t}\n\n\tlet mult = 1000\n\tfor(let i = parts.length - 1; i >= 0; i--){\n\t\tconst part = parts[i]!\n\t\tmsec += intOrZero(part) * mult\n\t\tmult *= 60\n\t}\n\treturn msec\n}\n\nfunction onAnyChange(input: HTMLInputElement, handler: (value: string) => void): void {\n\tlet lastValue = input.value\n\tconst wrappedHandler = () => {\n\t\tconst value = input.value\n\t\tif(value !== lastValue){\n\t\t\tlastValue = value\n\t\t\thandler(value)\n\t\t}\n\t}\n\tinput.addEventListener(\"change\", wrappedHandler)\n\tinput.addEventListener(\"mousedown\", wrappedHandler)\n\tinput.addEventListener(\"mouseup\", wrappedHandler)\n\tinput.addEventListener(\"keydown\", wrappedHandler)\n\tinput.addEventListener(\"keyup\", wrappedHandler)\n}\n\nexport function main(root: HTMLElement): void {\n\troot.classList.add(css.timerRoot ?? \"\")\n\tconst wrap = tag({class: css.wrap})\n\n\tconst timeEl = tag({class: css.timer})\n\twrap.appendChild(timeEl)\n\n\tconst resetBtn = tag({tagName: \"button\", text: \"reset\", class: css.button})\n\tresetBtn.addEventListener(\"click\", () => {\n\t\ttimeAcc = 0\n\t\tupdateText()\n\t})\n\twrap.appendChild(resetBtn)\n\n\tconst pauseBtn = tag({tagName: \"button\", text: \"pause\", class: css.button})\n\tpauseBtn.addEventListener(\"click\", () => {\n\t\tif(paused){\n\t\t\tpaused = false\n\t\t\tpauseBtn.value = \"pause\"\n\t\t} else {\n\t\t\tpaused = true\n\t\t\tpauseBtn.value = \"unpause\"\n\t\t}\n\t})\n\twrap.appendChild(pauseBtn)\n\n\tconst speedBlock = tag({class: css.speedBlock, text: \"Speed: \"})\n\tconst speedInput = tag({tagName: \"input\", attrs: {type: \"number\", value: 1}, class: css.speedInput})\n\tonAnyChange(speedInput, () => {\n\t\tconst parsed = parseFloat(speedInput.value)\n\t\tif(Number.isNaN(parsed) || !Number.isFinite(parsed)){\n\t\t\tconsole.warn(\"Bad speed value: \" + JSON.stringify(speedInput.value) + \": cannot parse\")\n\t\t\treturn\n\t\t}\n\t\tspeed = parsed\n\t})\n\tspeedBlock.appendChild(speedInput)\n\twrap.appendChild(speedBlock)\n\n\n\tconst addTimeBlock = tag()\n\tconst addTimeButton = tag({tagName: \"button\", text: \"Add time\", class: css.button})\n\taddTimeButton.addEventListener(\"click\", () => {\n\t\ttimeAcc += parseTime(addTimeInput.value)\n\t\tupdateText()\n\t})\n\taddTimeBlock.appendChild(addTimeButton)\n\tconst addTimeInput = tag({tagName: \"input\", attrs: {type: \"string\", value: \"5:00.000\"}, class: css.speedInput})\n\taddTimeInput.addEventListener(\"blur\", () => {\n\t\taddTimeInput.value = formatTimeShort(parseTime(addTimeInput.value))\n\t})\n\taddTimeBlock.appendChild(addTimeInput)\n\n\twrap.appendChild(addTimeBlock)\n\n\troot.appendChild(wrap)\n\n\tfunction updateText(): void {\n\t\ttimeEl.textContent = formatTime(Math.round(timeAcc))\n\t}\n\n\tlet timeAcc = 0\n\tlet paused = false\n\tlet speed = 1\n\tlet lastUpdateTime = Date.now()\n\tconst updateTimer = () => {\n\t\trequestAnimationFrame(updateTimer)\n\t\tconst now = Date.now()\n\t\tconst dTime = (now - lastUpdateTime) * speed\n\t\tlastUpdateTime = now\n\t\tif(!paused){\n\t\t\ttimeAcc += dTime\n\t\t\tupdateText()\n\t\t}\n\t}\n\tupdateTimer()\n}","import {Binder, getBinder} from \"common/binder/binder\"\nimport {isRBox, MaybeRBoxed, RBox, unbox, WBox} from \"common/box\"\nimport {ClassNameParts, makeClassname} from \"common/classname\"\nimport {FieldsOfObjectWithType, WritableKeysOf} from \"common/type_utils\"\n\ntype CssStyleAssignableKeys = WritableKeysOf<CSSStyleDeclaration> & FieldsOfObjectWithType<CSSStyleDeclaration, string>\n\ninterface TagDescription<K extends string = string, ThisType = unknown> {\n\treadonly tagName?: K\n\treadonly text?: MaybeRBoxed<string | number>\n\treadonly attrs?: {\n\t\treadonly [attrName: string]: MaybeRBoxed<string | number | undefined | null>\n\t}\n\treadonly on?: {\n\t\treadonly [k in keyof GlobalEventHandlersEventMap]?: (this: ThisType, evt: GlobalEventHandlersEventMap[k]) => void\n\t}\n\treadonly class?: ClassNameParts\n}\n\nexport interface HTMLTagDescription<K extends keyof HTMLElementTagNameMap = keyof HTMLElementTagNameMap> extends TagDescription<K, HTMLElementTagNameMap[K]> {\n\n\treadonly style?: {\n\t\treadonly [k in CssStyleAssignableKeys]?: MaybeRBoxed<string | number>\n\t}\n}\n\nexport type SVGTagDescription<K extends keyof SVGElementTagNameMap = keyof SVGElementTagNameMap> = TagDescription<K, SVGElementTagNameMap[K]>\n\ntype ChildArray = (Element | null | undefined)[] | RBox<(Element | null | undefined)[]>\n\n// typings are weird here, had to cast\nfunction resolveArgs<K>(a?: K | ChildArray, b?: ChildArray): [K, ChildArray | undefined] {\n\tif(!a){\n\t\treturn [{} as K, b]\n\t} else if(Array.isArray(a) || isRBox(a)){\n\t\treturn [{} as K, a as ChildArray]\n\t} else {\n\t\treturn [a as K, b]\n\t}\n}\n\nfunction populateTag<K extends string, T>(tagBase: Element, description: TagDescription<K, T>, children?: ChildArray): Binder | null {\n\tlet binder: Binder | null = null\n\n\tif(description.text){\n\t\tconst text = description.text\n\t\tif(isRBox(text)){\n\t\t\t(binder ||= getBinder(tagBase)).watch<string | number>(text, text => {\n\t\t\t\ttagBase.textContent = text + \"\"\n\t\t\t})\n\t\t}\n\t\ttagBase.textContent = unbox(text) + \"\"\n\t}\n\n\tif(description.on){\n\t\tfor(const evtName in description.on){\n\t\t\tconst handler = description.on[evtName as keyof GlobalEventHandlersEventMap]\n\t\t\t// I don't want to construct elaborat solid type here\n\t\t\t// I know the type will be correct, because it is enforced by function parameter type\n\t\t\t// so just be Any and that's it\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\ttagBase.addEventListener(evtName, handler as any, {passive: true, capture: false})\n\t\t}\n\t}\n\n\tfor(const k in description.attrs){\n\t\tconst v = description.attrs[k]\n\t\tif(isRBox(v)){\n\t\t\t(binder ||= getBinder(tagBase)).watch<string | number | null | undefined>(v, v => {\n\t\t\t\tif(v === null || v === undefined){\n\t\t\t\t\ttagBase.removeAttribute(k)\n\t\t\t\t} else {\n\t\t\t\t\ttagBase.setAttribute(k, v + \"\")\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\tconst vv = unbox(v)\n\t\tif(v !== null && v !== undefined){\n\t\t\ttagBase.setAttribute(k, vv + \"\")\n\t\t}\n\t}\n\n\tif(children){\n\t\tconst setChildren = (children: (Element | null | undefined)[]) => {\n\t\t\tconst childTags = children.filter(x => !!x) as Element[]\n\t\t\tupdateChildren(tagBase, childTags)\n\t\t}\n\n\t\tif(isRBox(children)){\n\t\t\t(binder ||= getBinder(tagBase)).watch(children, children => {\n\t\t\t\tsetChildren(children)\n\t\t\t})\n\t\t}\n\t\tsetChildren(unbox(children))\n\t}\n\n\tif(description.class){\n\t\tbinder = makeClassname(\n\t\t\tbinder,\n\t\t\ttagBase,\n\t\t\tdescription.class,\n\t\t\t// using classList here because on svg elements .className is readonly (in runtime)\n\t\t\tclassname => tagBase.classList.value = classname\n\t\t) || binder\n\t}\n\n\treturn binder\n}\n\nexport function tag(): HTMLDivElement\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(description: HTMLTagDescription<K>): HTMLElementTagNameMap[K]\nexport function tag(children: ChildArray): HTMLDivElement\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(description: HTMLTagDescription<K>, children: ChildArray): HTMLElementTagNameMap[K]\n\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(a?: HTMLTagDescription<K> | ChildArray, b?: ChildArray): HTMLElementTagNameMap[K] {\n\tconst [description, children] = resolveArgs(a, b)\n\n\tconst tagBase = document.createElement(description.tagName || \"div\")\n\n\tlet binder = populateTag(tagBase, description, children)\n\n\tif(description.style){\n\t\tfor(const k in description.style){\n\t\t\tconst v = description.style[k as CssStyleAssignableKeys]\n\t\t\tif(isRBox(v)){\n\t\t\t\t(binder ||= getBinder(tagBase)).watch<string | number>(v, v => {\n\t\t\t\t\ttagBase.style[k] = v + \"\"\n\t\t\t\t})\n\t\t\t}\n\t\t\ttagBase.style[k] = unbox(description.style[k]!) + \"\"\n\t\t}\n\t}\n\n\treturn tagBase as HTMLElementTagNameMap[K]\n}\n\nexport function svgTag(): SVGGElement\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(description: SVGTagDescription<K>): SVGElementTagNameMap[K]\nexport function svgTag(children: ChildArray): SVGGElement\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(description: SVGTagDescription<K>, children: ChildArray): SVGElementTagNameMap[K]\n\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(a?: SVGTagDescription<K> | ChildArray, b?: ChildArray): SVGElementTagNameMap[K] {\n\tconst [description, children] = resolveArgs(a, b)\n\n\tconst tagBase = document.createElementNS(\"http://www.w3.org/2000/svg\", description.tagName || \"g\")\n\n\tif(description.tagName === \"svg\"){\n\t\ttagBase.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\")\n\t}\n\n\tpopulateTag(tagBase, description, children)\n\n\treturn tagBase as SVGElementTagNameMap[K]\n}\n\nfunction updateChildren(parent: Element, newChildren: readonly Element[]): void {\n\tfor(let i = 0; i < newChildren.length; i++){\n\t\tconst childTag = newChildren[i]!\n\t\tconst x = parent.childNodes[i]\n\t\tif(x === childTag){\n\t\t\tcontinue\n\t\t}\n\t\tif(x){\n\t\t\tparent.insertBefore(childTag, x)\n\t\t} else {\n\t\t\tparent.appendChild(childTag)\n\t\t}\n\t}\n\n\twhile(parent.childNodes[newChildren.length]){\n\t\tparent.childNodes[newChildren.length]!.remove()\n\t}\n}\n\n/** Cached renderer for list of elements\n * Won't re-render an element if already has one for the value */\nexport function renderArray<T, K, E extends Element>(src: WBox<T[]>, getKey: (value: T) => K, render: (value: WBox<T>) => E): RBox<E[]>\nexport function renderArray<T, K, E extends Element>(src: RBox<T[]>, getKey: (value: T) => K, render: (value: RBox<T>) => E): RBox<E[]>\nexport function renderArray<T, K, E extends Element>(src: MaybeRBoxed<readonly T[]>, getKey: (value: T) => K, render: (value: MaybeRBoxed<T>) => E): E[]\nexport function renderArray<T, K, E extends Element>(src: MaybeRBoxed<readonly T[]> | WBox<T[]>, getKey: (value: T) => K, render: (value: WBox<T> | T) => E): Node[] | RBox<Node[]> {\n\tif(Array.isArray(src)){\n\t\treturn src.map(el => render(el))\n\t}\n\n\tconst map = new Map<WBox<T>, E>()\n\n\treturn (src as WBox<T[]>).wrapElements(getKey).map(itemBoxes => {\n\t\tconst leftoverBoxes = new Set(map.keys())\n\n\t\tconst result = itemBoxes.map(itemBox => {\n\t\t\tleftoverBoxes.delete(itemBox)\n\t\t\tlet el = map.get(itemBox)\n\t\t\tif(!el){\n\t\t\t\tel = render(itemBox)\n\t\t\t\tmap.set(itemBox, el)\n\t\t\t}\n\t\t\treturn el\n\t\t})\n\n\t\tfor(const oldBox of leftoverBoxes){\n\t\t\tmap.delete(oldBox)\n\t\t}\n\n\t\treturn result\n\t})\n}","import {Binder, getBinder} from \"common/binder/binder\"\nimport {isRBox, MaybeRBoxed, unbox} from \"common/box\"\n\ntype ClassNamePart = MaybeRBoxed<string | null | undefined> | Record<string, MaybeRBoxed<boolean | undefined>>\nexport type ClassNameParts = ClassNamePart | ClassNamePart[]\n\n/** Utility function that assembles classname from parts */\nexport function makeClassname(binder: Binder | null, node: Node, parts: ClassNameParts, callback: (className: string) => void): Binder | null {\n\tconst arr = Array.isArray(parts) ? parts : [parts]\n\tfor(const item of arr){\n\t\tif(isRBox(item)){\n\t\t\t(binder ||= getBinder(node)).watch(item, makeClassnameAndCallTheCallback)\n\t\t} else if(item && typeof(item) === \"object\"){\n\t\t\tfor(const key in item){\n\t\t\t\tconst bool = item[key]\n\t\t\t\tif(isRBox(bool)){\n\t\t\t\t\t(binder ||= getBinder(node)).watch(bool, makeClassnameAndCallTheCallback)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction makeClassnameAndCallTheCallback() {\n\t\tconst result = []\n\t\tfor(const item of arr){\n\t\t\tif(item && typeof(item) === \"object\"){\n\t\t\t\tfor(const classname in item){\n\t\t\t\t\tif(unbox(item[classname])){\n\t\t\t\t\t\tresult.push(classname)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst classname = unbox(item)\n\t\t\t\tif(classname){\n\t\t\t\t\tresult.push(classname)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcallback(result.join(\" \"))\n\t}\n\n\tmakeClassnameAndCallTheCallback()\n\n\treturn binder\n}",".timerRoot {\n\tbackground: #222;\n\tdisplay: flex;\n\tflex-direction: column;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n.wrap {\n\tdisplay: flex;\n\tflex-direction: column;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n.timer {\n\tfont-size: 5vw;\n\tcolor: #ccc;\n\tfont-family: 'courier new';\n}\n\n.speedInput, \n.button {\n\tfont-size: 2vw;\n\tcolor: #aaa;\n\tborder: 2px solid #aaa;\n\tbackground: #444;\n\tcursor: pointer;\n\ttransition: 0.25s;\n\tborder-radius: 3px;\n\n\tmargin: 0.5vw;\n}\n\n.speedInput:hover, \n.resetButton:hover {\n\tcolor: #fff;\n\tborder-color: #fff;\n\tbackground: #888;\n}\n\n.speedBlock {\n\tmargin: 0.5vw;\n\tfont-size: 2vw;\n\tcolor: #ccc;\n}\n\n.speedInput {\n\tmax-width: 5em;\n}"],"names":["$aCP3q","parcelRequire","$85fafec3b85dd8b2$var$twoDigis","x","$85fafec3b85dd8b2$var$formatTime","time","ms","s","Math","floor","m","h","$85fafec3b85dd8b2$var$intOrZero","result","parseInt","Number","isNaN","isFinite","$85fafec3b85dd8b2$var$parseTime","parts","split","msec","length","secParts","secondsPart","msecPart","mult","i","$85fafec3b85dd8b2$export$f22da7240b7add18","root","classList","add","$g0JTA","timerRoot","wrap","tag","class","timeEl","timer","appendChild","resetBtn","tagName","text","button","addEventListener","timeAcc","updateText","pauseBtn","paused","value","speedBlock","speedInput","attrs","type","input","handler","lastValue","wrappedHandler","$85fafec3b85dd8b2$var$onAnyChange","parsed","parseFloat","speed","console","warn","JSON","stringify","addTimeBlock","addTimeButton","addTimeInput","textContent","round","replace","startsWith","$85fafec3b85dd8b2$var$formatTimeShort","lastUpdateTime","Date","now","updateTimer","requestAnimationFrame","dTime","$hIDiW","$4c0fbf616468c6ce$var$resolveArgs","a","b","Array","isArray","$hsvBG","isRBox","$4c0fbf616468c6ce$var$populateTag","tagBase","description","children","binder","getBinder","watch","unbox","on","evtName","passive","capture","k","v","removeAttribute","setAttribute","vv","setChildren","childTags","filter","parent","newChildren","childTag","childNodes","insertBefore","remove","$4c0fbf616468c6ce$var$updateChildren","$jM5hi","makeClassname","classname","$4c0fbf616468c6ce$export$2b067c6666111485","document","createElement","style","$4c0fbf616468c6ce$export$e0e99c6b21dfde8d","createElementNS","setAttributeNS","$0d27fb504028ccb8$export$4ded07f8b6ee4cea","node","callback","arr","item","makeClassnameAndCallTheCallback","key","bool","push","classname1","join","$ba803f58ba7028d1$export$9dc4ecf953986f04","$ba803f58ba7028d1$export$4997ffc0176396a6","$ba803f58ba7028d1$export$df1e6181cc5665bb","$ba803f58ba7028d1$export$ac48f81997917406","$ba803f58ba7028d1$export$fd786f21a988b067","$ba803f58ba7028d1$export$2ba01fb71ed41cb6"],"version":3,"file":"timer.e822dc81.js.map"}