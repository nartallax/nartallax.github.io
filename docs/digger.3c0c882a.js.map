{"mappings":"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","sources":["node_modules/@nartallax/cardboard-dom/ts/src/box_dom_binding/dom_value_link.ts","node_modules/@nartallax/cardboard-dom/ts/src/box_dom_binding/css_variable_box.ts","node_modules/@nartallax/cardboard-dom/ts/src/parts/check_repeater.ts","node_modules/@nartallax/cardboard-dom/ts/src/monkeypatching/history_monkeypatching.ts","node_modules/@nartallax/cardboard-dom/ts/src/box_dom_binding/url_box.ts","node_modules/@nartallax/cardboard-dom/ts/src/parts/binder.ts","node_modules/@nartallax/cardboard-dom/ts/src/monkeypatching/dom_monkeypatching.ts","node_modules/@nartallax/cardboard-dom/ts/src/parts/projected_tree_state.ts","node_modules/@nartallax/cardboard-dom/ts/src/functions/utils.ts","node_modules/@nartallax/cardboard-dom/ts/src/functions/base_tag.ts","node_modules/@nartallax/cardboard-dom/ts/src/functions/classname.ts","node_modules/@nartallax/cardboard-dom/ts/src/node_binding.ts","node_modules/@nartallax/cardboard-dom/ts/src/parts/async_mutation_watcher.ts","node_modules/@nartallax/cardboard-dom/ts/src/parts/sync_mutation_watcher.ts","node_modules/@nartallax/cardboard-dom/ts/src/box_dom_binding/bind_box_to_dom.ts","node_modules/@nartallax/cardboard-dom/ts/src/box_dom_binding/local_storage_box.ts","node_modules/@nartallax/cardboard-dom/ts/src/functions/html_tag.ts","node_modules/@nartallax/cardboard-dom/ts/src/functions/svg_tag.ts","node_modules/@nartallax/cardboard-dom/ts/src/functions/wait_document_loaded.ts","node_modules/@nartallax/cardboard/ts/src/dependency_lists/base_dependency_list.ts","node_modules/@nartallax/cardboard/ts/src/dependency_lists/multiple_dependency_list.ts","node_modules/@nartallax/cardboard/ts/src/dependency_lists/single_dependency_list.ts","node_modules/@nartallax/cardboard/ts/src/boxes/abstract/base_box.ts","node_modules/@nartallax/cardboard/ts/src/array_contexts/map_array_elements.ts","node_modules/@nartallax/cardboard/ts/src/boxes/abstract/first_subscriber_handling_box.ts","node_modules/@nartallax/cardboard/ts/src/boxes/abstract/downstream_box.ts","node_modules/@nartallax/cardboard/ts/src/boxes/abstract/single_downstream_box.ts","node_modules/@nartallax/cardboard/ts/src/boxes/map_box.ts","node_modules/@nartallax/cardboard/ts/src/boxes/prop_box.ts","node_modules/@nartallax/cardboard/ts/src/boxes/array_context_controlled_box.ts","node_modules/@nartallax/cardboard/ts/src/boxes/array_item_box.ts","node_modules/@nartallax/cardboard/ts/src/boxes/calc_box.ts","node_modules/@nartallax/cardboard/ts/src/boxes/value_box.ts","node_modules/@nartallax/cardboard/ts/src/boxes/const_box.ts","node_modules/@nartallax/cardboard/ts/src/common.ts","node_modules/@nartallax/cardboard/ts/src/subscriber_list.ts","node_modules/@nartallax/cardboard/ts/src/array_contexts/array_context.ts","node_modules/@nartallax/cardboard/ts/src/array_contexts/const_array_context.ts","node_modules/@nartallax/cardboard/ts/src/update_delivery/update_queue.ts","node_modules/@nartallax/cardboard/ts/src/update_delivery/update.ts"],"sourcesContent":["import {RBox, isWBox} from \"@nartallax/cardboard\"\nimport {DomBoxOptionsBase} from \"src/box_dom_binding/bind_box_to_dom\"\nimport {Binder} from \"src/parts/binder\"\n\nconst NoValueKnown = Symbol(\"dom-value-link-no-value-known\")\n\n/** Some wrapper around DOM value that can bind box to the value */\nexport abstract class DomValueLink<T, R = unknown, O extends DomBoxOptionsBase = DomBoxOptionsBase> {\n\tprotected abstract updateDomValue(value: T): void\n\tprotected abstract parseDomValue(domValue: R): T\n\tprotected abstract getRawDomValue(): R\n\tprotected subscribeToDomValue(): void {\n\t\t// nothing by default; there's no way to subscribe to some of the DOM values\n\t\t// subclasses are supposed to set up event listeners that call this.updateBoxValueBound\n\t\t// (bound = can be used without call context; was .bind(this)-ed)\n\t}\n\tprotected unsubscribeFromDomValue(): void {\n\t\t// nothing by default\n\t}\n\n\tprivate readonly subscribeDomBound: () => void\n\tprivate readonly unsubscribeDomBound: () => void\n\tprivate readonly tryUpdateDomValueBound: (value: T) => void\n\tprotected readonly updateBoxValueBound: () => void\n\tprivate lastKnownRawDomValue: R | typeof NoValueKnown = NoValueKnown\n\n\tconstructor(readonly box: RBox<T>, readonly options: O) {\n\t\tthis.subscribeDomBound = this.subscribeToDomValue.bind(this)\n\t\tthis.unsubscribeDomBound = this.unsubscribeFromDomValue.bind(this)\n\t\tthis.tryUpdateDomValueBound = this.tryUpdateDomValue.bind(this)\n\t\tthis.updateBoxValueBound = this.updateBoxValue.bind(this)\n\t}\n\n\tprivate canPushUpdates(): boolean {\n\t\treturn this.subscribeToDomValue !== DomValueLink.prototype.subscribeToDomValue && isWBox(this.box)\n\t}\n\n\tprotected updateBoxValue(): void {\n\t\tif(!isWBox(this.box)){\n\t\t\treturn\n\t\t}\n\n\t\tconst rawValue = this.getRawDomValue()\n\t\tif(this.lastKnownRawDomValue === rawValue){\n\t\t\treturn\n\t\t}\n\t\tthis.lastKnownRawDomValue = rawValue\n\t\tthis.box.set(this.parseDomValue(rawValue))\n\t}\n\n\tprivate tryUpdateDomValue(value: T): void {\n\t\tconst rawDomValue = this.getRawDomValue()\n\t\tconst preferBoxValue = this.options.preferBoxValue || !isWBox(this.box)\n\t\tif(rawDomValue !== this.lastKnownRawDomValue && !preferBoxValue){\n\t\t\treturn // we don't actually update anything here. we expect box value to be updated in other handler\n\t\t}\n\n\t\tthis.updateDomValue(value)\n\t\tthis.lastKnownRawDomValue = this.getRawDomValue()\n\t}\n\n\tbind(binder: Binder): void {\n\t\tif(this.canPushUpdates()){\n\t\t\tbinder.onInserted(this.updateBoxValueBound)\n\t\t\tbinder.onInserted(this.subscribeDomBound)\n\t\t\tbinder.onRemoved(this.unsubscribeDomBound)\n\t\t}\n\n\t\tif(binder.isInDom){\n\t\t\tthis.subscribeToDomValue()\n\t\t}\n\n\t\tif(this.options.preferBoxValue || !isWBox(this.box)){\n\t\t\tbinder.watchAndRun(this.box, this.tryUpdateDomValueBound)\n\t\t} else {\n\t\t\tbinder.watch(this.box, this.tryUpdateDomValueBound)\n\t\t\tthis.updateBoxValue()\n\t\t}\n\t}\n\n\tunbind(binder: Binder): void {\n\t\tif(this.canPushUpdates()){\n\t\t\tbinder.offInserted(this.updateBoxValueBound)\n\t\t\tbinder.offInserted(this.subscribeDomBound)\n\t\t\tbinder.offRemoved(this.unsubscribeDomBound)\n\t\t\tif(binder.isInDom){\n\t\t\t\tthis.unsubscribeFromDomValue()\n\t\t\t}\n\t\t}\n\t\tbinder.unwatch(this.tryUpdateDomValueBound)\n\t}\n\n}","import {RBox, WBox, box, isWBox} from \"@nartallax/cardboard\"\nimport {DomBoxOptionsBase, bindBoxToDomValue} from \"src/box_dom_binding/bind_box_to_dom\"\nimport {DomValueLink} from \"src/box_dom_binding/dom_value_link\"\n\nexport type CssVariableBoxOptions = DomBoxOptionsBase & {\n\treadonly type: \"cssVariable\"\n\treadonly name: string\n\treadonly element?: HTMLElement\n}\n\nexport class CssVariableBoxLink<T> extends DomValueLink<T, string, CssVariableBoxOptions> {\n\n\tconstructor(private readonly node: Node, box: RBox<T>, options: CssVariableBoxOptions) {\n\t\tif(isWBox(box)){\n\t\t\t// never try to put anything in this box\n\t\t\tbox = box.map(x => x)\n\t\t}\n\t\tsuper(box, options)\n\t}\n\n\tprivate get element(): HTMLElement {\n\t\treturn this.options.element ?? (this.node instanceof HTMLElement ? this.node : null) ?? document.body\n\t}\n\n\tprotected getRawDomValue(): string {\n\t\treturn (this.options.element ?? document.body).style.getPropertyValue(this.options.name)\n\t}\n\n\tprotected updateDomValue(value: T): void {\n\t\tconst name = this.options.name\n\n\t\tif(value === null || value === undefined || value === \"\" || (typeof(value) !== \"string\" && typeof(value) !== \"number\")){\n\t\t\tthis.element.style.removeProperty(name)\n\t\t} else {\n\t\t\tthis.element.style.setProperty(name, value + \"\")\n\t\t}\n\t}\n\n\tprotected parseDomValue(): T {\n\t\tthrow new Error(\"There's no way to move value of CSS variable into box, because it could break types: CSS variable is always string, but box may be of different type. If you need to do that - do that explicitly by using element.style.getPropertyValue(name)\")\n\t}\n\n}\n\n/** Creates a writable box that is linked to CSS variable on a particular element.\n * Keep in mind that name should start with --\n * If value of the variable is non-empty string, or number - the variable will take this value;\n * otherwise, variable will be deleted. */\nexport function cssVariableBox<T>(node: Node, name: string, value: T, options?: Omit<CssVariableBoxOptions, \"type\" | \"name\">): WBox<T> {\n\tconst result = box(value)\n\tbindBoxToDomValue(node, result, {...(options || {}), name, type: \"cssVariable\"})\n\treturn result\n}","export class CheckRepeater {\n\n\tprivate startTime = 0\n\tprivate isRunning = false\n\n\tconstructor(private readonly timeoutMs: number, private readonly check: () => boolean) {}\n\n\tprivate runCheckAndRequest(): void {\n\t\tconst fn = () => {\n\t\t\ttry {\n\t\t\t\tif(this.check() || Date.now() - this.startTime > this.timeoutMs){\n\t\t\t\t\tthis.isRunning = false\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} catch(e){\n\t\t\t\tthis.isRunning = false\n\t\t\t\tthrow e\n\t\t\t}\n\t\t\trequestFrame(fn)\n\t\t}\n\n\t\tthis.isRunning = true\n\t\tfn()\n\t}\n\n\trun(): void {\n\t\tthis.startTime = Date.now()\n\t\tif(!this.isRunning){\n\t\t\tthis.runCheckAndRequest()\n\t\t}\n\t}\n\n}\n\nconst requestFrame: (callback: () => void) => unknown = requestAnimationFrame as any ?? ((callback: () => void) => setTimeout(callback, 1000 / 60) as unknown)","import {CheckRepeater} from \"src/parts/check_repeater\"\n\nclass HistoryUpdateWatcher {\n\n\tprivate readonly handlers = new Set<() => void>()\n\tprivate lastKnownLocation = \"\"\n\tprivate isPatched = false\n\tprivate repeater = new CheckRepeater(1000, this.tryCallHandlers.bind(this))\n\n\tsubscribe(handler: () => void) {\n\t\tthis.handlers.add(handler)\n\t\tif(!this.isPatched){\n\t\t\tthis.isPatched = true\n\t\t\tthis.patch()\n\t\t}\n\t}\n\n\tunsubscribe(handler: () => void): void {\n\t\tthis.handlers.delete(handler)\n\t}\n\n\tprivate patch(): void {\n\t\tthis.lastKnownLocation = window.location + \"\"\n\n\t\tconst proto = History.prototype as any\n\n\t\tfor(const key in proto){\n\t\t\tlet original: any\n\t\t\ttry {\n\t\t\t\toriginal = proto[key]\n\t\t\t} catch(e){\n\t\t\t\t// could happen in case of props\n\t\t\t\t// thing is, methods could also be defined as props\n\t\t\t\t// so I don't want to miss anything\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif(typeof(original) !== \"function\"){\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\n\t\t\tconst self = this\n\t\t\tconst patched = function(this: any, ...args: any[]): any {\n\t\t\t\tconst result = original.apply(this, args)\n\t\t\t\t/* this is kinda bad\n\t\t\t\t* but some of the history methods don't change location synchronously,\n\t\t\t\t* and there's no way to get it anywhere else.\n\t\t\t\t*\n\t\t\t\t* I was thinking about maintaining history stack by myself,\n\t\t\t\t* but that won't cover all of the cases (like some of the history added before patch) */\n\t\t\t\tself.repeater.run()\n\t\t\t\treturn result\n\t\t\t}\n\t\t\tproto[key] = patched\n\t\t}\n\t}\n\n\tprivate tryCallHandlers(): boolean {\n\t\tconst currentLocation = window.location + \"\"\n\t\tif(currentLocation === this.lastKnownLocation){\n\t\t\treturn false\n\t\t}\n\t\tthis.lastKnownLocation = currentLocation\n\t\tfor(const handler of this.handlers){\n\t\t\thandler()\n\t\t}\n\t\treturn true\n\t}\n\n}\n\nexport const historyUpdateWatcher = new HistoryUpdateWatcher()","import {WBox, box} from \"@nartallax/cardboard\"\nimport {DomBoxOptionsBase, bindBoxToDomValue} from \"src/box_dom_binding/bind_box_to_dom\"\nimport {DomValueLink} from \"src/box_dom_binding/dom_value_link\"\nimport {historyUpdateWatcher} from \"src/monkeypatching/history_monkeypatching\"\n\nexport type UrlOptions = DomBoxOptionsBase & {\n\treadonly type: \"url\"\n\treadonly path?: boolean\n\treadonly search?: boolean\n\treadonly hash?: boolean\n\treadonly history?: \"replace\" | \"push\"\n}\n\nexport class UrlBoxDomLink extends DomValueLink<string, string, UrlOptions> {\n\n\tprotected getRawDomValue(): string {\n\t\treturn window.location + \"\"\n\t}\n\n\tprotected parseDomValue(raw: string): string {\n\t\tconst url = new URL(raw)\n\n\t\tlet result = \"\"\n\t\tif(this.options.path){\n\t\t\tresult += url.pathname\n\t\t}\n\t\tif(this.options.search){\n\t\t\tresult += url.search\n\t\t}\n\t\tif(this.options.hash){\n\t\t\tresult += url.hash\n\t\t}\n\n\t\treturn result\n\t}\n\n\tprotected updateDomValue(value: string): void {\n\t\tconst url = new URL(value, window.location + \"\")\n\n\t\t// we won't overwrite existing search/path if this is not explicitly enabled\n\t\t// even if user puts something that resembles search/path\n\t\tif(!this.options.search){\n\t\t\turl.search = window.location.search\n\t\t}\n\t\tif(!this.options.path){\n\t\t\turl.pathname = window.location.pathname\n\t\t}\n\t\tif(!this.options.hash){\n\t\t\turl.hash = window.location.hash\n\t\t}\n\n\t\tif(url + \"\" === window.location + \"\"){\n\t\t\treturn\n\t\t}\n\n\t\tif((this.options.history ?? \"replace\") === \"replace\"){\n\t\t\twindow.history.replaceState(null, \"\", url)\n\t\t} else {\n\t\t\twindow.history.pushState(null, \"\", url)\n\t\t}\n\t}\n\n\tprotected subscribeToDomValue(): void {\n\t\tconst handler = this.updateBoxValueBound\n\n\t\thistoryUpdateWatcher.subscribe(handler)\n\n\t\tif(this.options.hash){\n\t\t\t// setting url through window.location.hash = \"#123\" won't trigger history api\n\t\t\twindow.addEventListener(\"hashchange\", handler)\n\t\t}\n\t}\n\n\tprotected unsubscribeFromDomValue(): void {\n\t\tconst handler = this.updateBoxValueBound\n\n\t\thistoryUpdateWatcher.unsubscribe(handler)\n\n\t\tif(this.options.hash){\n\t\t\twindow.removeEventListener(\"hashchange\", handler)\n\t\t}\n\t}\n\n}\n\n/** Create a writable box linked to some part of page URL.\n * History API is used to manipulate the URL.\n *\n * If some part of the URL is present in the page, but not enabled in the box options - it will stay as-is when URL is updated. */\nexport function urlBox(node: Node, options: Omit<UrlOptions, \"type\" | \"preferOriginalValue\">): WBox<string> {\n\tconst result = box(\"\")\n\tbindBoxToDomValue(node, result, {...options, type: \"url\"})\n\treturn result\n}","import {BoxChangeHandler, BoxUpdateMeta, RBox} from \"@nartallax/cardboard\"\nimport {DomBoxOptionsBase} from \"src/box_dom_binding/bind_box_to_dom\"\nimport {DomValueLink} from \"src/box_dom_binding/dom_value_link\"\n\nconst noValue = Symbol(\"cardboard-dom-binder-no-value\")\ntype NoValue = typeof noValue\n\ninterface WatchedBox<T = unknown>{\n\treadonly box: RBox<T>\n\thandler: BoxChangeHandler<T>\n\treadonly handlerWrap: BoxChangeHandler<T>\n\tlastKnownValue: T | NoValue\n}\n\n// for tests\nexport let mismatchedNodesErrorCount = 0\n\n/** Binder is a way to access various lifecycle events of DOM nodes\n * Through that it can help with subscription to various stuff like boxes */\nexport class Binder {\n\tprivate beforeInsertedHandlers: null | (() => void)[] = null\n\tprivate afterInsertedHandlers: null | (() => void)[] = null\n\tprivate removedHandlers: null | (() => void)[] = null\n\tprivate watchedBoxes: null | WatchedBox[] = null\n\t// those are here only for unsubscribing\n\tprivate domValueLinks: null | DomValueLink<unknown>[] = null\n\tisInDom: boolean\n\tprivate isExpectingInsertion = false\n\n\tconstructor(readonly node: Node) {\n\t\tthis.isInDom = node.isConnected\n\t}\n\n\tonInserted(handler: () => void, before?: boolean): void {\n\t\tif(before){\n\t\t\t(this.beforeInsertedHandlers ||= []).push(handler)\n\t\t} else {\n\t\t\t(this.afterInsertedHandlers ||= []).push(handler)\n\t\t}\n\t}\n\n\tonRemoved(handler: () => void): void {\n\t\t(this.removedHandlers ||= []).push(handler)\n\t}\n\n\toffInserted(handler: () => void, before?: boolean): void {\n\t\tif(before){\n\t\t\tthis.beforeInsertedHandlers = dropItemFromArray(this.beforeInsertedHandlers, handler)\n\t\t} else {\n\t\t\tthis.afterInsertedHandlers = dropItemFromArray(this.afterInsertedHandlers, handler)\n\t\t}\n\t}\n\n\toffRemoved(handler: () => void): void {\n\t\tthis.removedHandlers = dropItemFromArray(this.removedHandlers, handler)\n\t}\n\n\tnotifyBeforeInserted(): void {\n\t\tif(this.isInDom){\n\t\t\treturn\n\t\t}\n\t\t// console.log(\"beforeInserted\", this.node)\n\t\tthis.isInDom = true\n\t\tthis.isExpectingInsertion = true\n\t\tconst boxes = this.watchedBoxes\n\t\tif(boxes){\n\t\t\tfor(let i = 0; i < boxes.length; i++){\n\t\t\t\tconst boxWrap = boxes[i]!\n\t\t\t\tconst value = boxWrap.box.get()\n\t\t\t\tboxWrap.box.subscribe(boxWrap.handlerWrap)\n\t\t\t\tif(boxWrap.lastKnownValue !== value){\n\t\t\t\t\tthis.invokeBoxHandler(value, boxWrap, undefined)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfireAll(this.beforeInsertedHandlers)\n\t}\n\n\tnotifyAfterInserted(): void {\n\t\tif(!this.isExpectingInsertion){\n\t\t\treturn\n\t\t}\n\t\tthis.isExpectingInsertion = false\n\t\t// console.log(\"afterinserted\", this.node)\n\t\tfireAll(this.afterInsertedHandlers)\n\t}\n\n\tnotifyAfterRemoved(): void {\n\t\tif(!this.isInDom){\n\t\t\treturn\n\t\t}\n\t\tthis.isInDom = false\n\t\tthis.isExpectingInsertion = false // in case of some weird tree manipulations\n\t\t// console.log(\"removed\", this.node)\n\t\tconst boxes = this.watchedBoxes\n\t\tif(boxes){\n\t\t\tfor(let i = 0; i < boxes.length; i++){\n\t\t\t\tconst box = boxes[i]!\n\t\t\t\tbox.box.unsubscribe(box.handlerWrap)\n\t\t\t}\n\t\t}\n\n\t\tfireAll(this.removedHandlers)\n\t}\n\n\tnotifyAttachmentState(shouldBeAttached: boolean): void {\n\t\tif(this.isInDom !== shouldBeAttached){\n\t\t\tconsole.error(`A node was ${shouldBeAttached ? \"inserted into\" : \"removed from\"} DOM tree using unexpected method or property. This could result in memory leaks and/or inconsistent state. Please investigate and report an error.`, this.node)\n\t\t\tmismatchedNodesErrorCount++\n\n\t\t\t// this really should be done synchronously\n\t\t\tif(shouldBeAttached){\n\t\t\t\tthis.notifyBeforeInserted()\n\t\t\t} else {\n\t\t\t\tthis.notifyAfterRemoved()\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate invokeBoxHandler<T>(value: T, box: WatchedBox<T>, meta: BoxUpdateMeta | undefined): void {\n\t\tbox.handler(value, box.box, meta)\n\t\tbox.lastKnownValue = value\n\t}\n\n\tprivate subscribe<T>(box: RBox<T>, handler: BoxChangeHandler<T>, assumeRunning?: boolean): WatchedBox<T> {\n\t\tconst boxWrap: WatchedBox<T> = {\n\t\t\tbox,\n\t\t\thandler,\n\t\t\tlastKnownValue: assumeRunning ? box.get() : noValue,\n\t\t\t// wonder if creating a handler wrapper is more performant than storing lastKnownValue and handler in map\n\t\t\thandlerWrap: (v, _, meta) => this.invokeBoxHandler(v, boxWrap, meta)\n\t\t}\n\t\tif(this.isInDom){\n\t\t\tboxWrap.box.subscribe(boxWrap.handlerWrap)\n\t\t}\n\t\t(this.watchedBoxes ||= []).push(boxWrap as WatchedBox)\n\t\treturn boxWrap\n\t}\n\n\twatch<T>(box: RBox<T>, handler: BoxChangeHandler<T>, assumeRunning?: boolean): void {\n\t\tthis.subscribe(box, handler, assumeRunning)\n\t}\n\n\twatchAndRun<T>(box: RBox<T>, handler: BoxChangeHandler<T>): void {\n\t\tconst boxWrap = this.subscribe(box, handler)\n\t\tthis.invokeBoxHandler(box.get(), boxWrap, undefined)\n\t}\n\n\tunwatch<T>(handler: (value: T) => void): void {\n\t\tconst filteredBoxes = this.watchedBoxes?.filter(boxWrap => {\n\t\t\tif(boxWrap.handler === handler){\n\t\t\t\tboxWrap.box.unsubscribe(boxWrap.handlerWrap)\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\t\tthis.watchedBoxes = !filteredBoxes || filteredBoxes.length < 0 ? null : filteredBoxes\n\t}\n\n\taddDomValueLink<T>(link: DomValueLink<T>): void {\n\t\t(this.domValueLinks ||= []).push(link as DomValueLink<unknown>)\n\t\tlink.bind(this)\n\t}\n\n\tremoveDomValueLink(options: DomBoxOptionsBase): void {\n\t\tif(!this.domValueLinks){\n\t\t\treturn\n\t\t}\n\n\t\tconst links = this.domValueLinks.filter(link => {\n\t\t\tif(link.options === options){\n\t\t\t\tlink.unbind(this)\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\n\t\tthis.domValueLinks = links.length === 0 ? null : links\n\t}\n\n}\n\n// yeah, not very efficient\n// though in real applications removal of something from watch list is not a frequent operation\n// so, whatever\nfunction dropItemFromArray<T>(arr: T[] | null, item: T): T[] | null {\n\tif(!arr || (arr.length === 1 && arr[0] === item)){\n\t\treturn null\n\t}\n\tconst result = [] as T[]\n\tfor(let i = 0; i < arr.length; i++){\n\t\tconst el = arr[i]!\n\t\tif(el !== item){\n\t\t\tresult.push(el)\n\t\t}\n\t}\n\treturn result\n}\n\nfunction fireAll(handlers: (() => void)[] | null): void {\n\tif(!handlers){\n\t\treturn\n\t}\n\tfor(let i = 0; i < handlers.length; i++){\n\t\thandlers[i]!()\n\t}\n}","/** Monkeypatch DOM methods and properties to synchronously call handlers on insert and remove\n * Exists because MutationObserver is asynchronous, and there's no hope for synchronous version in sight\n *\n * afterRemoveOrInsert is like that because insertion can remove node from DOM if inserting into detached node\n *\n * beforeInsert and afterRemoveOrInsert are called when node potentially could be inserted or removed,\n * and do not guarantee that they actually are.\n * In some cases they'd be wrong; additional checking is required.\n * (also weird stuff could happen in replace-methods and such)\n *\n * Will call handlers only for top-level inserted/removed nodes (i.e. won't iterate their children to call handlers)\n * Won't call beforeInsert in case of nodes created on-fly when HTML text is changed\n * (by innerHTML, outerHTML, setHTML(), and other methods that accept strings in place of nodes) */\nexport function monkeyPatchDomForInsertRemove(beforeInsert: (node: Node, parent: Node) => void, afterRemoveOrInsert: (node: Node) => void): void {\n\n\tknownPatchedFunctions = new Set()\n\n\tconst beforeInsertIfNode = (x: unknown, parent: Node) => {\n\t\tif(x instanceof Node){\n\t\t\tbeforeInsert(x, parent)\n\t\t}\n\t}\n\n\tconst onNodeListAttaching = (original: any) => function(this: Node, ...args: unknown[]): void {\n\t\tfor(let i = 0; i < args.length; i++){\n\t\t\tbeforeInsertIfNode(args[i]!, this)\n\t\t}\n\t\tconst result = original.apply(this, args)\n\t\tfor(let i = 0; i < args.length; i++){\n\t\t\tconst child = args[i]\n\t\t\tif(child instanceof Node){\n\t\t\t\tafterRemoveOrInsert(child)\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n\n\tconst onSingleNodeInsert = (original: any) => function(this: Node, ...args: any[]): any {\n\t\tbeforeInsert(args[0]!, this)\n\t\tconst result = original.apply(this, args)\n\t\tafterRemoveOrInsert(args[0]!)\n\t\treturn result\n\t}\n\n\tmonkeyPatchMethod(\"insertBefore\", onSingleNodeInsert)\n\tmonkeyPatchMethod(\"after\", onSingleNodeInsert)\n\tmonkeyPatchMethod(\"before\", onSingleNodeInsert)\n\tmonkeyPatchMethod(\"appendChild\", onSingleNodeInsert)\n\tmonkeyPatchMethod(\"append\", onNodeListAttaching)\n\tmonkeyPatchMethod(\"prepend\", onNodeListAttaching)\n\tmonkeyPatchMethod(\"insertAdjacentElement\", original => function(this: Node, ...args: any[]) {\n\t\tbeforeInsert(args[1]!, this)\n\t\tconst result = original.apply(this, args)\n\t\tafterRemoveOrInsert(args[1]!)\n\t\treturn result\n\t})\n\t// there's also insertAdjacentText and insertAdjacentHTML\n\t// but for purposes of this library I don't need to do anything about them\n\n\tmonkeyPatchMethodAfter(\"removeChild\", afterRemoveOrInsert)\n\tmonkeyPatchMethodAfter(\"remove\", function(this: Element) {\n\t\tafterRemoveOrInsert(this)\n\t})\n\n\tmonkeyPatchMethod(\"replaceChild\", original => function(this: Node, ...args: Node[]) {\n\t\tbeforeInsert(args[0]!, this)\n\t\tconst result = original.apply(this, args)\n\t\tafterRemoveOrInsert(args[1]!)\n\t\tafterRemoveOrInsert(args[0]!)\n\t\treturn result\n\t})\n\n\tmonkeyPatchMethod(\"replaceChildren\", original => function(this: Element, ...args: any[]): any {\n\t\tconst oldChildren = copyArrayLike(this.childNodes)\n\t\tfor(let i = 0; i < args.length; i++){\n\t\t\tbeforeInsertIfNode(args[i], this)\n\t\t}\n\t\tconst result = original.apply(this, args)\n\t\tfor(let i = 0; i < oldChildren.length; i++){\n\t\t\tafterRemoveOrInsert(oldChildren[i]!)\n\t\t}\n\t\tfor(let i = 0; i < args.length; i++){\n\t\t\tconst arg = args[i]!\n\t\t\tif(arg instanceof Node){\n\t\t\t\tafterRemoveOrInsert(arg)\n\t\t\t}\n\t\t}\n\t\treturn result\n\t})\n\n\tmonkeyPatchMethod(\"replaceWith\", original => function(this: Element, ...args: any[]): any {\n\t\tfor(let i = 0; i < args.length; i++){\n\t\t\tbeforeInsertIfNode(args[i], this)\n\t\t}\n\t\tconst result = original.apply(this, args)\n\t\tafterRemoveOrInsert(this)\n\t\tfor(let i = 0; i < args.length; i++){\n\t\t\tconst arg = args[i]!\n\t\t\tif(arg instanceof Node){\n\t\t\t\tafterRemoveOrInsert(arg)\n\t\t\t}\n\t\t}\n\t\treturn result\n\t})\n\n\tmonkeyPatchMethod(\"setHTML\", original => function(this: Element, ...args: any[]): any {\n\t\tconst oldChildren = copyArrayLike(this.childNodes)\n\t\tconst result = original.apply(this, args)\n\t\tfor(let i = 0; i < oldChildren.length; i++){\n\t\t\tafterRemoveOrInsert(oldChildren[i]!)\n\t\t}\n\t\treturn result\n\t})\n\n\tmonkeyPatchSetter(\"innerHTML\", original => function(this: Element, ...args: any[]) {\n\t\tconst oldChildren = copyArrayLike(this.childNodes)\n\t\t// here we can't call beforeInsert, because there are no elements before insert, they are created in process\n\t\t// but for use-case of this library it's fine\n\t\t// it will never need freshly-created elements anyway, because no handles can exist for them yet\n\t\t// (the same goes for other html-changing methods and props)\n\t\tconst result = original.apply(this, args as any)\n\t\tfor(let i = 0; i < oldChildren.length; i++){\n\t\t\tafterRemoveOrInsert(oldChildren[i]!)\n\t\t}\n\t\treturn result\n\t})\n\n\tmonkeyPatchSetter(\"outerHTML\", original => function(this: Element, ...args: any[]) {\n\t\tconst result = original.apply(this, args as any)\n\t\tafterRemoveOrInsert(this)\n\t\treturn result\n\t})\n\n\tmonkeyPatchSetter(\"textContent\", original => function(this: Element, ...args: any[]) {\n\t\tconst oldChildren = copyArrayLike(this.childNodes)\n\t\tconst result = original.apply(this, args as any)\n\t\tfor(let i = 0; i < oldChildren.length; i++){\n\t\t\tafterRemoveOrInsert(oldChildren[i]!)\n\t\t}\n\t\treturn result\n\t})\n\n\tknownPatchedFunctions = null\n\n}\n\n/** Those are all classes we potentially may want to patch\n * this file is organized that way because I'm afraid that some browsers will define some methods/properties in non-standard way\n * for now it's mostly in the past, but a nice robustness touch anyway */\nconst patchableClasses = [Node, Element, HTMLElement, SVGElement]\n\nlet knownPatchedFunctions: Set<any> | null = null\n\nfunction copyArrayLike<T>(src: ArrayLike<T>): T[] {\n\tconst result: T[] = new Array(src.length)\n\tfor(let i = 0; i < src.length; i++){\n\t\tresult[i] = src[i]!\n\t}\n\treturn result\n}\n\nfunction monkeyPatchMethodAfter(name: string, patch: (...args: any) => void): void {\n\tmonkeyPatchMethod(name, original => function(this: any, ...args: any[]): any {\n\t\tconst result = original.apply(this, args)\n\t\tpatch.apply(this, args as any)\n\t\treturn result\n\t})\n}\n\nfunction monkeyPatchMethod(\n\tname: string, makePatch: (original: any) => any\n): void {\n\tfor(const cls of patchableClasses){\n\t\tconst original = (cls.prototype as any)[name]\n\t\tif(typeof(original) !== \"function\" || knownPatchedFunctions?.has(original)){\n\t\t\tcontinue\n\t\t}\n\t\ttry {\n\t\t\tconst patchedMethod = makePatch(original)\n\t\t\tknownPatchedFunctions?.add(patchedMethod);\n\t\t\t// for testing purposes\n\t\t\t(patchedMethod as any).originalNonPatchedMethod = original;\n\t\t\t(cls.prototype as any)[name] = patchedMethod\n\t\t} catch(e){\n\t\t\tconsole.error(\"Failed to monkeypatch \" + name + \" method on \" + cls.name + \": \" + e)\n\t\t}\n\t}\n\n}\n\nfunction monkeyPatchSetter(name: string, makePatch: (original: any) => any): void {\n\tfor(const cls of patchableClasses){\n\t\ttry {\n\t\t\tconst originalProp = Object.getOwnPropertyDescriptor(cls.prototype, name)\n\t\t\tif(!originalProp || typeof(originalProp.set) !== \"function\" || knownPatchedFunctions?.has(originalProp.set)){\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tconst patchedSetter = makePatch(originalProp.set)\n\t\t\tknownPatchedFunctions?.add(patchedSetter)\n\t\t\tObject.defineProperty(cls.prototype, name, {\n\t\t\t\t...originalProp,\n\t\t\t\tset: patchedSetter\n\t\t\t})\n\t\t} catch(e){\n\t\t\tconsole.error(\"Failed to monkeypatch \" + name + \" property on \" + cls.name + \": \" + e)\n\t\t}\n\t}\n}","/** This class holds expected tree structure after all insert-handlers are invoked\n * We can't use just DOM tree for this purpose, because we need to run handlers before it is modified\n * And sometimes it leads to removal of children, and it can get complicated, resulting in some handlers not being invoked */\nexport class ProjectedTreeState {\n\n\tprivate readonly nodesInTree: Set<Node> = new Set()\n\tprivate ongoingInsertOperationsCount = 0\n\n\tstartInsertOperation(node: Node): void {\n\t\tthis.ongoingInsertOperationsCount++\n\t\tthis.markNodeInserted(node)\n\t}\n\n\tendInsertOperation(): void {\n\t\tthis.ongoingInsertOperationsCount--\n\t\tif(this.ongoingInsertOperationsCount === 0){\n\t\t\tthis.nodesInTree.clear()\n\t\t}\n\t}\n\n\tmarkNodeInserted(node: Node): void {\n\t\t// no early-exit here\n\t\t// previous operation could remove part of subtree, so we need to put it back\n\t\tthis.nodesInTree.add(node)\n\t\tfor(let i = 0; i < node.childNodes.length; i++){\n\t\t\tthis.markNodeInserted(node.childNodes[i]!)\n\t\t}\n\t}\n\n\tmarkNodeRemoved(node: Node): void {\n\t\t// again, no early-exit here, for same reason as insert\n\t\tthis.nodesInTree.delete(node)\n\n\t\tfor(let i = 0; i < node.childNodes.length; i++){\n\t\t\tthis.markNodeRemoved(node.childNodes[i]!)\n\t\t}\n\t}\n\n\tisInserted(node: Node): boolean {\n\t\treturn node.isConnected || this.nodesInTree.has(node)\n\t}\n\n}","export type Maybe<E> = E | null | undefined\nexport type MaybeArray<E> = E | readonly E[]\n\n// why is this not in default typings...?\nexport function isArray<T>(a: MaybeArray<T>): a is readonly T[] {\n\treturn Array.isArray(a)\n}","import {BoxChangeHandler, BoxUpdateMeta, MRBox, RBox, Unboxed, constBoxWrap, isConstBox, isRBox, unbox} from \"@nartallax/cardboard\"\nimport {ClassName, bindClassname} from \"src/functions/classname\"\nimport {Maybe, MaybeArray, isArray} from \"src/functions/utils\"\nimport {getBinder} from \"src/node_binding\"\nimport {Binder} from \"src/parts/binder\"\n\ntype NoLeadingOn<T extends `on${string}`> = T extends `on${infer X}` ? Uncapitalize<X> : never\ntype WithLeadingOn<T extends string> = `on${Capitalize<T>}`\ntype EventHandlers<ThisType = unknown> = {\n\treadonly [k in WithLeadingOn<keyof GlobalEventHandlersEventMap>]?: (this: ThisType, evt: GlobalEventHandlersEventMap[NoLeadingOn<k>]) => void\n}\n\nexport type UnboxedTuple<D> = D extends readonly [infer X, ...infer Rest]\n\t? readonly [Unboxed<X>, ...UnboxedTuple<Rest>]\n\t: D extends []\n\t\t? []\n\t\t: D extends readonly MRBox<unknown>[]\n\t\t\t? readonly Unboxed<D[number]>[]\n\t\t\t: never\n\nexport function removeOnPrefix<T extends WithLeadingOn<keyof GlobalEventHandlersEventMap>>(x: T): NoLeadingOn<T> {\n\treturn x.charAt(2).toLowerCase() + x.substring(3) as NoLeadingOn<T>\n}\n\n\ntype CustomEventHandlers<ThisType = unknown> = {\n\treadonly beforeInserted?: (element: ThisType) => void\n\treadonly afterInserted?: (element: ThisType) => void\n\treadonly onRemoved?: (element: ThisType) => void\n}\n\ntype Attributes = {\n\treadonly [attrName: string]: MRBox<string | number | boolean | undefined | null>\n}\n\nexport interface TagDescription<K extends string = string, ThisType = unknown> extends EventHandlers<ThisType>, CustomEventHandlers<ThisType>{\n\treadonly tag?: K\n\treadonly class?: ClassName\n\treadonly attrs?: Attributes\n}\n\ntype NonBoxedSingleChildArrayElement<E> = Maybe<E | string | number | boolean>\nexport type ChildArray<E> = readonly MRBox<MaybeArray<NonBoxedSingleChildArrayElement<E>>>[]\n\nexport function resolveTagCreationArgs<K, E>(a?: K | ChildArray<E>, b?: ChildArray<E>): [K, ChildArray<E> | undefined] {\n\tif(!a){\n\t\treturn [{} as K, b]\n\t} else if(Array.isArray(a)){\n\t\treturn [{} as K, a]\n\t} else {\n\t\treturn [a as K, b]\n\t}\n}\n\nexport function populateTag<K extends string, T, E extends Element>(tagBase: Element, description: TagDescription<K, T>, children: ChildArray<E> | undefined): Binder | null {\n\tlet binder: Binder | null = null\n\n\tif(\"class\" in description){\n\t\tbinder = bindClassname(\n\t\t\tbinder,\n\t\t\ttagBase,\n\t\t\tdescription.class,\n\t\t\t// using classList here because on svg elements .className is readonly (in runtime)\n\t\t\tclassname => tagBase.classList.value = classname\n\t\t) || binder\n\t}\n\n\tif(description.attrs){\n\t\tfor(const k in description.attrs){\n\t\t\tbinder = watchAndRun(binder, tagBase, description.attrs[k]!, v => {\n\t\t\t\tsetAttribute(tagBase, k, v)\n\t\t\t})\n\t\t}\n\t}\n\n\tfor(const k in description){\n\t\tif(k.startsWith(\"on\")){\n\t\t\t// I don't want to construct elaborate solid type here\n\t\t\t// I know the type will be correct, because it is enforced by function parameter type\n\t\t\t// so just be Any and that's it\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst handler = description[k as keyof EventHandlers] as any\n\t\t\tif(k === \"beforeInserted\"){\n\t\t\t\t(binder ||= getBinder(tagBase)).onInserted(handler, true)\n\t\t\t} else if(k === \"afterInserted\"){\n\t\t\t\t(binder ||= getBinder(tagBase)).onInserted(handler, false)\n\t\t\t} else if(k === \"onRemoved\"){\n\t\t\t\t(binder ||= getBinder(tagBase)).onRemoved(handler)\n\t\t\t} else {\n\t\t\t\tconst evtName = removeOnPrefix(k as WithLeadingOn<keyof GlobalEventHandlersEventMap>)\n\t\t\t\ttagBase.addEventListener(evtName, handler, {passive: true, capture: false})\n\t\t\t}\n\t\t}\n\t}\n\n\tif(children){\n\t\tconst updateFn = (_: any, box: RBox<MaybeArray<NonBoxedSingleChildArrayElement<E>>> | undefined, meta: BoxUpdateMeta | undefined) => updateChildren<E>(tagBase, children, box, meta)\n\n\t\tfor(const child of children){\n\t\t\tif(isRBox(child)){\n\t\t\t\t(binder ||= getBinder(tagBase)).watch(child, updateFn, true)\n\t\t\t}\n\t\t}\n\t\tupdateFn(null, undefined, undefined)\n\t}\n\n\treturn binder\n}\n\n// function findChildStartIndex<E>(children: ChildArray<E>, updatedBox: RBox<MaybeArray<NonBoxedSingleChildArrayElement<E>>>): number {\n// \tlet index = 0\n// \tfor(let i = 0; i < children.length; i++){\n// \t\tconst childBox = children[i]!\n// \t\tif(childBox === updatedBox){\n// \t\t\treturn index\n// \t\t}\n// \t\tconst child = unbox(children[i]!)\n// \t\tif(isArray(child)){\n// \t\t\tindex += child.length\n// \t\t} else if(!isEmptyChild(child)){\n// \t\t\tindex++\n// \t\t}\n// \t}\n\n// \tthrow new Error(\"The child box is not element of child array\")\n// }\n\nfunction updateChildren<E extends Element>(parent: Node, children: ChildArray<E>, updatedBox: RBox<MaybeArray<NonBoxedSingleChildArrayElement<E>>> | undefined, meta: BoxUpdateMeta | undefined): void {\n\tif(updatedBox){\n\t\tswitch(meta?.type){\n\t\t\t// we could go on, but other optimizations are quite complex (and more rare)\n\t\t\t// that is, if there will be good cases - I'll add them, but now it's not worth it\n\t\t\tcase \"array_item_update\":{\n\t\t\t\tconst oldValue = meta.oldValue\n\t\t\t\tconst newValue = (updatedBox.get() as NonBoxedSingleChildArrayElement<E>[])[meta.index]!\n\t\t\t\t// Element and not Node here because text nodes should still be updated by parent element\n\t\t\t\tif(oldValue instanceof Element && newValue instanceof Element){\n\t\t\t\t\treturn // it's fully handled alredy\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\n\tlet index = 0\n\tfor(const wrappedChild of children){\n\t\tconst child = unbox(wrappedChild)\n\t\tif(isArray(child)){\n\t\t\tfor(let i = 0; i < child.length; i++){\n\t\t\t\tindex = updateChildAt(parent, child[i]!, index)\n\t\t\t}\n\t\t} else {\n\t\t\tindex = updateChildAt(parent, child, index)\n\t\t}\n\t}\n\n\twhile(parent.childNodes.length > index){\n\t\t// Q: why last child instead of `index`-th?\n\t\t// A: I have a feeling that it's more performant, to pop the last one\n\t\t// no confirmation though\n\t\tparent.removeChild(parent.childNodes[parent.childNodes.length - 1]!)\n\t}\n}\n\nfunction isEmptyChild<E>(child: NonBoxedSingleChildArrayElement<E>): boolean {\n\treturn child === null || child === undefined || child === true || child === false\n}\n\nfunction updateChildAt<E extends Element>(parent: Node, child: NonBoxedSingleChildArrayElement<E>, index: number): number {\n\tif(isEmptyChild(child)){\n\t\treturn index\n\t}\n\n\tlet childNode: Node\n\tif(child instanceof Node){\n\t\tchildNode = child\n\t} else {\n\t\tconst childText = child + \"\"\n\t\tconst existingChildNode = parent.childNodes[index]\n\t\tif(existingChildNode instanceof Text){\n\t\t\texistingChildNode.textContent = childText\n\t\t\treturn index + 1\n\t\t}\n\t\tchildNode = document.createTextNode(childText)\n\t}\n\n\t// why do I have to cast this...? TS is weird here\n\tif(parent.childNodes[index] as Node | undefined === childNode){\n\t\treturn index + 1\n\t}\n\tif(parent.childNodes.length <= index){\n\t\tparent.appendChild(childNode)\n\t} else {\n\t\tparent.insertBefore(childNode, parent.childNodes[index]!)\n\t}\n\treturn index + 1\n}\n\nfunction setAttribute(tagBase: Element, attrName: string, value: Attributes[string]): void {\n\tif(value === false || value === undefined){\n\t\ttagBase.removeAttribute(attrName)\n\t} else if(value === true){\n\t\ttagBase.setAttribute(attrName, attrName)\n\t} else {\n\t\ttagBase.setAttribute(attrName, value + \"\")\n\t}\n}\n\nexport interface BoxHandlerBindingOptions {\n\treadonly dontCallImmediately?: boolean\n}\n\nexport function bindBoxWithHandler<T>(el: Node, box: MRBox<T>, handler: (value: T) => void, opts?: BoxHandlerBindingOptions): void {\n\t(opts?.dontCallImmediately ? watch : watchAndRun)(null, el, box, handler)\n}\n\nexport function unbindBoxWithHandler<T>(el: Node, handler: (value: T) => void): void {\n\tgetBinder(el).unwatch(handler)\n}\n\nfunction watch<T>(binder: Binder | null, node: Node, value: MRBox<T>, handler: (value: T) => void): Binder | null {\n\tif(!isRBox(value) || isConstBox(value)){\n\t\treturn binder\n\t}\n\n\t(binder ||= getBinder(node)).watch(value, handler)\n\treturn binder\n}\n\n// watchAndRun cannot be substituted with just doing the actions and calling watch() with same box and node\n// because watchAndRun will also notify binder about last used value\n// this helps to avoid some weird situations and double-running of the same code\nexport function watchAndRun<T>(binder: Binder | null, node: Node, value: MRBox<T>, handler: BoxChangeHandler<T>): Binder | null {\n\tif(!isRBox(value) || isConstBox(value)){\n\t\thandler(unbox(value), constBoxWrap(value), undefined)\n\t\treturn binder\n\t}\n\n\t(binder ||= getBinder(node)).watchAndRun(value, handler)\n\treturn binder\n}\n\ntype OnMountOptions = {\n\t/** If true, will invoke handler before node is in DOM, not after\n\t * DOM manipulations should be avoided if this option is enabled,\n\t * because it may lead to unexpected behaviour */\n\treadonly beforeInserted?: boolean\n\t/** What to do if the node is already in DOM at the time of `onMount()` call?\n\t * \"throw\" (default) - throw an error. Because most of the time both calling or not calling the handler is unexpected.\n\t * \"nothing\" - don't call the handler\n\t * \"call\" - call the handler */\n\treadonly ifInDom?: \"throw\" | \"nothing\" | \"call\"\n}\n\n/** This function will attach handler to an element, to be called when element is inserted into the DOM.\n * Handler can then return another function, which will be executed when element is removed from the DOM. */\nexport function onMount(el: Element, handler: (() => void) | (() => () => void), options?: OnMountOptions): void {\n\tconst binder = getBinder(el)\n\n\tconst onInserted = () => {\n\t\tconst result = handler()\n\t\tif(typeof(result) === \"function\"){\n\t\t\tconst removeHandler = () => {\n\t\t\t\ttry {\n\t\t\t\t\tresult()\n\t\t\t\t} finally {\n\t\t\t\t\tbinder.offRemoved(removeHandler)\n\t\t\t\t}\n\t\t\t}\n\t\t\tbinder.onRemoved(removeHandler)\n\t\t}\n\t}\n\n\tif(binder.isInDom){\n\t\tswitch(options?.ifInDom ?? \"throw\"){\n\t\t\tcase \"throw\": throw new Error(\"Node is already in DOM, that's unexpected\")\n\t\t\tcase \"call\": onInserted(); break\n\t\t}\n\t}\n\tbinder.onInserted(onInserted, options?.beforeInserted)\n}","import {Binder} from \"src/parts/binder\"\nimport {MRBox, isRBox, unbox} from \"@nartallax/cardboard\"\nimport {getBinder} from \"src/node_binding\"\n\ntype MbArrayRecursive<T> = T | readonly MbArrayRecursive<T>[]\ntype ClassNamePart = MRBox<string | null | undefined> | Record<string, MRBox<boolean | undefined>>\nexport type ClassName = MbArrayRecursive<ClassNamePart>\n\nfunction flattenRecursive<T>(value: MbArrayRecursive<T>, result: T[] = []): T[] {\n\tif(Array.isArray(value)){\n\t\tfor(const item of value){\n\t\t\tflattenRecursive(item, result)\n\t\t}\n\t} else {\n\t\tresult.push(value as T)\n\t}\n\treturn result\n}\n\n/** Assemble classname from parts, subscribing to all the boxes, and call the callback */\nexport function bindClassname(binder: Binder | null, node: Node, className: ClassName, callback: (className: string) => void): Binder | null {\n\n\tconst arr = flattenRecursive(className)\n\tfor(const part of arr){\n\t\tif(isRBox(part)){\n\t\t\t(binder ||= getBinder(node)).watch(part, makeClassnameAndCallTheCallback, true)\n\t\t} else if(part && typeof(part) === \"object\"){\n\t\t\tfor(const key in part){\n\t\t\t\tconst bool = part[key]\n\t\t\t\tif(isRBox(bool)){\n\t\t\t\t\t(binder ||= getBinder(node)).watch(bool, makeClassnameAndCallTheCallback, true)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmakeClassnameAndCallTheCallback()\n\n\tfunction makeClassnameAndCallTheCallback() {\n\t\tconst result = []\n\t\tfor(const part of arr){\n\t\t\tif(part && typeof(part) === \"object\" && !isRBox(part)){\n\t\t\t\tfor(const classname in part){\n\t\t\t\t\tif(unbox(part[classname])){\n\t\t\t\t\t\tresult.push(classname)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst classname = unbox(part)\n\t\t\t\tif(classname){\n\t\t\t\t\tresult.push(classname)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcallback(result.join(\" \"))\n\t}\n\n\treturn binder\n}","import {Binder} from \"src/parts/binder\"\nimport {AsyncMutationWatcher} from \"src/parts/async_mutation_watcher\"\nimport {SyncMutationWatcher} from \"src/parts/sync_mutation_watcher\"\nimport {MRBox} from \"@nartallax/cardboard\"\nimport {BoxHandlerBindingOptions, bindBoxWithHandler, unbindBoxWithHandler} from \"src/functions/base_tag\"\nimport {DomBoxBindingOptions, bindBoxToDomValue, unbindBoxToDom} from \"src/box_dom_binding/bind_box_to_dom\"\nimport {MaybeArray, isArray} from \"src/functions/utils\"\n\nconst binders = new WeakMap<Node, Binder>()\nconst asyncWatcher = new AsyncMutationWatcher(binders)\nconst syncWatcher = new SyncMutationWatcher(binders)\n\n/** This function allows to stop debug observer from working\n * Debug observer only exists to warn you about improper DOM manipulations;\n * if there are none, it's safe to turn off to reclaim some performance. */\nexport const shutdownDebugObserver = () => asyncWatcher.shutdown()\n\n/** Initialize DOM bindings.\n *\n * This function must be called before any DOM manipulations, otherwise things can go wrong.\n * It won't do harm to call it more than once, if you're uncertain if you did that already or not. */\nexport const initializeCardboardDom = async(): Promise<void> => {\n\t// this function is async for futureproofing\n\tasyncWatcher.init()\n\tsyncWatcher.init()\n\t/* Explaination about this function:\n\tv8 (and maybe other engines, untested), when calling a method, will resolve implementation first, and then arguments\n\tthis is fine 99.9% of the time, but that will lead to unexpected results if the argument is a call and it changes the method\n\tIn other words,\n\n\t\tlet button = patchAppendAndMakeButton()\n\t\tdocument.body.append(button)\n\n\twill call patched method, but\n\n\t\tdocument.body.append(patchAppendAndMakeButton())\n\n\twill call original one.\n\tTo avoid this weird effect, this init function exists. */\n}\n\nexport const getBinder = (node: Node): Binder => {\n\tif(!syncWatcher.isInitialized()){\n\t\tthrow new Error(\"Cardboard DOM is not initialized! You need to call initializeCardboardDom() first.\")\n\t}\n\tlet binder = binders.get(node)\n\tif(!binder){\n\t\tbinder = new Binder(node)\n\t\tbinders.set(node, binder)\n\t}\n\treturn binder\n}\n\n/** This function is a way to subscribe to arbitrary box without making memory leak\n * Subscriptions will only be called when the component is in the DOM\n * (with the only exception being first immediate call, which will happen regardless of mount state) */\nexport function bindBox<T>(node: Node, box: MaybeArray<MRBox<T>>, handler: (value: T) => void, opts?: BoxHandlerBindingOptions): void\n/** This function is a way to link arbitrary box to some of well-known DOM values,\n * like URL parts or local storage values\n *\n * In case there's API for receiving updates for the value and the box is wbox,\n * the box will receive updates from DOM.\n * Otherwise only the DOM value will be updated by box's value. */\nexport function bindBox<T>(node: Node, box: MaybeArray<MRBox<T>>, options: DomBoxBindingOptions<T>): void\nexport function bindBox<T>(node: Node, box: MaybeArray<MRBox<T>>, a: DomBoxBindingOptions<T> | ((value: T) => void), b?: BoxHandlerBindingOptions): void {\n\tfor(const bx of isArray(box) ? box : [box]){\n\t\tif(typeof(a) === \"function\"){\n\t\t\tbindBoxWithHandler(node, bx, a, b)\n\t\t} else {\n\t\t\tbindBoxToDomValue(node, bx, a)\n\t\t}\n\t}\n}\n\nexport function unbindBox<T>(node: Node, handler: (value: T) => void): void\nexport function unbindBox<T>(node: Node, options: DomBoxBindingOptions<T>): void\nexport function unbindBox<T>(node: Node, a: DomBoxBindingOptions<T> | ((value: T) => void)): void {\n\tif(typeof(a) === \"function\"){\n\t\tunbindBoxWithHandler(node, a)\n\t} else {\n\t\tunbindBoxToDom(node, a)\n\t}\n}","import {Binder} from \"src/parts/binder\"\n\n/** A wrap around MutationObserver\n * exists to check after monkeypatched DOM nodes\n * (we should emit error if observer's state is not consistent with monkeypatched state) */\nexport class AsyncMutationWatcher {\n\tprivate observer: MutationObserver | null = null\n\n\tconstructor(private readonly binders: WeakMap<Node, Binder>) {}\n\n\tinit(): void {\n\t\tif(!this.observer && typeof(MutationObserver) !== \"undefined\"){\n\t\t\tthis.observer = new MutationObserver(this.doWithRecords.bind(this))\n\t\t\tthis.observer.observe(document.body, {childList: true, subtree: true})\n\t\t}\n\t}\n\n\tshutdown(): void {\n\t\tif(this.observer){\n\t\t\tthis.observer.disconnect()\n\t\t\tthis.observer = null\n\t\t}\n\t}\n\n\tprivate collectEligibleNodesFromArray(nodes: Node[]): Set<Node> {\n\t\tconst result = new Set<Node>()\n\t\tfor(let i = 0; i < nodes.length; i++){\n\t\t\tthis.collectEligibleNodes(nodes[i]!, result)\n\t\t}\n\t\treturn result\n\t}\n\n\tprivate collectEligibleNodes(node: Node, result: Set<Node>): void {\n\t\tif(this.binders.has(node)){\n\t\t\tresult.add(node)\n\t\t}\n\t\tconst children = node.childNodes\n\t\tfor(let i = 0; i < children.length; i++){\n\t\t\tthis.collectEligibleNodes(children[i]!, result)\n\t\t}\n\t}\n\n\tprivate doWithRecords(records: MutationRecord[]): void {\n\t\tconst addedNodesArr = [] as Node[]\n\t\tconst removedNodesArr = [] as Node[]\n\t\tfor(let i = 0; i < records.length; i++){\n\t\t\tconst record = records[i]!\n\t\t\tfor(let j = 0; j < record.addedNodes.length; j++){\n\t\t\t\taddedNodesArr.push(record.addedNodes[j]!)\n\t\t\t}\n\t\t\tfor(let j = 0; j < record.removedNodes.length; j++){\n\t\t\t\tremovedNodesArr.push(record.removedNodes[j]!)\n\t\t\t}\n\t\t}\n\n\t\tconst addedNodes = this.collectEligibleNodesFromArray(addedNodesArr)\n\t\tconst removedNodes = this.collectEligibleNodesFromArray(removedNodesArr)\n\n\t\tfor(const node of addedNodes){\n\t\t\tif(removedNodes.has(node)){\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tthis.binders.get(node)!.notifyAttachmentState(true)\n\t\t}\n\n\t\tfor(const node of removedNodes){\n\t\t\tif(addedNodes.has(node)){\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tthis.binders.get(node)!.notifyAttachmentState(false)\n\t\t}\n\t}\n}","import {Binder} from \"src/parts/binder\"\nimport {monkeyPatchDomForInsertRemove} from \"src/monkeypatching/dom_monkeypatching\"\nimport {ProjectedTreeState} from \"src/parts/projected_tree_state\"\n\nexport class SyncMutationWatcher {\n\n\tprivate isInit = false\n\tprivate readonly projectedTreeState = new ProjectedTreeState()\n\n\tconstructor(readonly binders: WeakMap<Node, Binder>) {}\n\n\tisInitialized(): boolean {\n\t\treturn this.isInit\n\t}\n\n\tinit(): void {\n\t\tif(!this.isInit){\n\t\t\tthis.isInit = true\n\t\t\tmonkeyPatchDomForInsertRemove(\n\t\t\t\tthis.beforeInserted.bind(this),\n\t\t\t\tthis.afterRemovedOrInserted.bind(this)\n\t\t\t)\n\t\t}\n\t}\n\n\tprivate collectBinders(node: Node, result: Binder[] = []): Binder[] {\n\t\tconst binder = this.binders.get(node)\n\t\tif(binder){\n\t\t\tresult.push(binder)\n\t\t}\n\t\tfor(let i = 0; i < node.childNodes.length; i++){\n\t\t\tthis.collectBinders(node.childNodes[i]!, result)\n\t\t}\n\t\treturn result\n\t}\n\n\tprivate beforeInserted(node: Node, parent: Node): void {\n\t\tif(!this.projectedTreeState.isInserted(parent)){\n\t\t\treturn\n\t\t}\n\n\t\tthis.projectedTreeState.startInsertOperation(node)\n\t\t// console.log(\"startInsertOperation\", node)\n\t\ttry {\n\t\t\tconst binders = this.collectBinders(node)\n\t\t\tfor(let i = 0; (i < binders.length); i++){\n\t\t\t\tconst binder = binders[i]!\n\t\t\t\tif(this.projectedTreeState.isInserted(binder.node)){\n\t\t\t\t\tbinder.notifyBeforeInserted()\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.projectedTreeState.endInsertOperation()\n\t\t}\n\t}\n\n\tprivate afterRemovedOrInserted(node: Node): void {\n\t\tif(!node.parentNode){\n\t\t\t// we can't rely on .isConnected here\n\t\t\t// because even if it is inserted, it may be not connected\n\t\t\t// because parent is not in the DOM yet\n\t\t\t// so, to see intent - if the node is removed or inserted somewhere - we can check .parentNode\n\t\t\tthis.projectedTreeState.markNodeRemoved(node)\n\t\t}\n\n\t\tconst binders = this.collectBinders(node)\n\t\tfor(let i = 0; i < binders.length; i++){\n\t\t\tconst binder = binders[i]!\n\t\t\tif(binder.node.isConnected){\n\t\t\t\tbinder.notifyAfterInserted()\n\t\t\t} else {\n\t\t\t\t// console.log([...(this.projectedTreeState as any).nodesInTree])\n\t\t\t\tif(this.projectedTreeState.isInserted(binder.node)){\n\t\t\t\t\tcontinue // we'll call notify on this node after its parent is fully inserted\n\t\t\t\t}\n\t\t\t\tbinder.notifyAfterRemoved()\n\t\t\t}\n\t\t}\n\t}\n\n}","import {MRBox, RBox, constBoxWrap} from \"@nartallax/cardboard\"\nimport {CssVariableBoxLink, CssVariableBoxOptions} from \"src/box_dom_binding/css_variable_box\"\nimport {DomValueLink} from \"src/box_dom_binding/dom_value_link\"\nimport {LocalStorageBoxOptions, LocalStorageDomLink} from \"src/box_dom_binding/local_storage_box\"\nimport {UrlBoxDomLink, UrlOptions} from \"src/box_dom_binding/url_box\"\nimport {getBinder} from \"src/node_binding\"\n\nexport type DomBoxOptionsBase = {\n\t/** This flag is used when resolving conflicts between DOM value and box value\n\t * like, \"we have new box value and new DOM value, what should happen?\"\n\t * If the flag is false (default) - that means box value will be overwritten by DOM value\n\t * If the flag is true - DOM value will be overwritten\n\t * ...or you can just pass an RBox, which cannot be overwritten and will always have preference */\n\treadonly preferBoxValue?: boolean\n}\n\nexport type DomBoxBindingOptions<T> = (LocalStorageBoxOptions<T> | CssVariableBoxOptions | (string extends T ? UrlOptions : never))\n\nexport function bindBoxToDomValue<T>(node: Node, box: MRBox<T>, options: DomBoxBindingOptions<T>): void {\n\tconst wrappedBox = constBoxWrap(box)\n\tconst binder = getBinder(node)\n\tlet link: DomValueLink<T>\n\tswitch(options.type){\n\t\tcase \"localStorage\": link = new LocalStorageDomLink(wrappedBox, options); break\n\t\tcase \"cssVariable\": link = new CssVariableBoxLink(node, wrappedBox, options); break\n\t\tcase \"url\": link = new UrlBoxDomLink(wrappedBox as RBox<string>, options) as unknown as DomValueLink<T>; break\n\t}\n\tbinder.addDomValueLink(link)\n}\n\nexport function unbindBoxToDom<T>(node: Node, options: DomBoxBindingOptions<T>): void {\n\tgetBinder(node).removeDomValueLink(options)\n}","import {WBox, box} from \"@nartallax/cardboard\"\nimport {DomBoxOptionsBase, bindBoxToDomValue} from \"src/box_dom_binding/bind_box_to_dom\"\nimport {DomValueLink} from \"src/box_dom_binding/dom_value_link\"\n\nexport interface LocalStorageBoxOptions<T> extends DomBoxOptionsBase {\n\treadonly type: \"localStorage\"\n\treadonly key: string\n\treadonly parse: (x: string | null) => T\n\treadonly serialize: (x: T) => string | null\n}\n\nexport class LocalStorageDomLink<T> extends DomValueLink<T, string | null, LocalStorageBoxOptions<T>> {\n\n\tprotected getRawDomValue(): string | null {\n\t\treturn localStorage.getItem(this.options.key)\n\t}\n\n\tprotected updateDomValue(value: T): void {\n\t\tconst key = this.options.key\n\t\tconst serialized = this.options.serialize(value)\n\t\tif(serialized === null){\n\t\t\tlocalStorage.removeItem(key)\n\t\t} else {\n\t\t\tlocalStorage.setItem(key, serialized)\n\t\t}\n\t}\n\n\tprotected parseDomValue(raw: string | null): T {\n\t\treturn this.options.parse(raw)\n\t}\n\n}\n\n/** Create a writable box that is linked to a value in localStorage.\n * initialValue is only used when a key is not present in the localStorage.\n *\n * Value is JSON-serialized for storage. */\nexport function localStorageBox<T>(node: Node, key: string, initialValue: T): WBox<T>\n/** Create a writable box that is linked to a value in localStorage.\n * initialValue is only used when a key is not present in the localStorage.\n *\n * If you chose to pass options - you must pass custom serializer.\n * It is done for the case when preferBoxValue is false, and the value in the local storage is absent;\n * so you must do something about `null` as parser input.\n *\n * This also gives you an opportunity to delete value from local storage by returning `null` from serializer. */\nexport function localStorageBox<T>(node: Node, key: string, initialValue: T, options: Omit<LocalStorageBoxOptions<T>, \"type\" | \"key\">): WBox<T>\nexport function localStorageBox<T>(node: Node, key: string, initialValue: T, options?: Omit<LocalStorageBoxOptions<T>, \"type\" | \"key\">): WBox<T> {\n\tconst result = box(initialValue)\n\tbindBoxToDomValue(node, result, {\n\t\tparse: value => JSON.parse(value + \"\"),\n\t\tserialize: value => JSON.stringify(value),\n\t\tpreferBoxValue: localStorage.getItem(key) === null,\n\t\t...(options || {}),\n\t\tkey,\n\t\ttype: \"localStorage\"\n\t})\n\treturn result\n}","import {MRBox} from \"@nartallax/cardboard\"\nimport {ChildArray, TagDescription, populateTag, resolveTagCreationArgs, watchAndRun} from \"src/functions/base_tag\"\n\ntype IfEquals<X, Y, A, B> =\n    (<T>() => T extends X ? 1 : 2) extends\n    (<T>() => T extends Y ? 1 : 2) ? A : B\ntype WritableKeysOf<T> = {\n\t[P in keyof T]: IfEquals<{[Q in P]: T[P]}, {-readonly [Q in P]: T[P]}, P, never>\n}[keyof T]\ntype WritablePart<T> = Pick<T, WritableKeysOf<T>>\ntype WritableStyles = WritablePart<CSSStyleDeclaration>\n\ntype IsAnyString<X, IfTrue, IfFalse> = string extends X ? IfTrue : IfFalse\ntype StyleValue<K extends keyof WritableStyles> = IsAnyString<CSSStyleDeclaration[K], string | number, CSSStyleDeclaration[K]> | null | undefined\ntype StyleValues = {\n\treadonly [k in keyof WritableStyles]?: MRBox<StyleValue<k>>\n}\n\ninterface HTMLTagDescriptionBase {\n\treadonly style?: StyleValues\n}\n\nexport interface HTMLTagDescription<K extends keyof HTMLElementTagNameMap = keyof HTMLElementTagNameMap> extends HTMLTagDescriptionBase, TagDescription<K, HTMLElementTagNameMap[K]>{}\n\ntype HTMLChild = HTMLElement | SVGElement\nexport type HTMLChildArray = ChildArray<HTMLChild>\n\n/** Create an HTMLElement according to the description. */\nexport function tag(): HTMLDivElement\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(description: HTMLTagDescription<K>): HTMLElementTagNameMap[K]\nexport function tag(children: HTMLChildArray): HTMLDivElement\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(description: HTMLTagDescription<K>, children: HTMLChildArray): HTMLElementTagNameMap[K]\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(a?: HTMLTagDescription<K> | HTMLChildArray, b?: HTMLChildArray): HTMLElementTagNameMap[K] {\n\tconst [description, children] = resolveTagCreationArgs(a, b)\n\n\tconst tagBase = document.createElement(description.tag || \"div\")\n\n\tlet binder = populateTag(tagBase, description, children)\n\n\tif(description.style){\n\t\tfor(const k in description.style){\n\t\t\tconst styleValue = description.style[k]\n\t\t\tbinder = watchAndRun(binder, tagBase, styleValue, v => {\n\t\t\t\tif(v === undefined || v === null){\n\t\t\t\t\ttagBase.style.removeProperty(k)\n\t\t\t\t} else {\n\t\t\t\t\ttagBase.style[k] = v as string // ew\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\treturn tagBase as HTMLElementTagNameMap[K]\n}","import {ChildArray, TagDescription, populateTag, resolveTagCreationArgs} from \"src/functions/base_tag\"\n\nexport type SVGTagDescription<K extends keyof SVGElementTagNameMap = keyof SVGElementTagNameMap> = TagDescription<K, SVGElementTagNameMap[K]>\n\nexport type SVGChildArray = ChildArray<SVGElement>\n\n/** Create an SVGElement according to the description. */\nexport function svgTag(): SVGGElement\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(description: SVGTagDescription<K>): SVGElementTagNameMap[K]\nexport function svgTag(children: SVGChildArray): SVGGElement\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(description: SVGTagDescription<K>, children: SVGChildArray): SVGElementTagNameMap[K]\n\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(a?: SVGTagDescription<K> | SVGChildArray, b?: SVGChildArray): SVGElementTagNameMap[K] {\n\tconst [description, children] = resolveTagCreationArgs(a, b)\n\n\tconst tagBase = document.createElementNS(\"http://www.w3.org/2000/svg\", description.tag || \"g\")\n\n\tif(description.tag === \"svg\"){\n\t\ttagBase.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\")\n\t}\n\n\tpopulateTag(tagBase, description, children)\n\n\treturn tagBase as SVGElementTagNameMap[K]\n}","/** Make a promise that is resolved when the document is in \"interactive\" state or further */\nexport function waitDocumentLoaded(): Promise<void> {\n\treturn new Promise(ok => {\n\t\tconst check = () => {\n\t\t\tif(document.readyState === \"interactive\" || document.readyState === \"complete\"){\n\t\t\t\tdocument.removeEventListener(\"readystatechange\", check, false)\n\t\t\t\tok()\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn false\n\t\t}\n\n\t\tif(check()){\n\t\t\treturn\n\t\t}\n\n\t\tdocument.addEventListener(\"readystatechange\", check, false)\n\t})\n}","import type {BoxInternal, BoxUpdateMeta, CalculatableBox} from \"src/internal\"\n\nexport abstract class BaseDependencyList {\n\n\tabstract updateKnownDependencyValues(): void\n\n\tcalculate<T>(owner: CalculatableBox<T>, changeSourceBox: BoxInternal<unknown> | undefined, meta: BoxUpdateMeta | undefined): void {\n\t\tconst startingRevision = owner.revision\n\t\tconst value = owner.calculate(changeSourceBox, meta)\n\t\tif(owner.revision === startingRevision){\n\t\t\tif(meta?.type === \"recalc_on_get\" && meta.owner === owner){\n\t\t\t\t// meta \"recalc_on_get\" is related to owner box, and can be propagated\n\t\t\t\towner.set(value, changeSourceBox, meta)\n\t\t\t} else {\n\t\t\t\t// all other metas are related to source box, and should not be propagated\n\t\t\t\t// because then subscribers will receive meta for wrong box\n\t\t\t\towner.set(value, changeSourceBox)\n\t\t\t}\n\t\t}\n\n\t\tthis.updateKnownDependencyValues()\n\t}\n}","import {BaseDependencyList, DependencyList, BoxInternal, UpstreamSubscriber, isRBox, unbox, isWBox, RBox} from \"src/internal\"\n\nexport class MultipleDependencyList extends BaseDependencyList implements DependencyList {\n\tprivate readonly boxMap: Map<BoxInternal<unknown>, unknown> = new Map()\n\n\tconstructor(private readonly rawDependencies: readonly (unknown | BoxInternal<unknown>)[]) {\n\t\tsuper()\n\t\tfor(const mbbox of rawDependencies){\n\t\t\tif(isRBox(mbbox)){\n\t\t\t\tthis.boxMap.set(mbbox as BoxInternal<unknown>, mbbox.get())\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateKnownDependencyValues(): void {\n\t\tfor(const box of this.boxMap.keys()){\n\t\t\tthis.boxMap.set(box, box.get())\n\t\t}\n\t}\n\n\tgetDependencyValues(): unknown[] {\n\t\tconst result: unknown[] = new Array(this.rawDependencies.length)\n\t\tfor(let i = 0; i < this.rawDependencies.length; i++){\n\t\t\tresult[i] = unbox(this.rawDependencies[i])\n\t\t}\n\t\treturn result\n\t}\n\n\tsubscribeToDependencies(owner: UpstreamSubscriber): void {\n\t\tfor(const dependency of this.boxMap.keys()){\n\t\t\tdependency.subscribe(owner)\n\t\t}\n\t}\n\n\tunsubscribeFromDependencies(owner: UpstreamSubscriber): void {\n\t\tfor(const dependency of this.boxMap.keys()){\n\t\t\tdependency.unsubscribe(owner)\n\t\t}\n\t}\n\n\tdidDependencyListChange(): boolean {\n\t\tfor(const [box, value] of this.boxMap){\n\t\t\tif(box.get() !== value){\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\tsetDependencyValues(values: unknown[]): void {\n\t\tfor(let i = 0; i < this.rawDependencies.length; i++){\n\t\t\tconst dep = this.rawDependencies[i]!\n\t\t\tconst value = values[i]!\n\t\t\tif(isWBox(dep)){\n\t\t\t\tdep.set(value)\n\t\t\t} else {\n\t\t\t\tconst currentValue = unbox(dep)\n\t\t\t\tif(currentValue !== value){\n\t\t\t\t\tthrow new Error(\"Cannot update value of readonly dependency \" + dep)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tisDependency(box: RBox<unknown>): boolean {\n\t\treturn this.boxMap.has(box as BoxInternal<unknown>)\n\t}\n\n}","import {DependencyList, BoxInternal, UpstreamSubscriber, BaseDependencyList, unbox, isRBox, isWBox, RBox} from \"src/internal\"\n\n/** A dependency list for cases when you have only one dependency */\nexport class SingleDependencyList<T> extends BaseDependencyList implements DependencyList {\n\tprivate lastKnownDependencyValue: T\n\n\tconstructor(\n\t\treadonly dependency: T | BoxInternal<T>) {\n\t\tsuper()\n\t\tthis.lastKnownDependencyValue = unbox(dependency)\n\t}\n\n\tupdateKnownDependencyValues(): void {\n\t\tthis.lastKnownDependencyValue = unbox(this.dependency)\n\t}\n\n\tsubscribeToDependencies(owner: UpstreamSubscriber): void {\n\t\tif(isRBox(this.dependency)){\n\t\t\tthis.dependency.subscribe(owner)\n\t\t}\n\t}\n\n\tunsubscribeFromDependencies(owner: UpstreamSubscriber): void {\n\t\tif(isRBox(this.dependency)){\n\t\t\tthis.dependency.unsubscribe(owner)\n\t\t}\n\t}\n\n\tdidDependencyListChange(): boolean {\n\t\treturn this.lastKnownDependencyValue !== unbox(this.dependency)\n\t}\n\n\tgetDependencyValues(): unknown[] {\n\t\treturn [unbox(this.dependency)]\n\t}\n\n\tsetDependencyValues(values: unknown[]): void {\n\t\tif(isWBox(this.dependency)){\n\t\t\tthis.dependency.set(values[0]! as T)\n\t\t} else {\n\t\t\tconst currentValue = unbox(this.dependency)\n\t\t\tif(currentValue !== values[0]){\n\t\t\t\tthrow new Error(\"Cannot update value of readonly dependency \" + this.dependency)\n\t\t\t}\n\t\t}\n\t}\n\n\tisDependency(box: RBox<unknown>): boolean {\n\t\treturn box === this.dependency\n\t}\n\n}","import type {BoxChangeHandler, RBox, BoxInternal, UpstreamSubscriber, WBox, BoxUpdateMeta, ArrayItemWBox} from \"src/internal\"\nimport {ArrayContextImpl, MapRBox, MapWBox, PropRBox, PropWBox, isWBox, mapArrayElements, SubscriberList} from \"src/internal\"\n\nexport const NoValue = Symbol(\"AbsentBoxValue\")\n\nexport abstract class BaseBox<T> implements BoxInternal<T> {\n\tvalue: T | typeof NoValue = NoValue\n\tprivate readonly subscriberList = new SubscriberList<T, this>(this)\n\n\thaveSubscribers(): boolean {\n\t\treturn this.subscriberList.haveSubscribers()\n\t}\n\n\t/** Update the value of the box, calling the subscribers.\n\t *\n\t * @param changeSource the box that caused the change. Won't be notified of the change happening. */\n\tset(newValue: T, changeSource?: BoxInternal<unknown> | UpstreamSubscriber, updateMeta?: BoxUpdateMeta): void {\n\t\tif(this.value === newValue){\n\t\t\treturn\n\t\t}\n\n\t\tthis.value = newValue\n\t\tthis.notifyOnValueChange(newValue, changeSource, updateMeta)\n\t}\n\n\tget(): T {\n\t\tif(this.value === NoValue){\n\t\t\tthrow new Error(\"This box is disposed; no value can be get\")\n\t\t}\n\t\treturn this.value\n\t}\n\n\t/** When a box is disposed, it is no longer possible to get or set a value to this box\n\t *\n\t * Use case is situation when some upstream becomes invalid;\n\t * that means setting or getting value of this box is an error\n\t * because it is no longer updated or is able to propagate value to his own upstream\n\t * in this case, every downstream box should also became invalid */\n\tdispose(): void {\n\t\tthis.value = NoValue\n\t\tthis.subscriberList.dispose()\n\t}\n\n\tsubscribe(handler: UpstreamSubscriber | BoxChangeHandler<T>): void {\n\t\tthis.subscriberList.subscribe(handler, this.get())\n\t}\n\n\tunsubscribe(handler: UpstreamSubscriber | BoxChangeHandler<T>): void {\n\t\tthis.subscriberList.unsubscribe(handler)\n\t}\n\n\tprotected notifyOnValueChange(value: T, changeSource: BoxInternal<unknown> | UpstreamSubscriber | undefined, updateMeta: BoxUpdateMeta | undefined): void {\n\t\tthis.subscriberList.callSubscribers(value, changeSource, updateMeta)\n\t}\n\n\tmap<R>(mapper: (value: T, meta: BoxUpdateMeta | undefined) => R): RBox<R>\n\tmap<R>(mapper: (value: T, meta: BoxUpdateMeta | undefined) => R, reverseMapper: (value: R, meta: BoxUpdateMeta | undefined) => T): WBox<R>\n\tmap<R>(mapper: (value: T, meta: BoxUpdateMeta | undefined) => R, reverseMapper?: (value: R, meta: BoxUpdateMeta | undefined) => T): RBox<R> {\n\t\tif(!reverseMapper){\n\t\t\treturn new MapRBox(this, mapper, throwOnReverseMapping)\n\t\t} else {\n\t\t\treturn new MapWBox(this, mapper, reverseMapper)\n\t\t}\n\t}\n\n\tprop<K extends keyof T>(this: RBox<T>, propName: K): RBox<T[K]>\n\tprop<K extends keyof T>(this: WBox<T>, propName: K): WBox<T[K]>\n\tprop<K extends keyof T>(propName: K): WBox<T[K]> | RBox<T[K]> {\n\t\treturn isWBox(this) ? new PropWBox(this, propName) : new PropRBox(this, propName)\n\t}\n\n\tgetArrayContext<E, K>(this: BaseBox<readonly E[]>, getKey: (item: E, index: number) => K): ArrayContextImpl<E, K, null> {\n\t\treturn new ArrayContextImpl(this, getKey, getNull)\n\t}\n\n\tmapArrayElements<E, R>(this: BaseBox<readonly E[]>, mapper: (item: E, index: number) => R): RBox<R[]>\n\tmapArrayElements<E, R>(this: BaseBox<readonly E[]>, mapper: (item: E, index: number) => R, reverseMapper: (item: R, index: number) => E): WBox<R[]>\n\tmapArrayElements<E, R>(this: BaseBox<readonly E[]>, mapper: (item: E, index: number) => R, reverseMapper?: (item: R, index: number) => E): WBox<R[]> | RBox<R[]> {\n\t\treturn mapArrayElements(this, mapper, reverseMapper)\n\t}\n\n\tmapArray<E, K, R>(this: BaseBox<readonly E[]>, getKey: (item: E, index: number) => K, mapBox: (box: ArrayItemWBox<E>, index: number) => R): RBox<readonly R[]> {\n\t\treturn new ArrayContextImpl(this, getKey, mapBox).getValueArrayBox()\n\t}\n\n\tsetProp<K extends keyof T>(propName: K, propValue: T[K]): void {\n\t\tconst oldValue = this.get()\n\t\tif(oldValue[propName] === propValue){\n\t\t\treturn\n\t\t}\n\t\tthis.set({...oldValue, [propName]: propValue}, undefined, {type: \"property_update\", propName})\n\t}\n\n\tsetElementAtIndex<E>(this: BaseBox<readonly E[]>, index: number, value: E): void {\n\t\tconst oldValue = this.get()\n\t\tif(oldValue[index] === value){\n\t\t\treturn\n\t\t}\n\t\tconst oldElementValue = oldValue[index]\n\t\tconst newValue = [...oldValue]\n\t\tnewValue[index] = value\n\t\tthis.set(newValue, undefined, {type: \"array_item_update\", index, oldValue: oldElementValue})\n\t}\n\n\tinsertElementsAtIndex<E>(this: BaseBox<readonly E[]>, index: number, values: readonly E[]): void {\n\t\tif(values.length === 0){\n\t\t\treturn\n\t\t}\n\n\t\tconst oldValue = this.get()\n\t\tthis.checkInsertIndex(oldValue, index)\n\t\tconst newValue = [...oldValue.slice(0, index), ...values, ...oldValue.slice(index)]\n\t\tthis.set(newValue, undefined, {type: \"array_items_insert\", index, count: values.length})\n\t}\n\n\tinsertElementAtIndex<E>(this: BaseBox<readonly E[]>, index: number, value: E): void {\n\t\tthis.insertElementsAtIndex(index, [value])\n\t}\n\n\tappendElement<E>(this: WBox<readonly E[]>, value: E): void {\n\t\tthis.insertElementsAtIndex(this.get().length, [value])\n\t}\n\n\tappendElements<E>(this: WBox<readonly E[]>, values: readonly E[]): void {\n\t\tthis.insertElementsAtIndex(this.get().length, values)\n\t}\n\n\tprependElement<E>(this: WBox<readonly E[]>, value: E): void {\n\t\tthis.insertElementsAtIndex(0, [value])\n\t}\n\n\tprependElements<E>(this: WBox<readonly E[]>, values: readonly E[]): void {\n\t\tthis.insertElementsAtIndex(0, values)\n\t}\n\n\tprivate checkInsertIndex(elements: readonly unknown[], index: number): void {\n\t\tif(index < 0){\n\t\t\tthrow new Error(`Cannot insert anything in negative index (passed index = ${index})`)\n\t\t}\n\n\t\tif(index > elements.length){\n\t\t\tthrow new Error(`Cannot insert anything in index beyond array length (passed index = ${index}, array length = ${elements.length}); this will create sparse array, which is bad in multiple ways and should always be avoided.`)\n\t\t}\n\t}\n\n\tdeleteElementsAtIndex<E>(this: BaseBox<readonly E[]>, index: number, count: number): void {\n\t\tif(count < 1){\n\t\t\treturn\n\t\t}\n\n\t\tconst oldValue = this.get()\n\t\tthis.checkDeleteIndex(oldValue, index)\n\n\t\tcount = Math.min(count, oldValue.length - index)\n\t\tif(count < 1){\n\t\t\t// yes, we are double-checking\n\t\t\t// previous check is useful for the case of user passing zero, and helps us to avoid calling .get()\n\t\t\t// which can be costly, depending on type of the box\n\t\t\treturn\n\t\t}\n\n\t\tconst deletedPairs: {index: number, value: unknown}[] = []\n\t\tfor(let offset = 0; offset < count; offset++){\n\t\t\tconst itemIndex = index + offset\n\t\t\tconst itemValue = oldValue[itemIndex]\n\t\t\tdeletedPairs.push({value: itemValue, index: itemIndex})\n\t\t}\n\n\t\tconst newValue = [...oldValue.slice(0, index), ...oldValue.slice(index + count)]\n\t\tthis.set(newValue, undefined, {type: \"array_items_delete\", indexValuePairs: deletedPairs})\n\t}\n\n\tdeleteElementAtIndex<E>(this: BaseBox<readonly E[]>, index: number): void {\n\t\tthis.deleteElementsAtIndex(index, 1)\n\t}\n\n\tprivate checkDeleteIndex(elements: readonly unknown[], index: number): void {\n\t\tif(index < 0){\n\t\t\tthrow new Error(`Cannot delete element at negative index (passed index = ${index})`)\n\t\t}\n\n\t\tif(index > elements.length - 1){\n\t\t\tthrow new Error(`Cannot delete anything starting from beyond array length (passed index = ${index}, array length = ${elements.length})`)\n\t\t}\n\t}\n\n\tdeleteElements<E>(this: BaseBox<readonly E[]>, predicate: (item: E, index: number) => boolean): void {\n\t\tthis.deleteElementsInternal(predicate, false)\n\t}\n\n\tdeleteElement<E>(this: BaseBox<readonly E[]>, predicate: (item: E, index: number) => boolean): void {\n\t\tthis.deleteElementsInternal(predicate, true)\n\t}\n\n\tprivate deleteElementsInternal<E>(this: BaseBox<readonly E[]>, predicate: (item: E, index: number) => boolean, stopAfterFirst: boolean): void {\n\t\tconst oldValue = this.get()\n\t\tconst deletedPairs: {index: number, value: unknown}[] = []\n\t\tconst newValue: E[] = []\n\t\tfor(let i = 0; i < oldValue.length; i++){\n\t\t\tconst itemValue = oldValue[i]!\n\t\t\tif(predicate(itemValue, i)){\n\t\t\t\tnewValue.push(itemValue)\n\t\t\t} else {\n\t\t\t\tdeletedPairs.push({value: itemValue, index: i})\n\t\t\t\tif(stopAfterFirst){\n\t\t\t\t\tnewValue.push(...oldValue.slice(i + 1))\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(deletedPairs.length === 0){\n\t\t\tif(stopAfterFirst){\n\t\t\t\tthrow new Error(\"Expected to find exactly one element to delete, but found none (predicate = \" + predicate + \")\")\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tthis.set(newValue, undefined, {type: \"array_items_delete\", indexValuePairs: deletedPairs})\n\t}\n\n\tdeleteAllElements<E>(this: BaseBox<readonly E[]>): void {\n\t\tthis.set([], undefined, {type: \"array_items_delete_all\"})\n\t}\n\n}\n\nconst throwOnReverseMapping = () => {\n\tthrow new Error(\"This box does not support reverse-mapping\")\n}\n\nconst getNull = () => null","import {BoxInternal, RBox, WBox} from \"src/types\"\n\nexport function mapArrayElements<E, R>(upstream: BoxInternal<readonly E[]>, mapper: (item: E, index: number) => R, reverseMapper?: (item: R, index: number) => E): RBox<R[]> | WBox<R[]> {\n\tconst forwardCache = new Map<E, R>()\n\tconst backwardCache: Map<R, E> | null = !reverseMapper ? null : new Map()\n\n\tconst forwardMap = (upstreamValues: readonly E[]) => {\n\t\tconst outdatedUpstreamItems = new Set(forwardCache.keys())\n\t\tconst result = upstreamValues.map((upstreamItem, index) => {\n\t\t\toutdatedUpstreamItems.delete(upstreamItem)\n\t\t\tlet downstreamItem = forwardCache.get(upstreamItem)\n\t\t\tif(!downstreamItem){\n\t\t\t\tdownstreamItem = mapper(upstreamItem, index)\n\t\t\t\tforwardCache.set(upstreamItem, downstreamItem)\n\t\t\t\tif(backwardCache){\n\t\t\t\t\tbackwardCache.set(downstreamItem, upstreamItem)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn downstreamItem\n\t\t})\n\t\tif(backwardCache){\n\t\t\tfor(const outdatedItem of outdatedUpstreamItems){\n\t\t\t\tbackwardCache.delete(forwardCache.get(outdatedItem)!)\n\t\t\t}\n\t\t}\n\t\tfor(const outdatedItem of outdatedUpstreamItems){\n\t\t\tforwardCache.delete(outdatedItem)\n\t\t}\n\t\treturn result\n\t}\n\n\tif(!backwardCache || !reverseMapper){\n\t\treturn upstream.map(forwardMap)\n\t}\n\n\tconst backwardMap = (downstreamValues: R[]) => {\n\t\tconst outdatedDownstreamItems = new Set(backwardCache.keys())\n\t\tconst result = downstreamValues.map((downstreamItem, index) => {\n\t\t\toutdatedDownstreamItems.delete(downstreamItem)\n\t\t\tlet upstreamItem = backwardCache.get(downstreamItem)\n\t\t\tif(!upstreamItem){\n\t\t\t\tupstreamItem = reverseMapper(downstreamItem, index)\n\t\t\t\tforwardCache.set(upstreamItem, downstreamItem)\n\t\t\t\tbackwardCache.set(downstreamItem, upstreamItem)\n\t\t\t}\n\t\t\treturn upstreamItem\n\t\t})\n\t\tfor(const outdatedItem of outdatedDownstreamItems){\n\t\t\tforwardCache.delete(backwardCache.get(outdatedItem)!)\n\t\t\tbackwardCache.delete(outdatedItem)\n\t\t}\n\t\treturn result\n\t}\n\treturn upstream.map(forwardMap, backwardMap)\n}\n\n","import {BaseBox, BoxChangeHandler, UpstreamSubscriber} from \"src/internal\"\n\n/** A box that invokes its handlers on first subscriber subscribing/last subscriber unsubscribing */\nexport abstract class FirstSubscriberHandlingBox<T> extends BaseBox<T> {\n\tprotected abstract onFirstSubscriber(): void\n\tprotected abstract onLastUnsubscriber(): void\n\n\toverride subscribe(handler: UpstreamSubscriber | BoxChangeHandler<T>): void {\n\t\tif(!this.haveSubscribers()){\n\t\t\tthis.onFirstSubscriber()\n\t\t}\n\t\tsuper.subscribe(handler)\n\t}\n\n\toverride unsubscribe(handler: UpstreamSubscriber | BoxChangeHandler<T>): void {\n\t\tconst hadSubs = this.haveSubscribers()\n\t\tsuper.unsubscribe(handler)\n\t\t// hadSubs check here because we could already have none subscribers\n\t\t// and we shouldn't invoke handler in this case\n\t\t// this is, of course, an user error, but we don't check for that\n\t\tif(hadSubs && !this.haveSubscribers()){\n\t\t\tthis.onLastUnsubscriber()\n\t\t}\n\t}\n\n}","import {DependencyList, FirstSubscriberHandlingBox, BoxInternal, NoValue, CalculatableBox, BoxUpdateMeta, UpstreamSubscriber} from \"src/internal\"\n\n/** DownstreamBox is a box that is derived from some other box (or several)\n * Those base boxes are called upstream; so this box is downstream box related to the upstream boxes\n *\n * Various downstream boxes can form a network of values, propagated through internal subscribers */\nexport abstract class DownstreamBox<T> extends FirstSubscriberHandlingBox<T> implements CalculatableBox<T> {\n\n\t/** Calculate value of this box based on its internal calculation logic */\n\tabstract calculate(changeSourceBox: BoxInternal<unknown> | undefined, meta: BoxUpdateMeta | undefined): T\n\n\t/** A revision is a counter that is incremented each time the value of the box is changed.\n\t *\n\t * It is very tempting to use revision number to check if value is changed or not.\n\t * However, it can go wrong when value does not change until you explicitly check.\n\t * For example, consider calcBox that depends on another calcBox\n\t * When there is no subscribers, upstream calcBox will never change, regardless of its own upstreams\n\t * And if downstream calcbox only relying on upstream calcbox's revision number to check if it is was changed,\n\t * there will be false negatives, because in this case it is required to check dependencies of upstream calcbox more thorough.\n\t *\n\t * And also value can change back and forth within one calculation, and revision will still be incremented;\n\t * that's why if you rely on revision to check if the value changed you'll get some false-positives.\n\t *\n\t * You can try to use revision to prevent calls of subscribers with outdated value;\n\t * hovewer, it will also have bugs related to early-drops of things that should not be dropped,\n\t * in cases of array contexts (there's a test for that) and partial updates */\n\trevision = 0\n\tforcedShouldRecalculate = false\n\n\tconstructor(readonly dependencyList: DependencyList) {\n\t\tsuper()\n\t}\n\n\t/** Calculate the value, calling the calculation function, and set it to this box.\n\t * This method should be called as handler of internal subscription calls\n\t *\n\t * @param changeSourceBox the box that caused this value to be recalculated. Won't receive update about result. */\n\tprotected calculateAndUpdate(changeSourceBox: BoxInternal<unknown> | undefined, meta: BoxUpdateMeta | undefined): void {\n\t\tthis.forcedShouldRecalculate = false\n\t\tthis.dependencyList.calculate(this, changeSourceBox, meta)\n\t}\n\n\tprotected notifyOnValueChange(value: T, changeSource: UpstreamSubscriber | BoxInternal<unknown> | undefined, updateMeta: BoxUpdateMeta | undefined): void {\n\t\tthis.revision++\n\t\tsuper.notifyOnValueChange(value, changeSource, updateMeta)\n\t}\n\n\tonUpstreamChange(upstream: BoxInternal<unknown>, meta: BoxUpdateMeta | undefined): void {\n\t\tthis.calculateAndUpdate(upstream, meta)\n\t}\n\n\tprotected shouldRecalculate(): boolean {\n\t\tif(this.forcedShouldRecalculate){\n\t\t\treturn true\n\t\t}\n\n\t\tif(this.value === NoValue){\n\t\t\t// we should never show absent value to outside world\n\t\t\t// also NoValue = disposed, and being disposed means that next recalculation will throw\n\t\t\t// and that's a good thing, because it will notify user of error in his code\n\t\t\treturn true\n\t\t}\n\n\t\tif(this.haveSubscribers()){\n\t\t\t// if we have subscribers - we are subscribed to our dependencies\n\t\t\t// that means we recalculate each time a dependency is changed\n\t\t\t// and that means our value is up-to-date and we don't need to recalculate\n\t\t\t// (if we just had first subscriber - we maybe should recalculate, because we didn't have a subscriber before and didn't recalculate since then)\n\t\t\treturn false\n\t\t}\n\n\t\t// this is a little bit bad, because if we have a big \"network\" of calcboxes noone subscribed to,\n\t\t// then each .get() to calcbox will trigger a chain checks for each box in network\n\t\t// which could happen on first render of an app UI, for example\n\t\t// nothing really can be done with it without introducing \"non-update\" bugs\n\t\tif(!this.dependencyList.didDependencyListChange()){\n\t\t\treturn false\n\t\t}\n\n\t\treturn true\n\t}\n\n\trecalculateIfShould(changeSourceBox?: BoxInternal<unknown>, meta?: BoxUpdateMeta): void {\n\t\tif(this.shouldRecalculate()){\n\t\t\tthis.calculateAndUpdate(changeSourceBox, meta)\n\t\t}\n\t}\n\n\toverride set(newValue: T, changeSource?: UpstreamSubscriber | BoxInternal<unknown> | undefined, updateMeta?: BoxUpdateMeta | undefined): void {\n\t\tif(!this.haveSubscribers() && this.shouldRecalculate()){\n\t\t\t// if the box doesn't have any subscribers - it could have outdated value\n\t\t\t// and then on .set() new value may coinside with outdated value\n\t\t\t// which will lead to non-delivery of some updates, if they should be delivered\n\t\t\t// so it's safer to assume that something is changed\n\t\t\t// (we could recalculate, but that's also not great, because it will be called each .set())\n\t\t\tthis.value = NoValue\n\t\t}\n\n\t\treturn super.set(newValue, changeSource, updateMeta)\n\t}\n\n\toverride get(): T {\n\t\tthis.recalculateIfShould(undefined, {type: \"recalc_on_get\", owner: this})\n\t\treturn super.get()\n\t}\n\n\tprotected override onFirstSubscriber(): void {\n\t\tthis.dependencyList.subscribeToDependencies(this)\n\t\tif(this.shouldRecalculate()){\n\t\t\t// something may change while we wasn't subscribed to our dependencies\n\t\t\t// that's why we should recalculate - so our value is actual\n\t\t\tthis.calculateAndUpdate(undefined, undefined)\n\t\t}\n\t}\n\n\tprotected override onLastUnsubscriber(): void {\n\t\tthis.dependencyList.unsubscribeFromDependencies(this)\n\t}\n\n}","import {DownstreamBox, BoxInternal, SingleDependencyList, UpstreamSubscriber, BoxUpdateMeta} from \"src/internal\"\n\n/** A downstream box that has only one upstream */\nexport abstract class SingleDownstreamBox<T, U> extends DownstreamBox<T> {\n\n\tprotected abstract makeDownstreamValue(upstreamValue: U, meta: BoxUpdateMeta | undefined): T\n\tprotected abstract updateUpstreamWith(downstreamValue: T, meta: BoxUpdateMeta | undefined): void\n\n\tconstructor(protected readonly upstream: BoxInternal<U>) {\n\t\tsuper(new SingleDependencyList(upstream))\n\t}\n\n\toverride calculate(_: BoxInternal<unknown> | undefined, meta: BoxUpdateMeta | undefined): T {\n\t\treturn this.makeDownstreamValue(this.upstream.get(), meta)\n\t}\n\n\tprotected override notifyOnValueChange(value: T, changeSource: BoxInternal<unknown> | UpstreamSubscriber | undefined, updateMeta: BoxUpdateMeta | undefined): void {\n\t\tif(changeSource !== this.upstream){\n\t\t\tthis.updateUpstreamWith(value, updateMeta)\n\t\t}\n\t\tsuper.notifyOnValueChange(value, changeSource, updateMeta)\n\t}\n\n\tprotected override calculateAndUpdate(changeSourceBox: BoxInternal<unknown> | undefined, meta: BoxUpdateMeta | undefined): void {\n\t\tif(!changeSourceBox){\n\t\t\t// the only case when we don't have a source box and need to recalculate\n\t\t\t// is when we detect that our value is out of date and needs to be updated\n\t\t\t// and this way our update is triggered by upstream box, in a way, because it was changed\n\t\t\t// we kinda should do it in DownstreamBox, but we cannot, because of its more dynamic nature\n\t\t\t// (that's one of the reasons why only box that can have multiple upstreams is readonly box)\n\t\t\tchangeSourceBox = this.upstream\n\t\t}\n\n\t\tsuper.calculateAndUpdate(changeSourceBox, meta)\n\t}\n}","import {anythingToString, SingleDownstreamBox, BoxInternal, BoxUpdateMeta} from \"src/internal\"\n\nexport abstract class MapBox<T, U> extends SingleDownstreamBox<T, U> {\n\n\tconstructor(\n\t\tupstream: BoxInternal<U>,\n\t\tprotected readonly makeDownstreamValue: (value: U, meta: BoxUpdateMeta | undefined) => T,\n\t\tprotected readonly makeUpstreamValue: (value: T, meta: BoxUpdateMeta | undefined) => U) {\n\t\tsuper(upstream)\n\t}\n\n\ttoString(): string {\n\t\treturn `MapBox(${anythingToString(this.value)})`\n\t}\n\n\tprotected updateUpstreamWith(downstreamValue: T, meta: BoxUpdateMeta | undefined): void {\n\t\tthis.upstream.set(this.makeUpstreamValue(downstreamValue, meta), this)\n\t}\n\n}\n\nexport class MapRBox<T, U> extends MapBox<T, U> {}\nexport class MapWBox<T, U> extends MapBox<T, U> {}","import {anythingToString, SingleDownstreamBox, BoxInternal} from \"src/internal\"\n\nexport abstract class PropBox<U, K extends keyof U> extends SingleDownstreamBox<U[K], U> {\n\n\tconstructor(\n\t\tupstream: BoxInternal<U>,\n\t\treadonly propName: K\n\t) {\n\t\tsuper(upstream)\n\t}\n\n\ttoString(): string {\n\t\treturn `PropBox(${anythingToString(this.value)})`\n\t}\n\n\tprotected override makeDownstreamValue(upstreamValue: U): U[K] {\n\t\treturn upstreamValue[this.propName]\n\t}\n\n\tprotected override updateUpstreamWith(downstreamValue: U[K]): void {\n\t\tconst value: U = {\n\t\t\t...this.upstream.get(),\n\t\t\t[this.propName]: downstreamValue\n\t\t}\n\t\tthis.upstream.set(value, this, {type: \"property_update\", propName: this.propName})\n\t}\n\n}\n\n// there are two classes to distinguish between rbox and wbox in runtime\n// we could always return PropWBox, as each wbox is also a rbox, but that will only protect us on type level\n// that is, in such case isWBox(calcBox(() => ({a:5})).prop(\"a\")) will be true, which is unacceptable\nexport class PropRBox<U, K extends keyof U> extends PropBox<U, K> {}\nexport class PropWBox<U, K extends keyof U> extends PropBox<U, K> {}","import {anythingToString, ArrayContextImpl, NoValue, FirstSubscriberHandlingBox} from \"src/internal\"\n\n/** Some box that is managed by array context */\nexport class ArrayContextControlledBox<T> extends FirstSubscriberHandlingBox<T> {\n\n\tconstructor(protected readonly arrayContext: ArrayContextImpl<any, any, any>, value: T) {\n\t\tsuper()\n\t\tthis.value = value\n\t}\n\n\ttoString(): string {\n\t\treturn `ArrayContextControlledBox(${anythingToString(this.value)})`\n\t}\n\n\tdispose(): void {\n\t\tif(this.haveSubscribers()){\n\t\t\tthis.arrayContext.onDownstreamUnsubscription()\n\t\t}\n\t\tsuper.dispose()\n\t}\n\n\tprotected onFirstSubscriber(): void {\n\t\tif(this.value !== NoValue){\n\t\t\tthis.arrayContext.onDownstreamSubscription()\n\t\t}\n\t}\n\n\tprotected onLastUnsubscriber(): void {\n\t\tif(this.value !== NoValue){\n\t\t\tthis.arrayContext.onDownstreamUnsubscription()\n\t\t}\n\t}\n\n\tcheckIfStillAttached(): void {\n\t\tif(!this.arrayContext.isItemBoxAttached(this)){\n\t\t\tthrow new Error(\"This array-linked box \" + this + \" is no longer attached to its upstream. Element it was attached to was removed from upstream, or was absent in some time in the past.\")\n\t\t}\n\t}\n\n\toverride get(): T {\n\t\tif(this.arrayContext.isItemBoxAttached(this)){\n\t\t\tthis.arrayContext.tryUpdate()\n\t\t}\n\t\tthis.checkIfStillAttached()\n\t\treturn super.get()\n\t}\n\n}","import {anythingToString, ArrayContextImpl, BoxInternal, UpstreamSubscriber, BoxUpdateMeta, ArrayItemWBox, ArrayContextControlledBox} from \"src/internal\"\n\n/** A box that contains an array item */\nexport abstract class ArrayItemBox<T, K> extends ArrayContextControlledBox<T> implements ArrayItemWBox<T> {\n\n\tconstructor(arrayContext: ArrayContextImpl<T, any, any>, value: T, public index: number, public key: K) {\n\t\tsuper(arrayContext, value)\n\t}\n\n\toverride toString(): string {\n\t\treturn `ArrayItemBox(${anythingToString(this.key)}, ${anythingToString(this.value)})`\n\t}\n\n\toverride set(newValue: T, changeSourceBox?: BoxInternal<unknown> | UpstreamSubscriber): void {\n\t\tthis.checkIfStillAttached()\n\t\tsuper.set(newValue, changeSourceBox)\n\t}\n\n\tprotected override notifyOnValueChange(value: T, changeSource: BoxInternal<unknown> | UpstreamSubscriber | undefined, updateMeta: BoxUpdateMeta | undefined): void {\n\t\tif(changeSource !== this.arrayContext){\n\t\t\tthis.arrayContext.onDownstreamChange(this, value)\n\t\t}\n\t\tsuper.notifyOnValueChange(value, changeSource, updateMeta)\n\t}\n\n\tdeleteArrayElement(): void {\n\t\tthis.checkIfStillAttached()\n\t\tthis.arrayContext.upstream.deleteElementAtIndex(this.index)\n\t}\n\n}\n\nexport class ArrayItemRBoxImpl<T, K> extends ArrayItemBox<T, K> {}\nexport class ArrayItemWBoxImpl<T, K> extends ArrayItemBox<T, K> {}","import {anythingToString, MultipleDependencyList, RBox, BoxInternal, DownstreamBox, SingleDependencyList, Unboxed, MRBox, BoxUpdateMeta, UpstreamSubscriber, WBox} from \"src/internal\"\n\ntype DependencyBoxValues<D> = D extends readonly [infer X, ...infer Rest]\n\t? readonly [Unboxed<X>, ...DependencyBoxValues<Rest>]\n\t: D extends []\n\t\t? readonly []\n\t\t: D extends readonly MRBox<unknown>[]\n\t\t\t? readonly Unboxed<D[number]>[]\n\t\t\t: never\n\nexport function calcBox<T, const D extends readonly MRBox<unknown>[]>(dependencies: D, calcFunction: (...dependencyValues: DependencyBoxValues<D>) => T): RBox<T>\n// generics on this overload are a bit weird\n// they are like that because that's the only way to infer result value of the function as tuple by default\n// (and not an array)\nexport function calcBox<T, const D extends readonly MRBox<unknown>[], const R extends (boxValue: T, ...dependencyValues: DependencyBoxValues<D>) => DependencyBoxValues<D>>(dependencies: D, calcFunction: (...dependencyValues: DependencyBoxValues<D>) => T, reverseCalcFunction: R): WBox<T>\n/** Make new calc box, readonly box that calculates its value based on passed function */\nexport function calcBox<T, const D extends readonly MRBox<unknown>[], const V extends DependencyBoxValues<D>>(dependencies: D, calcFunction: (...dependencyValues: V) => T, reverseCalcFunction?: (boxValue: T, ...dependencyValues: V) => V): RBox<T> {\n\t// in theory, here we could check if any of the dependencies are actually non-const boxes\n\t// and if not - then we could create a const box\n\t// but that's a rare case, and also calling calcFunction right now will break contract - it should be called later\n\t// maybe later, when I'd justify having const box that lazily calculates its value once\n\treturn new CalcBox(\n\t\tdependencies as unknown as readonly (unknown | BoxInternal<unknown>)[],\n\t\tcalcFunction as unknown as (...args: unknown[]) => T,\n\t\treverseCalcFunction as unknown as (value: T, ...args: unknown[]) => unknown[]\n\t)\n}\n\nexport class CalcBox<T> extends DownstreamBox<T> {\n\n\tconstructor(dependencies: readonly (unknown | BoxInternal<unknown>)[], readonly calculateFn: (...args: unknown[]) => T, readonly reverseCalculateFn: ((value: T, ...args: unknown[]) => unknown[]) | undefined) {\n\t\tsuper(dependencies.length === 1 ? new SingleDependencyList(dependencies[0]!) : new MultipleDependencyList(dependencies))\n\t}\n\n\ttoString(): string {\n\t\treturn `CalcBox(${anythingToString(this.value)})`\n\t}\n\n\toverride calculate(): T {\n\t\tconst values = this.dependencyList.getDependencyValues()\n\t\treturn this.calculateFn(...values)\n\t}\n\n\tprotected override notifyOnValueChange(value: T, changeSource: BoxInternal<unknown> | UpstreamSubscriber | undefined, updateMeta: BoxUpdateMeta | undefined): void {\n\t\tconst isChangeFromDependency = this.dependencyList.isDependency(changeSource)\n\t\tconst isChangeRecalcOnGet = !changeSource && updateMeta?.type === \"recalc_on_get\"\n\t\tconst canUpdateUpstream = !!this.reverseCalculateFn\n\t\tconst shouldUpdateUpstream = canUpdateUpstream && !isChangeFromDependency && !isChangeRecalcOnGet\n\n\t\tif(shouldUpdateUpstream){\n\t\t\tthis.updateUpstream(value)\n\t\t}\n\n\t\tsuper.notifyOnValueChange(value, changeSource, updateMeta)\n\t}\n\n\tprivate updateUpstream(newValue: T): void {\n\t\tconst depValues = this.dependencyList.getDependencyValues()\n\t\tconst newDepValues = this.reverseCalculateFn!(newValue, ...depValues)\n\t\tthis.dependencyList.setDependencyValues(newDepValues)\n\t}\n}","import {anythingToString, BaseBox, WBox} from \"src/internal\"\n\n/** Make new basic writable box */\nexport const box = <T>(value: T): WBox<T> => {\n\treturn new ValueBox(value)\n}\n\nexport class ValueBox<T> extends BaseBox<T> {\n\tconstructor(value: T) {\n\t\tsuper()\n\t\tthis.value = value\n\t}\n\n\ttoString(): string {\n\t\treturn `ValueBox(${anythingToString(this.value)})`\n\t}\n}","import {ConstArrayContext, anythingToString, ArrayContext, RBox, WBox, BoxInternal, NoValue, ArrayItemWBox, BoxUpdateMeta} from \"src/internal\"\n\n/** Make a new constant box, a readonly box which value never changes\n *\n * It exists mostly for convenience, to avoid writing two variants of code -\n * one for plain values and one for boxes */\nexport const constBox = <T>(value: T): RBox<T> => {\n\treturn new ConstBoxImpl(value)\n}\n\nexport class ConstBoxImpl<T> implements BoxInternal<T>, ArrayItemWBox<T> {\n\treadonly isConstBox!: true\n\n\tconstructor(readonly value: T | typeof NoValue) {\n\t\tif(value === NoValue){\n\t\t\tthrow new Error(\"ConstBox must always have a value\")\n\t\t}\n\t}\n\n\ttoString(): string {\n\t\treturn `ConstBox(${anythingToString(this.value)})`\n\t}\n\n\tget(): T {\n\t\treturn this.value as T\n\t}\n\n\tsubscribe(): void {\n\t\t// nothing. handler will never be called anyway\n\t}\n\n\tunsubscribe(): void {\n\t\t// nothing. we don't do anything on subscription and might as well do nothing on unsubscription\n\t}\n\n\thaveSubscribers(): boolean {\n\t\treturn false\n\t}\n\n\tmap<R>(mapper: (value: T, meta: BoxUpdateMeta | undefined) => R) {\n\t\treturn new ConstBoxImpl(mapper(this.value as T, undefined))\n\t}\n\n\tprop<K extends keyof T>(propName: K): WBox<T[K]> {\n\t\treturn new ConstBoxImpl((this.value as T)[propName])\n\t}\n\n\tgetArrayContext<E, K>(this: ConstBoxImpl<readonly E[]>, getKey: (item: E, index: number) => K): ArrayContext<E, K, ConstBoxImpl<E>> {\n\t\treturn new ConstArrayContext<E, K>(this, getKey)\n\t}\n\n\tmapArrayElements<E, R>(this: WBox<E[]>, mapper: (item: E, index: number) => R): RBox<R[]>\n\tmapArrayElements<E, R>(this: WBox<E[]>, mapper: (item: E, index: number) => R, reverseMapper: (item: R, index: number) => E): WBox<R[]>\n\tmapArrayElements<E, R>(this: ConstBoxImpl<E[]>, mapper: (item: E, index: number) => R): RBox<R[]> | WBox<R[]> {\n\t\treturn new ConstBoxImpl((this.value as E[]).map((item, index) => mapper(item, index)))\n\t}\n\n\tmapArray<E, K, R>(this: ConstBoxImpl<readonly E[]>, getKey: (item: E, index: number) => K, mapBox: (box: ArrayItemWBox<E>, index: number) => R): RBox<readonly R[]> {\n\t\tconst valueMap = new Map<K, R>()\n\t\treturn new ConstBoxImpl((this.value as E[]).map((sourceValue, i) => {\n\t\t\tconst key = getKey(sourceValue, i)\n\t\t\tif(valueMap.has(key)){\n\t\t\t\treturn valueMap.get(key)!\n\t\t\t}\n\n\t\t\tconst resultValue = mapBox(new ConstBoxImpl(sourceValue), i)\n\t\t\tvalueMap.set(key, resultValue)\n\t\t\treturn resultValue\n\t\t}))\n\t}\n\n\tset(): void {\n\t\tthrowOnChange()\n\t}\n\n\tsetProp(): void {\n\t\tthrowOnChange()\n\t}\n\n\tsetElementAtIndex(): void {\n\t\tthrowOnChange()\n\t}\n\n\tinsertElementsAtIndex(): void {\n\t\tthrowOnChange()\n\t}\n\n\tinsertElementAtIndex(): void {\n\t\tthrowOnChange()\n\t}\n\n\tappendElement(): void {\n\t\tthrowOnChange()\n\t}\n\n\tappendElements(): void {\n\t\tthrowOnChange()\n\t}\n\n\tprependElement(): void {\n\t\tthrowOnChange()\n\t}\n\n\tprependElements(): void {\n\t\tthrowOnChange()\n\t}\n\n\tdeleteElementsAtIndex(): void {\n\t\tthrowOnChange()\n\t}\n\n\tdeleteElementAtIndex(): void {\n\t\tthrowOnChange()\n\t}\n\n\tdeleteElements(): void {\n\t\tthrowOnChange()\n\t}\n\n\tdeleteElement(): void {\n\t\tthrowOnChange()\n\t}\n\n\tdeleteAllElements(): void {\n\t\tthrowOnChange()\n\t}\n\n\tdeleteArrayElement(): void {\n\t\tthrowOnChange()\n\t}\n\n\tdispose(): void {\n\t\tthrowOnChange()\n\t}\n}\n\nfunction throwOnChange(): never {\n\tthrow new Error(\"You can't change anything about value of const box\")\n}\n\n// ew. but we should do it to not diverge from typings\n(ConstBoxImpl.prototype as any).isConstBox = true","import {ConstBoxImpl, constBox, WBox, RBox, Boxed, Unboxed, ValueBox, PropWBox, ArrayItemWBoxImpl, MapWBox, BaseBox, ArrayItemWBox, updateQueue, ConstBox, MRBox} from \"src/internal\"\n\n/** Wrap a value in a const box, if the value is not a box; otherwise return that box as is */\nexport function constBoxWrap<T>(boxOrValue: RBox<T>): RBox<T>\nexport function constBoxWrap<T>(boxOrValue: T): Boxed<T>\nexport function constBoxWrap<T>(boxOrValue: T): Boxed<T> {\n\treturn (isRBox(boxOrValue) ? boxOrValue : constBox(boxOrValue)) as Boxed<T>\n}\n\n/** If the value is a box - returns the value stored inside; otherwise returns passed value */\nexport function unbox<T>(boxOrValue: RBox<T>): T\nexport function unbox<T>(boxOrValue: MRBox<T>): T\nexport function unbox<T>(boxOrValue: T): Unboxed<T> {\n\treturn (isRBox(boxOrValue) ? boxOrValue.get() : boxOrValue) as Unboxed<T>\n}\n\n/** Checks if the value is a box.\n *\n * Note that every box supplied by this library is an RBox;\n * every WBox is an RBox, every const box is an RBox, etc */\nexport function isRBox<T>(value: RBox<T>): value is RBox<T>\nexport function isRBox<T>(value: MRBox<T>): value is RBox<T>\nexport function isRBox(value: unknown): value is RBox<unknown>\nexport function isRBox(value: unknown): value is RBox<unknown> {\n\treturn value instanceof BaseBox || isConstBox(value)\n}\n\n/** Checks if the value is a writable box */\nexport function isWBox<T>(value: WBox<T>): value is WBox<T>\nexport function isWBox<T>(value: RBox<T>): value is WBox<T>\nexport function isWBox<T>(value: MRBox<T>): value is WBox<T>\nexport function isWBox(value: unknown): value is WBox<unknown>\nexport function isWBox(value: unknown): value is WBox<unknown> {\n\treturn value instanceof ValueBox || value instanceof MapWBox || value instanceof PropWBox || value instanceof ArrayItemWBoxImpl\n}\n\n/** Checks if the value is a constant box.\n *\n * Constant box is a readonly box that will never change its value.\n * This allows sometimes to skip subscribing to this box alltogether and save some performance. */\nexport function isConstBox<T>(value: MRBox<T>): value is ConstBox<T>\nexport function isConstBox<T>(value: RBox<T>): value is ConstBox<T>\nexport function isConstBox(value: unknown): value is ConstBox<unknown>\nexport function isConstBox(value: unknown): value is ConstBox<unknown> {\n\treturn value instanceof ConstBoxImpl\n}\n\nexport function isArrayItemWBox<T>(value: RBox<T>): value is ArrayItemWBox<T>\nexport function isArrayItemWBox<T>(value: MRBox<T>): value is ArrayItemWBox<T>\nexport function isArrayItemWBox(value: unknown): value is ArrayItemWBox<unknown>\nexport function isArrayItemWBox(value: unknown): value is ArrayItemWBox<unknown> {\n\treturn value instanceof ArrayItemWBoxImpl\n}\n\nexport function anythingToString(x: unknown): string {\n\tif(typeof(x) === \"symbol\"){\n\t\treturn x.toString()\n\t} else {\n\t\treturn JSON.stringify(x)\n\t}\n}\n\n/** Stops subscribers from being called until the callback is completed.\n * Updates are delivered to subscribers after that.\n * Can be used in cases when you need to do updates to several unrelated boxes and need to make sure that no extra work is done */\nexport const withBoxUpdatesPaused = <T>(callback: () => T): T => updateQueue.withUpdatesPaused(callback)","import {updateQueue, type BoxChangeHandler, type BoxInternal, type UpstreamSubscriber, BoxUpdateMeta, PropBox, Subscription, Update} from \"src/internal\"\n\n/** Class that manages list of active subscribers to some box */\nexport class SubscriberList<T, O extends BoxInternal<T>> {\n\tprivate subscriptions: Map<BoxChangeHandler<T> | UpstreamSubscriber, Subscription<T>> | null = null\n\t// propboxes are in separate collection to avoid calling all of them if meta tells us that we can skip some\n\tprivate propBoxInternalSubscriptions: Map<unknown, Subscription<T>[]> | null = null\n\n\tconstructor(private readonly owner: O) {}\n\n\thaveSubscribers(): boolean {\n\t\treturn !!(this.subscriptions || this.propBoxInternalSubscriptions)\n\t}\n\n\tcallSubscribers(value: T, changeSourceBox: BoxInternal<unknown> | UpstreamSubscriber | undefined, updateMeta: BoxUpdateMeta | undefined): void {\n\t\tthis.notifyPropSubscribers(value, changeSourceBox, updateMeta)\n\t\tthis.notifySubscribers(value, changeSourceBox, updateMeta)\n\t\tupdateQueue.run()\n\t}\n\n\tprivate notifySubscribers(value: T, changeSourceBox?: BoxInternal<unknown> | UpstreamSubscriber, updateMeta?: BoxUpdateMeta): void {\n\t\tif(!this.subscriptions){\n\t\t\treturn\n\t\t}\n\n\t\tfor(const subscription of this.subscriptions.values()){\n\t\t\tif(subscription.receiver === changeSourceBox){\n\t\t\t\t// that box already knows what value of this box should be\n\t\t\t\t// even if there's an update already in queue - it's not a big deal\n\t\t\t\t// downstream box will get fresh value each time anyway, instead of using value from update\n\t\t\t\tsubscription.lastKnownValue = value\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tupdateQueue.enqueueUpdate(new Update(subscription, value, updateMeta))\n\t\t}\n\t}\n\n\tprivate notifyPropSubscribers(value: T, changeSourceBox: BoxInternal<unknown> | UpstreamSubscriber | undefined, updateMeta: BoxUpdateMeta | undefined): void {\n\t\tif(!this.propBoxInternalSubscriptions){\n\t\t\treturn\n\t\t}\n\n\t\tif(updateMeta && updateMeta.type === \"property_update\"){\n\t\t\tconst propSubscriptionArray = this.propBoxInternalSubscriptions.get(updateMeta.propName)\n\t\t\tif(propSubscriptionArray){\n\t\t\t\tthis.notifyPropSubscriptionArray(value, propSubscriptionArray, changeSourceBox, updateMeta)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tfor(const propSubscriptionArray of this.propBoxInternalSubscriptions.values()){\n\t\t\tthis.notifyPropSubscriptionArray(value, propSubscriptionArray, changeSourceBox, updateMeta)\n\t\t}\n\t}\n\n\tprivate notifyPropSubscriptionArray(value: T, arr: Subscription<T>[], changeSourceBox?: BoxInternal<unknown> | UpstreamSubscriber, updateMeta?: BoxUpdateMeta): void {\n\t\tfor(let i = 0; i < arr.length; i++){\n\t\t\tconst subscription = arr[i]!\n\t\t\tif(subscription.receiver === changeSourceBox){\n\t\t\t\tsubscription.lastKnownValue = value\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tupdateQueue.enqueueUpdate(new Update(subscription, value, updateMeta))\n\t\t}\n\t}\n\n\tsubscribe(handler: BoxChangeHandler<T> | UpstreamSubscriber, lastKnownValue: T): void {\n\t\tconst sub: Subscription<T> = {lastKnownValue, receiver: handler, provider: this.owner}\n\t\tif(handler instanceof PropBox){\n\t\t\tconst map: typeof this.propBoxInternalSubscriptions = this.propBoxInternalSubscriptions ||= new Map()\n\n\t\t\tlet arr = map.get(handler.propName)\n\t\t\tif(!arr){\n\t\t\t\tarr = [sub]\n\t\t\t\tmap.set(handler.propName, arr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfor(let i = 0; i < arr.length; i++){\n\t\t\t\tif(arr[i]!.receiver === handler){\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tarr.push(sub)\n\t\t\treturn\n\t\t}\n\n\t\tconst map: typeof this.subscriptions = this.subscriptions ||= new Map()\n\t\tif(map.has(handler)){\n\t\t\t/** It's important to avoid creating new subscription objects if there are old ones\n\t\t\t * Because update queue may hold reference to old object to update lastKnownValue\n\t\t\t * and if new object is created for same handler/downstream, this update will be lost, which is bad */\n\t\t\treturn\n\t\t}\n\t\tmap.set(handler, sub)\n\t}\n\n\tunsubscribe(handler: BoxChangeHandler<T> | UpstreamSubscriber): void {\n\t\tif(handler instanceof PropBox){\n\t\t\tif(!this.propBoxInternalSubscriptions){\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlet arr = this.propBoxInternalSubscriptions.get(handler.propName)\n\t\t\tif(!arr){\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlet sub: Subscription<T> | null = null\n\n\t\t\tarr = arr.filter(x => {\n\t\t\t\tif(x.receiver === handler){\n\t\t\t\t\tsub = x\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t})\n\n\t\t\tif(sub){\n\t\t\t\tupdateQueue.deleteUpdate(sub)\n\t\t\t}\n\n\t\t\tif(arr.length === 0){\n\t\t\t\tthis.propBoxInternalSubscriptions.delete(handler.propName)\n\t\t\t\tif(this.propBoxInternalSubscriptions.size === 0){\n\t\t\t\t\tthis.propBoxInternalSubscriptions = null\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.propBoxInternalSubscriptions.set(handler.propName, arr)\n\t\t\t}\n\t\t}\n\n\t\tif(!this.subscriptions){\n\t\t\treturn\n\t\t}\n\n\t\tthis.subscriptions.delete(handler)\n\t\tif(this.subscriptions.size === 0){\n\t\t\tthis.subscriptions = null\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tif(this.subscriptions){\n\t\t\tfor(const downstream of this.subscriptions.keys()){\n\t\t\t\tif(typeof(downstream) !== \"function\"){\n\t\t\t\t\tdownstream.dispose()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}","import {isWBox, ArrayItemBox, UpstreamSubscriber, BoxInternal, ArrayItemRBoxImpl, ArrayItemWBoxImpl, ArrayContext, BoxUpdateMeta, ArrayContextControlledBox, RBox} from \"src/internal\"\n\ninterface BoxWithValue<E, K, V> {\n\treadonly box: ArrayItemBox<E, K>\n\treadonly value: V\n}\n\n/** This class controls a set of boxes that contain items of some array box\n * Links upstream array box with downstream item boxes\n *\n * In theory, we could live without this class,\n * but this means item boxes will need to perform a lot of checking every update\n * which is undesirable, because it's a performance hit */\nexport class ArrayContextImpl<E, K, V> implements UpstreamSubscriber, ArrayContext<E, K, ArrayItemBox<E, K>> {\n\tprivate readonly pairs = new Map<K, BoxWithValue<E, K, V>>()\n\tprivate childSubCount = 0\n\tprivate lastKnownUpstreamValue: readonly E[] | null = null\n\tprivate mappedValueBox: ArrayContextControlledBox<readonly V[]> | null = null\n\n\tconstructor(readonly upstream: BoxInternal<readonly E[]>, private readonly getKey: (element: E, index: number) => K, private readonly getValue: (element: ArrayItemBox<E, K>, index: number) => V) {\n\t}\n\n\ttryUpdate(skipSubCountCheck?: boolean): void {\n\t\tif(!skipSubCountCheck && this.childSubCount > 0){\n\t\t\t// the same logic as in calcbox - if we are being subscribed to, then we are subscribed to upstream\n\t\t\t// that means our value is up-to-date\n\t\t\treturn\n\t\t}\n\n\t\tconst upstreamArray = this.upstream.get()\n\t\tif(upstreamArray === this.lastKnownUpstreamValue){\n\t\t\treturn\n\t\t}\n\n\t\tthis.onUpstreamChange(this.upstream, undefined, upstreamArray)\n\t}\n\n\tprivate makeChildBox(item: E, index: number, key: K): BoxWithValue<E, K, V> {\n\t\tconst box = !isWBox(this.upstream)\n\t\t\t? new ArrayItemRBoxImpl<E, K>(this, item, index, key)\n\t\t\t: new ArrayItemWBoxImpl<E, K>(this, item, index, key)\n\t\tconst pair = {box, value: null as unknown as V}\n\t\tthis.pairs.set(key, pair)\n\t\tpair.value = this.getValue(box, index)\n\t\treturn pair\n\t}\n\n\tonUpstreamChange(_: BoxInternal<unknown>, meta: BoxUpdateMeta | undefined, upstreamArray?: readonly E[]): void {\n\t\tupstreamArray ??= this.upstream.get()\n\t\tthis.lastKnownUpstreamValue = upstreamArray\n\t\tlet newMeta: BoxUpdateMeta | undefined = undefined\n\t\tlet shouldUpdateValues = true\n\n\t\tswitch(meta?.type){\n\n\t\t\tcase \"array_item_update\": {\n\t\t\t\tconst item = upstreamArray[meta.index]!\n\t\t\t\tconst key = this.getKey(item, meta.index)\n\t\t\t\tconst pair = this.pairs.get(key)\n\t\t\t\tif(!pair){\n\t\t\t\t\tconst oldKey = this.getKey(meta.oldValue as E, meta.index)\n\t\t\t\t\tconst oldPair = this.pairs.get(oldKey)\n\t\t\t\t\tif(!oldPair){\n\t\t\t\t\t\tthrow new Error(\"Array element is not found by key \" + oldKey)\n\t\t\t\t\t}\n\t\t\t\t\tthis.pairs.delete(oldKey)\n\t\t\t\t\tthis.makeChildBox(item, meta.index, key)\n\t\t\t\t\tnewMeta = {type: \"array_item_update\", index: meta.index, oldValue: oldPair.value}\n\t\t\t\t} else {\n\t\t\t\t\tpair.box.set(item, this)\n\t\t\t\t\tshouldUpdateValues = false\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tcase \"array_items_insert\": {\n\t\t\t\tconst newValuesArray: V[] = new Array(meta.count)\n\n\t\t\t\tfor(const {box} of this.pairs.values()){\n\t\t\t\t\tif(box.index >= meta.index){\n\t\t\t\t\t\tbox.index += meta.count\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(let offset = 0; offset < meta.count; offset++){\n\t\t\t\t\tconst index = meta.index + offset\n\t\t\t\t\tconst item = upstreamArray[index]!\n\t\t\t\t\tconst key = this.getKey(item, index)\n\t\t\t\t\tif(this.pairs.get(key)){\n\t\t\t\t\t\tthrow new Error(\"Duplicate key: \" + key)\n\t\t\t\t\t}\n\t\t\t\t\tconst pair = this.makeChildBox(item, index, key)\n\t\t\t\t\tnewValuesArray[offset] = pair.value\n\t\t\t\t}\n\t\t\t\tnewMeta = {type: \"array_items_insert\", count: meta.count, index: meta.index}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tcase \"array_items_delete\": {\n\t\t\t\tconst newIndexValuePairs: {index: number, value: unknown}[] = new Array(meta.indexValuePairs.length)\n\t\t\t\tfor(let i = 0; i < meta.indexValuePairs.length; i++){\n\t\t\t\t\tconst {index, value} = meta.indexValuePairs[i]!\n\t\t\t\t\tconst key = this.getKey(value as E, index)\n\t\t\t\t\tconst pair = this.pairs.get(key)\n\t\t\t\t\tif(!pair){\n\t\t\t\t\t\tthrow new Error(\"Tried to delete item at key \" + key + \", but there's no item for that key.\")\n\t\t\t\t\t}\n\t\t\t\t\tpair.box.dispose()\n\t\t\t\t\tthis.pairs.delete(key)\n\t\t\t\t\tnewIndexValuePairs[i] = {index, value: pair.value}\n\t\t\t\t}\n\n\t\t\t\t// \"smart\" update of only boxes that has indexes shifted would be hard here\n\t\t\t\t// so let's just update all the indexes\n\t\t\t\tthis.updateAllIndex(upstreamArray)\n\n\t\t\t\tnewMeta = {type: \"array_items_delete\", indexValuePairs: newIndexValuePairs}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tcase \"array_items_delete_all\": {\n\n\t\t\t\tfor(const pair of this.pairs.values()){\n\t\t\t\t\tpair.box.dispose()\n\t\t\t\t}\n\t\t\t\tthis.pairs.clear()\n\t\t\t\tnewMeta = {type: \"array_items_delete_all\"}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tdefault: {\n\t\t\t\tconst outdatedKeys = new Set(this.pairs.keys())\n\t\t\t\tfor(let index = 0; index < upstreamArray.length; index++){\n\t\t\t\t\tconst item = upstreamArray[index]!\n\t\t\t\t\tconst key = this.getKey(item, index)\n\t\t\t\t\tconst pair = this.pairs.get(key)\n\t\t\t\t\tif(pair){\n\t\t\t\t\t\tif(!outdatedKeys.has(key)){\n\t\t\t\t\t\t\tthrow new Error(\"Constraint violated, key is not unique: \" + key)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpair.box.set(item, this)\n\t\t\t\t\t\tpair.box.index = index\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.makeChildBox(item, index, key)\n\t\t\t\t\t}\n\n\t\t\t\t\toutdatedKeys.delete(key)\n\t\t\t\t}\n\n\t\t\t\tfor(const key of outdatedKeys){\n\t\t\t\t\tconst pair = this.pairs.get(key)!\n\t\t\t\t\tpair.box.dispose()\n\t\t\t\t\tthis.pairs.delete(key)\n\t\t\t\t}\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif(this.mappedValueBox !== null && shouldUpdateValues){\n\t\t\tthis.mappedValueBox.set(this.makeValuesArray(), this, newMeta)\n\t\t}\n\t}\n\n\tprivate updateAllIndex(upstreamArray: readonly E[]): void {\n\t\tfor(let i = 0; i < upstreamArray.length; i++){\n\t\t\tconst item = upstreamArray[i]!\n\t\t\tconst key = this.getKey(item, i)\n\t\t\tconst pair = this.pairs.get(key)\n\t\t\tif(!pair){\n\t\t\t\tcontinue // whatever, we'll create them on next update call\n\t\t\t}\n\t\t\tpair.box.index = i\n\t\t}\n\t}\n\n\tonDownstreamChange(downstreamBox: ArrayItemBox<E, K>, value: E): void {\n\t\tconst newKey = this.getKey(value, downstreamBox.index)\n\t\tif(newKey !== downstreamBox.key){\n\t\t\t/* changing keys within one box is not allowed\n\t\t\tsure, we can handle it... within this context;\n\t\t\tbut there could be more than one context for an array box,\n\t\t\tand that other context won't be updated, which will increase confusion.\n\n\t\t\tthat is, the only way for other contexts to handle the change is to disconnect the box (and create another)\n\t\t\tthat means, for the sake of consistency, that we should also disconnect this box\n\t\t\twhich is just confusing, because setting value of a box disconnects it...? what?\n\n\t\t\tchange of key through direct .setElementAtIndex or whatever it's called is still allowed\n\t\t\tbecause this won't lead to such confusion\n\n\t\t\talso changing a key like that is generally confusing idea, not sure why anyone would do that */\n\t\t\tthrow new Error(\"Array item box changed key, which is not allowed; was: \" + downstreamBox.key + \", now \" + newKey)\n\t\t}\n\n\t\tconst oldUpstreamValue = this.upstream.get()\n\t\tif(this.childSubCount < 1){\n\t\t\t// if we wasn't subscribed - there's a chance that upstream box changed unpredictably\n\t\t\t// that includes index changes\n\t\t\t// so, if we are gonna rely on index - we should update it\n\t\t\tthis.tryUpdate()\n\t\t\tdownstreamBox.checkIfStillAttached()\n\t\t}\n\n\t\tconst newUpstreamValue: E[] = [...oldUpstreamValue]\n\t\tconst oldElementValue = newUpstreamValue[downstreamBox.index]\n\t\tnewUpstreamValue[downstreamBox.index] = value\n\t\tthis.lastKnownUpstreamValue = newUpstreamValue\n\t\tthis.upstream.set(newUpstreamValue, this, {type: \"array_item_update\", index: downstreamBox.index, oldValue: oldElementValue})\n\t}\n\n\tonDownstreamSubscription(): void {\n\t\tthis.childSubCount++\n\t\tif(this.childSubCount === 1){\n\t\t\tthis.tryUpdate(true)\n\t\t\tthis.upstream.subscribe(this)\n\t\t}\n\t}\n\n\tonDownstreamUnsubscription(): void {\n\t\tthis.childSubCount--\n\t\tif(this.childSubCount === 0){\n\t\t\tthis.unsubscribeFromUpstream()\n\t\t}\n\t}\n\n\tprivate unsubscribeFromUpstream(): void {\n\t\tthis.upstream.unsubscribe(this)\n\t}\n\n\tgetBoxes(): ArrayItemBox<E, K>[] {\n\t\tthis.tryUpdate()\n\t\tconst upstreamValue = this.upstream.get()\n\t\tconst result: ArrayItemBox<E, K>[] = new Array(upstreamValue.length)\n\t\tfor(let i = 0; i < upstreamValue.length; i++){\n\t\t\tconst oldValue = upstreamValue[i]!\n\t\t\tconst key = this.getKey(oldValue, i)\n\t\t\tconst pair = this.pairs.get(key)\n\t\t\tif(!pair){\n\t\t\t\t// should realistically never happen\n\t\t\t\tthrow new Error(\"Cannot get array item box list: no downstream box for key \" + key)\n\t\t\t}\n\t\t\tresult[i] = pair.box\n\t\t}\n\t\treturn result\n\t}\n\n\tgetBoxForKey(key: K): ArrayItemBox<E, K> {\n\t\tthis.tryUpdate()\n\t\tconst pair = this.pairs.get(key)\n\t\tif(!pair){\n\t\t\tthrow new Error(\"No box for key \" + key)\n\t\t}\n\t\treturn pair.box\n\t}\n\n\tisItemBoxAttached(itemBox: RBox<unknown>): boolean {\n\t\treturn itemBox instanceof ArrayItemBox\n\t\t\t? this.pairs.get(itemBox.key)?.box === itemBox\n\t\t\t: this.mappedValueBox === itemBox\n\t}\n\n\tdispose(): void {\n\t\tthis.lastKnownUpstreamValue = null // to trigger update next time\n\t\tfor(const pair of this.pairs.values()){\n\t\t\tpair.box.dispose()\n\t\t}\n\t}\n\n\ttoString(): string {\n\t\treturn `ArrayContext(${this.getKey})`\n\t}\n\n\tgetValueArrayBox(): ArrayContextControlledBox<readonly V[]> {\n\t\tif(!this.mappedValueBox){\n\t\t\tthis.mappedValueBox = new ArrayContextControlledBox<readonly V[]>(this, this.makeValuesArray())\n\t\t}\n\t\treturn this.mappedValueBox\n\t}\n\n\tprivate makeValuesArray(): readonly V[] {\n\t\tthis.tryUpdate()\n\t\tif(!this.lastKnownUpstreamValue){\n\t\t\t// should not happen\n\t\t\tthrow new Error(\"Array context update failed: no known upstream value (wtf?)\")\n\t\t}\n\t\tconst values: V[] = new Array(this.pairs.size)\n\t\tfor(let i = 0; i < this.lastKnownUpstreamValue.length; i++){\n\t\t\t// oof. wonder if there's a better way\n\t\t\tvalues[i] = this.pairs.get(this.getKey(this.lastKnownUpstreamValue[i]!, i))!.value\n\t\t}\n\t\treturn values\n\t}\n\n}","import {ConstBoxImpl, ArrayContext} from \"src/internal\"\n\nexport class ConstArrayContext<E, K> implements ArrayContext<E, K, ConstBoxImpl<E>> {\n\n\tprivate boxMap: Map<K, ConstBoxImpl<E>> | null = null\n\tprivate boxArray: ConstBoxImpl<E>[] | null = null\n\n\tconstructor(private readonly upstream: ConstBoxImpl<readonly E[]>, private readonly getKey: (item: E, index: number) => K) {}\n\n\tgetBoxForKey(key: K): ConstBoxImpl<E> {\n\t\tif(!this.boxMap){\n\t\t\tthis.boxMap = new Map()\n\t\t\tconst upstreamArray = this.upstream.get()\n\t\t\tfor(let i = 0; i < upstreamArray.length; i++){\n\t\t\t\tconst item = upstreamArray[i]!\n\t\t\t\tconst key = this.getKey(item, i)\n\t\t\t\tif(this.boxMap.has(key)){\n\t\t\t\t\tthrow new Error(\"Duplicate array key: \" + key)\n\t\t\t\t}\n\t\t\t\tthis.boxMap.set(key, new ConstBoxImpl(item))\n\t\t\t}\n\t\t}\n\n\t\tconst box = this.boxMap.get(key)\n\t\tif(!box){\n\t\t\tthrow new Error(\"No box for key \" + key)\n\t\t}\n\n\t\treturn box\n\t}\n\n\tgetBoxes(): ConstBoxImpl<E>[] {\n\t\tif(!this.boxArray){\n\t\t\tconst upstreamArray = this.upstream.get()\n\t\t\tthis.boxArray = upstreamArray.map(item => new ConstBoxImpl(item))\n\t\t}\n\t\treturn [...this.boxArray]\n\t}\n\n}","import {Subscription, UpdateReceiver, MapBox, Update, CalcBox} from \"src/internal\"\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ntype NTuple<X, T> = X extends `${infer _}${infer B}` ? [T, ...NTuple<B, T>] : []\ntype SubQueue<T> = Map<Subscription<T>, Update<T>>\n\nclass UpdateQueue {\n\tprivate readonly subQueues = new Array(3).fill(null).map(() => new Map()) as NTuple<\"124\", SubQueue<unknown>>\n\tprivate isRunning = false\n\tprivate pauseLevel = 0\n\n\tprivate getSubQueue<T>(receiver: UpdateReceiver<T>): SubQueue<T> {\n\t\t// this exact ordering of update distribution is dictated by the need to avoid showing inconsistent state to user callbacks\n\t\tif(typeof(receiver) === \"function\"){\n\t\t\treturn this.subQueues[2] as SubQueue<T>\n\t\t} else if(receiver instanceof CalcBox || receiver instanceof MapBox){\n\t\t\treturn this.subQueues[1] as SubQueue<T>\n\t\t} else {\n\t\t\treturn this.subQueues[0] as SubQueue<T>\n\t\t}\n\t}\n\n\twithUpdatesPaused<T>(callback: () => T): T {\n\t\tthis.pauseLevel++\n\t\ttry {\n\t\t\treturn callback()\n\t\t} finally {\n\t\t\tthis.pauseLevel--\n\t\t\tthis.run()\n\t\t}\n\t}\n\n\tenqueueUpdate<T>(update: Update<T>): void {\n\t\tconst subQueue = this.getSubQueue(update.subscription.receiver)\n\t\tconst oldUpdate = subQueue.get(update.subscription)\n\t\tif(oldUpdate){\n\t\t\t// we cannot have two updates queued at the same time, because it doesn't make sense to in general\n\t\t\t// so, when we queue next update, previous update is lost\n\t\t\t// that means that we MUST do full update, because if both of the updates are partial - some meaning is lost\n\t\t\t// and that's why we are clearing meta here\n\t\t\tupdate.meta = undefined\n\t\t}\n\t\tif(update.value === update.subscription.lastKnownValue){\n\t\t\tsubQueue.delete(update.subscription)\n\t\t} else {\n\t\t\tsubQueue.set(update.subscription, update)\n\t\t}\n\t}\n\n\tdeleteUpdate<T>(subscription: Subscription<T>): void {\n\t\tthis.getSubQueue(subscription.receiver).delete(subscription)\n\t}\n\n\trun(): void {\n\t\tif(this.isRunning || this.pauseLevel > 0){\n\t\t\treturn\n\t\t}\n\t\tthis.isRunning = true\n\t\ttry {\n\t\t\tthis.runInternal()\n\t\t} finally {\n\t\t\tthis.isRunning = false\n\t\t}\n\t}\n\n\tprivate runInternal(): void {\n\t\twhile(true){\n\t\t\tfor(let i = 0; i < this.subQueues.length; i++){\n\t\t\t\tconst subQueue = this.subQueues[i]!\n\t\t\t\tconst update = subQueue.values().next().value as Update<unknown> | undefined\n\t\t\t\tif(!update){\n\t\t\t\t\tif(i === this.subQueues.length - 1){\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tsubQueue.delete(update.subscription)\n\t\t\t\tupdate.deliver()\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nexport const updateQueue = new UpdateQueue()","import {CalcBox, anythingToString, Subscription, BoxUpdateMeta, MapBox} from \"src/internal\"\n\n/** Update is a single act of notifying a subscriber about change\n *\n * This class holds information about one update, to be executed when the time is right. */\nexport class Update<T> {\n\tconstructor(\n\t\treadonly subscription: Subscription<T>,\n\t\treadonly value: T,\n\t\tpublic meta: BoxUpdateMeta | undefined\n\t) {\n\t\tif(subscription.receiver instanceof CalcBox || subscription.receiver instanceof MapBox){\n\t\t\t/** We deliver updates to those boxes with the flag to enforce proper recalculation order;\n\t\t\t * if we deliver updates in order of receiving, there could be situation when some calcBox gets update before its upstream\n\t\t\t * and therefore should be recalculated again later;\n\t\t\t * also it can be confusing to user, because inconsistent state could be observed then */\n\t\t\tsubscription.receiver.forcedShouldRecalculate = true\n\t\t}\n\t\t// console.log(\"created \" + this)\n\t}\n\n\tdeliver(): void {\n\t\t// console.log(\"delivering \" + this)\n\t\tthis.subscription.lastKnownValue = this.value\n\t\tconst receiver = this.subscription.receiver\n\t\tif(receiver instanceof CalcBox || receiver instanceof MapBox){\n\t\t\tif(receiver.forcedShouldRecalculate){\n\t\t\t\t// it could be called before us, if there are other boxes depending on this calcbox\n\t\t\t\treceiver.recalculateIfShould(this.subscription.provider, this.meta)\n\t\t\t}\n\t\t} else if(typeof(receiver) === \"function\"){\n\t\t\treceiver(this.value, this.subscription.provider, this.meta)\n\t\t} else {\n\t\t\treceiver.onUpstreamChange(this.subscription.provider, this.meta)\n\t\t}\n\t}\n\n\ttoString(): string {\n\t\treturn `Update(${anythingToString(this.value)}, from ${this.subscription.provider} to ${this.subscription.receiver}${!this.meta ? \"\" : \", \" + JSON.stringify(this.meta)})`\n\t}\n}"],"names":["$56ecb70de8c62ae9$var$r","Symbol","$56ecb70de8c62ae9$var$l","subscribeToDomValue","unsubscribeFromDomValue","constructor","e","t","this","box","options","lastKnownRawDomValue","subscribeDomBound","bind","unsubscribeDomBound","tryUpdateDomValueBound","tryUpdateDomValue","updateBoxValueBound","updateBoxValue","canPushUpdates","prototype","$9H5KT","isWBox","getRawDomValue","set","parseDomValue","o","preferBoxValue","updateDomValue","onInserted","onRemoved","isInDom","watchAndRun","watch","unbind","offInserted","offRemoved","unwatch","$56ecb70de8c62ae9$var$a","map","super","node","element","HTMLElement","document","body","style","getPropertyValue","name","removeProperty","setProperty","Error","$56ecb70de8c62ae9$var$h","timeoutMs","check","startTime","isRunning","runCheckAndRequest","Date","now","e1","$56ecb70de8c62ae9$var$u","run","requestAnimationFrame","setTimeout","$56ecb70de8c62ae9$var$c","subscribe","handlers","add","isPatched","patch","unsubscribe","delete","lastKnownLocation","window","location","History","n","s","apply","repeater","tryCallHandlers","Set","$56ecb70de8c62ae9$var$f","URL","path","pathname","search","hash","history","replaceState","pushState","addEventListener","removeEventListener","$56ecb70de8c62ae9$var$m","$56ecb70de8c62ae9$var$y","beforeInsertedHandlers","afterInsertedHandlers","removedHandlers","watchedBoxes","domValueLinks","isExpectingInsertion","isConnected","push","$56ecb70de8c62ae9$var$w","notifyBeforeInserted","length","get","handlerWrap","lastKnownValue","invokeBoxHandler","$56ecb70de8c62ae9$var$g","notifyAfterInserted","notifyAfterRemoved","notifyAttachmentState","console","error","handler","filter","addDomValueLink","removeDomValueLink","$56ecb70de8c62ae9$var$x","Node","Element","SVGElement","$56ecb70de8c62ae9$var$I","$56ecb70de8c62ae9$var$v","Array","$56ecb70de8c62ae9$var$D","$56ecb70de8c62ae9$var$V","has","originalNonPatchedMethod","t1","$56ecb70de8c62ae9$var$B","Object","getOwnPropertyDescriptor","defineProperty","$56ecb70de8c62ae9$var$N","startInsertOperation","ongoingInsertOperationsCount","markNodeInserted","endInsertOperation","nodesInTree","clear","childNodes","markNodeRemoved","isInserted","$56ecb70de8c62ae9$var$R","isArray","$56ecb70de8c62ae9$var$k","$56ecb70de8c62ae9$var$$","i","r","n1","isRBox","$56ecb70de8c62ae9$var$P","l","s1","i1","unbox","join","class","classList","value","attrs","$56ecb70de8c62ae9$var$A","removeAttribute","setAttribute","n2","startsWith","o1","charAt","toLowerCase","substring","passive","capture","t2","type","oldValue","index","$56ecb70de8c62ae9$var$S","removeChild","Text","textContent","createTextNode","appendChild","insertBefore","isConstBox","constBoxWrap","$56ecb70de8c62ae9$export$1e848a9e87980bd5","ifInDom","beforeInserted","$56ecb70de8c62ae9$var$L","WeakMap","$56ecb70de8c62ae9$var$C","binders","observer","init","MutationObserver","doWithRecords","observe","childList","subtree","shutdown","disconnect","collectEligibleNodesFromArray","collectEligibleNodes","addedNodes","e2","removedNodes","e3","e4","$56ecb70de8c62ae9$var$E","isInit","projectedTreeState","isInitialized","afterRemovedOrInserted","collectBinders","parentNode","$56ecb70de8c62ae9$export$45d2dafb95487308","async","$56ecb70de8c62ae9$export$45f69fe3f857b94d","dontCallImmediately","$56ecb70de8c62ae9$var$K","$56ecb70de8c62ae9$var$W","localStorage","getItem","key","serialize","removeItem","setItem","parse","$56ecb70de8c62ae9$export$2b067c6666111485","createElement","tag","$56ecb70de8c62ae9$export$e0e99c6b21dfde8d","createElementNS","setAttributeNS","$56ecb70de8c62ae9$export$7003262fc833c023","Promise","readyState","$70ec98150aeca14c$var$e","calculate","revision","owner","updateKnownDependencyValues","$70ec98150aeca14c$var$t","rawDependencies","boxMap","Map","$70ec98150aeca14c$export$74473745afe6cecc","keys","getDependencyValues","$70ec98150aeca14c$export$c1d3dacf4f169228","subscribeToDependencies","unsubscribeFromDependencies","didDependencyListChange","setDependencyValues","$70ec98150aeca14c$export$323bbb183502380a","isDependency","$70ec98150aeca14c$var$s","dependency","lastKnownDependencyValue","$70ec98150aeca14c$var$i","$70ec98150aeca14c$var$r","haveSubscribers","subscriberList","notifyOnValueChange","dispose","callSubscribers","$70ec98150aeca14c$var$c","$70ec98150aeca14c$var$p","$70ec98150aeca14c$var$n","prop","$70ec98150aeca14c$var$y","$70ec98150aeca14c$var$b","getArrayContext","$70ec98150aeca14c$var$M","$70ec98150aeca14c$var$a","mapArrayElements","a","mapArray","getValueArrayBox","setProp","propName","setElementAtIndex","insertElementsAtIndex","checkInsertIndex","slice","count","insertElementAtIndex","appendElement","appendElements","prependElement","prependElements","deleteElementsAtIndex","checkDeleteIndex","Math","min","r1","indexValuePairs","deleteElementAtIndex","deleteElements","deleteElementsInternal","deleteElement","deleteAllElements","$70ec98150aeca14c$var$L","$70ec98150aeca14c$var$l","onFirstSubscriber","onLastUnsubscriber","$70ec98150aeca14c$var$o","dependencyList","forcedShouldRecalculate","calculateAndUpdate","onUpstreamChange","shouldRecalculate","recalculateIfShould","$70ec98150aeca14c$var$u","upstream","makeDownstreamValue","updateUpstreamWith","$70ec98150aeca14c$var$h","makeUpstreamValue","toString","$70ec98150aeca14c$var$_","$70ec98150aeca14c$var$d","$70ec98150aeca14c$var$x","arrayContext","onDownstreamUnsubscription","onDownstreamSubscription","checkIfStillAttached","isItemBoxAttached","tryUpdate","$70ec98150aeca14c$var$f","onDownstreamChange","deleteArrayElement","$70ec98150aeca14c$var$m","$70ec98150aeca14c$var$g","$70ec98150aeca14c$var$v","calculateFn","reverseCalculateFn","updateUpstream","$70ec98150aeca14c$export$827f4ee28efc37","$70ec98150aeca14c$var$A","$70ec98150aeca14c$var$E","$70ec98150aeca14c$var$P","$70ec98150aeca14c$var$C","$70ec98150aeca14c$export$e49fa8373069a746","$70ec98150aeca14c$export$5fa8b3233b7d11bd","$70ec98150aeca14c$export$d7e21a92df188992","JSON","stringify","subscriptions","propBoxInternalSubscriptions","notifyPropSubscribers","notifySubscribers","$70ec98150aeca14c$var$N","values","receiver","enqueueUpdate","$70ec98150aeca14c$var$F","notifyPropSubscriptionArray","provider","deleteUpdate","size","getKey","getValue","pairs","childSubCount","lastKnownUpstreamValue","mappedValueBox","makeChildBox","r2","a1","s2","i2","r3","a2","updateAllIndex","e5","e6","i3","r4","n3","makeValuesArray","unsubscribeFromUpstream","getBoxes","getBoxForKey","boxArray","getSubQueue","subQueues","withUpdatesPaused","pauseLevel","subscription","meta","runInternal","next","deliver","fill"],"version":3,"file":"digger.3c0c882a.js.map"}