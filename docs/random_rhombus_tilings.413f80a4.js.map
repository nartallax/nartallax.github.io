{"mappings":"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","sources":["src/sketches/random_rhombus_tilings/random_rhombus_tilings.ts","src/sketches/random_rhombus_tilings/rhombus_tiling_render.ts","src/common/color_utils.ts","src/common/tag.ts","src/common/classname.ts","src/sketches/random_rhombus_tilings/rhombus_tiling.ts","src/common/perfometer.ts","src/sketches/random_rhombus_tilings/triangle_grid.ts","src/common/queue.ts"],"sourcesContent":["import {renderRhombuses} from \"sketches/random_rhombus_tilings/rhombus_tiling_render\"\nimport {getEmptyRhombusPattern, tileWithRandomRhombuses} from \"sketches/random_rhombus_tilings/rhombus_tiling\"\nimport {transformColorHsl} from \"common/color_utils\"\nimport {performeter} from \"common/perfometer\"\n\n\nconst colors = [0x53bc01, 0xffeb03, 0xffa801, 0xf93a1d, 0xe21a5f, 0x572c62, 0xa1ccd3, 0x006898]\n\nexport function main(container: HTMLElement): void {\n\tperformeter.enterBlock(\"initializing\")\n\tconst grid = getEmptyRhombusPattern({width: 25, height: 25, length: 25})\n\n\tperformeter.exitEnterBlock(\"randomizing\")\n\ttileWithRandomRhombuses(grid)\n\n\tperformeter.exitEnterBlock(\"drawing\")\n\n\tconst color = colors[Math.floor(Math.random() * colors.length)]!\n\n\tconst svg = renderRhombuses({\n\t\thorisontalColor: transformColorHsl(color, ([h, s, l]) => [h, s * 1.1, l]),\n\t\tleftColor: transformColorHsl(color, ([h, s, l]) => [h, s * 0.9, l * 0.9]),\n\t\trightColor: transformColorHsl(color, ([h, s, l]) => [h, s * 0.9, l * 0.8]),\n\t\tcellSize: {\n\t\t\tx: 10,\n\t\t\ty: 10\n\t\t},\n\t\tgrid\n\t})\n\tsvg.style.margin = \"100px 500px\"\n\tcontainer.appendChild(svg)\n\n\tperformeter.exitBlock()\n\tperformeter.print()\n}","import {rgbNumberToColorString} from \"common/color_utils\"\nimport {svgTag} from \"common/tag\"\nimport {RhombusGrid} from \"sketches/random_rhombus_tilings/rhombus_tiling\"\nimport {TriangleGrid, XY} from \"sketches/random_rhombus_tilings/triangle_grid\"\n\ninterface Props {\n\treadonly cellSize: XY\n\treadonly horisontalColor: number\n\treadonly leftColor: number\n\treadonly rightColor: number\n\treadonly grid: RhombusGrid\n}\n\nexport const renderRhombuses = (props: Props): SVGSVGElement => {\n\tconst grid = props.grid\n\tconst svg = svgTag({tagName: \"svg\"})\n\n\tsvg.setAttribute(\"width\", grid.xWidth + \"\")\n\tsvg.setAttribute(\"height\", grid.yHeight + \"\")\n\tsvg.setAttribute(\"viewBox\", `-1 -1 ${grid.xWidth + 1} ${grid.yHeight + 0.5}`)\n\tsvg.style.width = ((grid.xWidth + 1) * props.cellSize.x) + \"px\"\n\tsvg.style.height = ((grid.yHeight + 0.5) * props.cellSize.y) + \"px\"\n\n\tconst strokeWidth = 2 / (props.cellSize.x + props.cellSize.y)\n\tconst makePathMaker = (color: number, expr: (x: number, y: number) => string) => (x: number, y: number): SVGPathElement => {\n\t\tlet offset = grid.getVerticalOffset(Math.max(0, Math.min(grid.xWidth - 1, x)))\n\t\tif(x < 0 || x >= grid.xWidth){\n\t\t\toffset += 0.5\n\t\t}\n\t\treturn svgTag({\n\t\t\ttagName: \"path\",\n\t\t\tattrs: {\n\t\t\t\td: expr(x, y + offset),\n\t\t\t\tfill: rgbNumberToColorString(color),\n\t\t\t\t// strokes are only required to fill small gaps between the elements\n\t\t\t\t// if all the lines were cardinal - there would be no gaps, but they are not\n\t\t\t\tstroke: rgbNumberToColorString(color),\n\t\t\t\t\"stroke-width\": strokeWidth\n\t\t\t}\n\t\t})\n\t}\n\n\tconst makeLeft = makePathMaker(\n\t\tprops.leftColor,\n\t\t(x, y) => `M ${x} ${y} V ${y - 1} L ${x - 1} ${y - 0.5} V ${y + 0.5} z`)\n\n\tconst makeRight = makePathMaker(\n\t\tprops.rightColor,\n\t\t(x, y) => `M ${x} ${y} V ${y - 1} L ${x + 1} ${y - 0.5} V ${y + 0.5} z`)\n\n\tconst makeBottom = makePathMaker(\n\t\tprops.horisontalColor,\n\t\t(x, y) => `M ${x} ${y} L ${x - 1} ${y + 0.5} L ${x} ${y + 1} L ${x + 1} ${y + 0.5} z`)\n\n\tfor(const {x, y, value: {leftIsSolid, rightIsSolid, bottomIsSolid}} of props.grid){\n\t\tif(leftIsSolid){\n\t\t\tsvg.appendChild(makeLeft(x, y))\n\t\t}\n\t\tif(rightIsSolid){\n\t\t\tsvg.appendChild(makeRight(x, y))\n\t\t}\n\t\tif(bottomIsSolid){\n\t\t\tsvg.appendChild(makeBottom(x, y))\n\t\t}\n\t}\n\n\t// filling borders\n\tgrid.exploreFrom(grid.getTopCornerCoords(), xy => {\n\t\tgrid.get(xy).leftIsSolid || svg.appendChild(makeBottom(xy.x, xy.y - 1))\n\t\treturn [grid.getBottomLeftOf(xy)]\n\t})\n\n\tgrid.exploreFrom(grid.getTopCornerCoords(), xy => {\n\t\tgrid.get(xy).rightIsSolid || svg.appendChild(makeBottom(xy.x, xy.y - 1))\n\t\treturn [grid.getBottomRightOf(xy)]\n\t})\n\n\tgrid.exploreFrom(grid.getRightBottomCornerCoords(), xy => {\n\t\tgrid.get(xy).rightIsSolid || svg.appendChild(makeLeft(xy.x + 1, xy.y))\n\t\treturn [grid.getTopOf(xy)]\n\t})\n\n\tgrid.exploreFrom(grid.getRightBottomCornerCoords(), xy => {\n\t\tgrid.get(xy).bottomIsSolid || svg.appendChild(makeLeft(xy.x + 1, xy.y))\n\t\treturn [grid.getBottomLeftOf(xy)]\n\t})\n\n\tgrid.exploreFrom(grid.getLeftBottomCornerCoords(), xy => {\n\t\tgrid.get(xy).bottomIsSolid || svg.appendChild(makeRight(xy.x - 1, xy.y))\n\t\treturn [grid.getBottomRightOf(xy)]\n\t})\n\n\tgrid.exploreFrom(grid.getLeftBottomCornerCoords(), xy => {\n\t\tgrid.get(xy).leftIsSolid || svg.appendChild(makeRight(xy.x - 1, xy.y))\n\t\treturn [grid.getTopOf(xy)]\n\t})\n\n\t// debug dots\n\t// for(const {x, y} of grid){\n\t// \tsvg.appendChild(svgTag({tagName: \"circle\", attrs: {\n\t// \t\tcx: x, cy: y + grid.getVerticalOffset(x), r: 0.1, fill: \"white\", stroke: \"none\"\n\t// \t}}))\n\t// }\n\n\treturn svg\n}\n\n// that's mostly for debug\nexport const renderRhombusDots = (grid: TriangleGrid<unknown>): SVGSVGElement => {\n\tconst cellSizePx = 20\n\tconst dotSizePx = 10\n\n\tconst svg = svgTag({tagName: \"svg\"})\n\tsvg.setAttribute(\"width\", grid.xWidth + \"\")\n\tsvg.setAttribute(\"height\", grid.yHeight + \"\")\n\tsvg.setAttribute(\"viewBox\", `-1 -1 ${grid.xWidth + 1} ${grid.yHeight + 1}`)\n\tsvg.style.width = (grid.xWidth * cellSizePx) + \"px\"\n\tsvg.style.height = (grid.yHeight * cellSizePx) + \"px\"\n\n\tconst findDot = ({x, y}: XY): SVGCircleElement | null => {\n\t\tconst el = svg.getElementById(`circle-${x}-${y}`)\n\t\treturn el instanceof SVGCircleElement ? el : null\n\t}\n\n\tconst setColor = (xy: XY, color: string) => {\n\t\tconst dot = findDot(xy)\n\t\tif(dot){\n\t\t\tdot.style.fill = color\n\t\t}\n\t}\n\n\tconst showNeighbours = (xy: XY) => grid.getValidNeighbourCoords(xy)\n\t\t.forEach(xy => setColor(xy, \"red\"))\n\n\tconst hideNeighbours = (xy: XY) => grid.getValidNeighbourCoords(xy)\n\t\t.forEach(xy => setColor(xy, \"white\"))\n\n\tfor(const xy of grid){\n\t\tconst circle = svgTag({\n\t\t\ttagName: \"circle\",\n\t\t\tattrs: {\n\t\t\t\tid: `circle-${xy.x}-${xy.y}`,\n\t\t\t\tcx: xy.x,\n\t\t\t\tcy: grid.getVerticalOffset(xy.x) + xy.y,\n\t\t\t\tr: dotSizePx / cellSizePx,\n\t\t\t\tfill: \"white\",\n\t\t\t\tstroke: \"none\"\n\t\t\t}\n\t\t})\n\n\t\tcircle.addEventListener(\"mouseover\", () => showNeighbours(xy))\n\t\tcircle.addEventListener(\"mouseout\", () => hideNeighbours(xy))\n\n\t\tsvg.appendChild(circle)\n\t}\n\n\treturn svg\n}","function twoHex(x: number): string {\n\treturn (x > 0xf ? \"\" : \"0\") + x.toString(16)\n}\n\nexport function colorNumberTo3Components(color: number): [r: number, g: number, b: number] {\n\tconst r = (color >> 16) & 0xff,\n\t\tg = (color >> 8) & 0xff,\n\t\tb = (color >> 0) & 0xff\n\treturn [r, g, b]\n}\n\nexport function color3ComponentsToNumber(components: [r: number, g: number, b: number]): number {\n\tconst [r, g, b] = components\n\treturn (r << 16) | (g << 8) | b\n}\n\nexport function rgbToHsl(color: number): number {\n\tlet [r, g, b] = colorNumberTo3Components(color)\n\t// Make r, g, and b fractions of 1\n\tr /= 255\n\tg /= 255\n\tb /= 255\n\n\t// Find greatest and smallest channel values\n\tconst cmin = Math.min(r, g, b),\n\t\tcmax = Math.max(r, g, b),\n\t\tdelta = cmax - cmin\n\tlet h = 0,\n\t\ts = 0,\n\t\tl = 0\n\n\t// Calculate hue\n\t// No difference\n\tif(delta === 0){\n\t\th = 0\n\t} else if(cmax === r){\n\t\t// Red is max\n\t\th = ((g - b) / delta) % 6\n\t} else if(cmax === g){\n\t\t// Green is max\n\t\th = (b - r) / delta + 2\n\t} else {\n\t\t// Blue is max\n\t\th = (r - g) / delta + 4\n\t}\n\n\th = Math.round(h * 60)\n\n\t// Make negative hues positive behind 360Â°\n\tif(h < 0){\n\t\th += 360\n\t}\n\n\t// Calculate lightness\n\tl = (cmax + cmin) / 2\n\n\t// Calculate saturation\n\ts = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1))\n\n\t// Multiply l and s by 100\n\ts = +(s * 100).toFixed(1)\n\tl = +(l * 100).toFixed(1)\n\n\treturn color3ComponentsToNumber([(h / 360) * 255, (s / 100) * 255, (l / 100) * 255])\n}\n\nexport function hslToRgb(hsl: number): number {\n\tlet [h, s, l] = colorNumberTo3Components(hsl)\n\th /= 255\n\ts /= 255\n\tl /= 255\n\tlet r: number, g: number, b: number\n\n\tif(s === 0){\n\t\tr = g = b = l // achromatic\n\t} else {\n\t\tconst q = l < 0.5 ? l * (1 + s) : l + s - l * s\n\t\tconst p = 2 * l - q\n\t\tr = hueToRgb(p, q, h + 1 / 3)\n\t\tg = hueToRgb(p, q, h)\n\t\tb = hueToRgb(p, q, h - 1 / 3)\n\t}\n\n\treturn color3ComponentsToNumber([Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)])\n}\n\nfunction hueToRgb(p: number, q: number, t: number): number {\n\tif(t < 0){\n\t\tt += 1\n\t}\n\tif(t > 1){\n\t\tt -= 1\n\t}\n\tif(t < 1 / 6){\n\t\treturn p + (q - p) * 6 * t\n\t}\n\tif(t < 1 / 2){\n\t\treturn q\n\t}\n\tif(t < 2 / 3){\n\t\treturn p + (q - p) * (2 / 3 - t) * 6\n\t}\n\treturn p\n}\n\nexport function rgbNumberToColorString(rgb: number): string {\n\tconst b = rgb & 0xff\n\trgb >>= 8\n\tconst g = rgb & 0xff\n\trgb >>= 8\n\tconst r = rgb & 0xff\n\n\treturn \"#\" + twoHex(r) + twoHex(g) + twoHex(b)\n}\n\nexport function transformColorHsl(colorRgb: number, transform: (hsl: [number, number, number]) => [number, number, number]): number {\n\tconst transformResult = transform(\n\t\tcolorNumberTo3Components(\n\t\t\trgbToHsl(colorRgb)\n\t\t)\n\t)\n\ttransformResult[0] = Math.max(0, Math.min(255, Math.round(transformResult[0])))\n\ttransformResult[1] = Math.max(0, Math.min(255, Math.round(transformResult[1])))\n\ttransformResult[2] = Math.max(0, Math.min(255, Math.round(transformResult[2])))\n\treturn hslToRgb(\n\t\tcolor3ComponentsToNumber(\n\t\t\ttransformResult\n\t\t)\n\t)\n}","import {Binder, getBinder} from \"common/binder/binder\"\nimport {isRBox, MaybeRBoxed, RBox, unbox, WBox} from \"common/box\"\nimport {ClassNameParts, makeClassname} from \"common/classname\"\nimport {FieldsOfObjectWithType, WritableKeysOf} from \"common/type_utils\"\n\ntype CssStyleAssignableKeys = WritableKeysOf<CSSStyleDeclaration> & FieldsOfObjectWithType<CSSStyleDeclaration, string>\n\ninterface TagDescription<K extends string = string, ThisType = unknown> {\n\treadonly tagName?: K\n\treadonly text?: MaybeRBoxed<string | number>\n\treadonly attrs?: {\n\t\treadonly [attrName: string]: MaybeRBoxed<string | number | undefined | null>\n\t}\n\treadonly on?: {\n\t\treadonly [k in keyof GlobalEventHandlersEventMap]?: (this: ThisType, evt: GlobalEventHandlersEventMap[k]) => void\n\t}\n\treadonly class?: ClassNameParts\n}\n\nexport interface HTMLTagDescription<K extends keyof HTMLElementTagNameMap = keyof HTMLElementTagNameMap> extends TagDescription<K, HTMLElementTagNameMap[K]> {\n\n\treadonly style?: {\n\t\treadonly [k in CssStyleAssignableKeys]?: MaybeRBoxed<string | number>\n\t}\n}\n\nexport type SVGTagDescription<K extends keyof SVGElementTagNameMap = keyof SVGElementTagNameMap> = TagDescription<K, SVGElementTagNameMap[K]>\n\ntype ChildArray = (Element | null | undefined)[] | RBox<(Element | null | undefined)[]>\n\n// typings are weird here, had to cast\nfunction resolveArgs<K>(a?: K | ChildArray, b?: ChildArray): [K, ChildArray | undefined] {\n\tif(!a){\n\t\treturn [{} as K, b]\n\t} else if(Array.isArray(a) || isRBox(a)){\n\t\treturn [{} as K, a as ChildArray]\n\t} else {\n\t\treturn [a as K, b]\n\t}\n}\n\nfunction populateTag<K extends string, T>(tagBase: Element, description: TagDescription<K, T>, children?: ChildArray): Binder | null {\n\tlet binder: Binder | null = null\n\n\tif(description.text){\n\t\tconst text = description.text\n\t\tif(isRBox(text)){\n\t\t\t(binder ||= getBinder(tagBase)).watch<string | number>(text, text => {\n\t\t\t\ttagBase.textContent = text + \"\"\n\t\t\t})\n\t\t}\n\t\ttagBase.textContent = unbox(text) + \"\"\n\t}\n\n\tif(description.on){\n\t\tfor(const evtName in description.on){\n\t\t\tconst handler = description.on[evtName as keyof GlobalEventHandlersEventMap]\n\t\t\t// I don't want to construct elaborat solid type here\n\t\t\t// I know the type will be correct, because it is enforced by function parameter type\n\t\t\t// so just be Any and that's it\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\ttagBase.addEventListener(evtName, handler as any, {passive: true, capture: false})\n\t\t}\n\t}\n\n\tfor(const k in description.attrs){\n\t\tconst v = description.attrs[k]\n\t\tif(isRBox(v)){\n\t\t\t(binder ||= getBinder(tagBase)).watch<string | number | null | undefined>(v, v => {\n\t\t\t\tif(v === null || v === undefined){\n\t\t\t\t\ttagBase.removeAttribute(k)\n\t\t\t\t} else {\n\t\t\t\t\ttagBase.setAttribute(k, v + \"\")\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\tconst vv = unbox(v)\n\t\tif(v !== null && v !== undefined){\n\t\t\ttagBase.setAttribute(k, vv + \"\")\n\t\t}\n\t}\n\n\tif(children){\n\t\tconst setChildren = (children: (Element | null | undefined)[]) => {\n\t\t\tconst childTags = children.filter(x => !!x) as Element[]\n\t\t\tupdateChildren(tagBase, childTags)\n\t\t}\n\n\t\tif(isRBox(children)){\n\t\t\t(binder ||= getBinder(tagBase)).watch(children, children => {\n\t\t\t\tsetChildren(children)\n\t\t\t})\n\t\t}\n\t\tsetChildren(unbox(children))\n\t}\n\n\tif(description.class){\n\t\tbinder = makeClassname(\n\t\t\tbinder,\n\t\t\ttagBase,\n\t\t\tdescription.class,\n\t\t\t// using classList here because on svg elements .className is readonly (in runtime)\n\t\t\tclassname => tagBase.classList.value = classname\n\t\t) || binder\n\t}\n\n\treturn binder\n}\n\nexport function tag(): HTMLDivElement\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(description: HTMLTagDescription<K>): HTMLElementTagNameMap[K]\nexport function tag(children: ChildArray): HTMLDivElement\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(description: HTMLTagDescription<K>, children: ChildArray): HTMLElementTagNameMap[K]\n\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(a?: HTMLTagDescription<K> | ChildArray, b?: ChildArray): HTMLElementTagNameMap[K] {\n\tconst [description, children] = resolveArgs(a, b)\n\n\tconst tagBase = document.createElement(description.tagName || \"div\")\n\n\tlet binder = populateTag(tagBase, description, children)\n\n\tif(description.style){\n\t\tfor(const k in description.style){\n\t\t\tconst v = description.style[k as CssStyleAssignableKeys]\n\t\t\tif(isRBox(v)){\n\t\t\t\t(binder ||= getBinder(tagBase)).watch<string | number>(v, v => {\n\t\t\t\t\ttagBase.style[k] = v + \"\"\n\t\t\t\t})\n\t\t\t}\n\t\t\ttagBase.style[k] = unbox(description.style[k]!) + \"\"\n\t\t}\n\t}\n\n\treturn tagBase as HTMLElementTagNameMap[K]\n}\n\nexport function svgTag(): SVGGElement\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(description: SVGTagDescription<K>): SVGElementTagNameMap[K]\nexport function svgTag(children: ChildArray): SVGGElement\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(description: SVGTagDescription<K>, children: ChildArray): SVGElementTagNameMap[K]\n\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(a?: SVGTagDescription<K> | ChildArray, b?: ChildArray): SVGElementTagNameMap[K] {\n\tconst [description, children] = resolveArgs(a, b)\n\n\tconst tagBase = document.createElementNS(\"http://www.w3.org/2000/svg\", description.tagName || \"g\")\n\n\tif(description.tagName === \"svg\"){\n\t\ttagBase.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\")\n\t}\n\n\tpopulateTag(tagBase, description, children)\n\n\treturn tagBase as SVGElementTagNameMap[K]\n}\n\nfunction updateChildren(parent: Element, newChildren: readonly Element[]): void {\n\tfor(let i = 0; i < newChildren.length; i++){\n\t\tconst childTag = newChildren[i]!\n\t\tconst x = parent.childNodes[i]\n\t\tif(x === childTag){\n\t\t\tcontinue\n\t\t}\n\t\tif(x){\n\t\t\tparent.insertBefore(childTag, x)\n\t\t} else {\n\t\t\tparent.appendChild(childTag)\n\t\t}\n\t}\n\n\twhile(parent.childNodes[newChildren.length]){\n\t\tparent.childNodes[newChildren.length]!.remove()\n\t}\n}\n\n/** Cached renderer for list of elements\n * Won't re-render an element if already has one for the value */\nexport function renderArray<T, K, E extends Element>(src: WBox<T[]>, getKey: (value: T) => K, render: (value: WBox<T>) => E): RBox<E[]>\nexport function renderArray<T, K, E extends Element>(src: RBox<T[]>, getKey: (value: T) => K, render: (value: RBox<T>) => E): RBox<E[]>\nexport function renderArray<T, K, E extends Element>(src: MaybeRBoxed<readonly T[]>, getKey: (value: T) => K, render: (value: MaybeRBoxed<T>) => E): E[]\nexport function renderArray<T, K, E extends Element>(src: MaybeRBoxed<readonly T[]> | WBox<T[]>, getKey: (value: T) => K, render: (value: WBox<T> | T) => E): Node[] | RBox<Node[]> {\n\tif(Array.isArray(src)){\n\t\treturn src.map(el => render(el))\n\t}\n\n\tconst map = new Map<WBox<T>, E>()\n\n\treturn (src as WBox<T[]>).wrapElements(getKey).map(itemBoxes => {\n\t\tconst leftoverBoxes = new Set(map.keys())\n\n\t\tconst result = itemBoxes.map(itemBox => {\n\t\t\tleftoverBoxes.delete(itemBox)\n\t\t\tlet el = map.get(itemBox)\n\t\t\tif(!el){\n\t\t\t\tel = render(itemBox)\n\t\t\t\tmap.set(itemBox, el)\n\t\t\t}\n\t\t\treturn el\n\t\t})\n\n\t\tfor(const oldBox of leftoverBoxes){\n\t\t\tmap.delete(oldBox)\n\t\t}\n\n\t\treturn result\n\t})\n}","import {Binder, getBinder} from \"common/binder/binder\"\nimport {isRBox, MaybeRBoxed, unbox} from \"common/box\"\n\ntype ClassNamePart = MaybeRBoxed<string | null | undefined> | Record<string, MaybeRBoxed<boolean | undefined>>\nexport type ClassNameParts = ClassNamePart | ClassNamePart[]\n\n/** Utility function that assembles classname from parts */\nexport function makeClassname(binder: Binder | null, node: Node, parts: ClassNameParts, callback: (className: string) => void): Binder | null {\n\tconst arr = Array.isArray(parts) ? parts : [parts]\n\tfor(const item of arr){\n\t\tif(isRBox(item)){\n\t\t\t(binder ||= getBinder(node)).watch(item, makeClassnameAndCallTheCallback)\n\t\t} else if(item && typeof(item) === \"object\"){\n\t\t\tfor(const key in item){\n\t\t\t\tconst bool = item[key]\n\t\t\t\tif(isRBox(bool)){\n\t\t\t\t\t(binder ||= getBinder(node)).watch(bool, makeClassnameAndCallTheCallback)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction makeClassnameAndCallTheCallback() {\n\t\tconst result = []\n\t\tfor(const item of arr){\n\t\t\tif(item && typeof(item) === \"object\"){\n\t\t\t\tfor(const classname in item){\n\t\t\t\t\tif(unbox(item[classname])){\n\t\t\t\t\t\tresult.push(classname)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst classname = unbox(item)\n\t\t\t\tif(classname){\n\t\t\t\t\tresult.push(classname)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcallback(result.join(\" \"))\n\t}\n\n\tmakeClassnameAndCallTheCallback()\n\n\treturn binder\n}","import {performeter} from \"common/perfometer\"\nimport {decodeXY, encodeXY, TriangleGrid, XY} from \"sketches/random_rhombus_tilings/triangle_grid\"\n\n// this all is very inoptimal, and can be stored in a few bits\n// but whatever, it's not heavy enough to lag anyway\nexport interface TriangleGridRhombusNode {\n\treadonly leftIsSolid: boolean\n\treadonly rightIsSolid: boolean\n\treadonly bottomIsSolid: boolean\n}\n\nexport type RhombusGrid = TriangleGrid<TriangleGridRhombusNode>\n\n// horisontal places at the bottom\nexport const getEmptyRhombusPattern = (props: {width: number, height: number, length: number}): RhombusGrid => {\n\tconst grid = new TriangleGrid<TriangleGridRhombusNode>({\n\t\t...props,\n\t\tdefaultValue: {\n\t\t\tleftIsSolid: false,\n\t\t\trightIsSolid: false,\n\t\t\tbottomIsSolid: false\n\t\t}\n\t})\n\n\tconst center = grid.getCenterCornerCoords()\n\n\tgrid.exploreFrom(center, xy => {\n\t\tgrid.set(xy, {...grid.get(xy), bottomIsSolid: true})\n\t\treturn [grid.getBottomLeftOf(xy), grid.getBottomRightOf(xy), grid.getBottomOf(xy)]\n\t})\n\n\tgrid.exploreFrom(center, xy => {\n\t\tgrid.set(xy, {...grid.get(xy), leftIsSolid: true})\n\t\treturn [grid.getBottomLeftOf(xy), grid.getTopLeftOf(xy), grid.getTopOf(xy)]\n\t})\n\n\tgrid.exploreFrom(center, xy => {\n\t\tgrid.set(xy, {...grid.get(xy), rightIsSolid: true})\n\t\treturn [grid.getBottomRightOf(xy), grid.getTopRightOf(xy), grid.getTopOf(xy)]\n\t})\n\n\treturn grid\n}\n\nexport const tileWithRandomRhombuses = (grid: RhombusGrid): void => {\n\tconst flippables = new Set<number>([encodeXY(grid.getCenterCornerCoords())])\n\n\tconst updateNeighbours = (sourceXy: XY) => {\n\t\tfor(const xy of grid.getValidNeighbourCoords(sourceXy)){\n\t\t\tconst key = encodeXY(xy)\n\t\t\tif(canFlipAt(xy)){\n\t\t\t\tflippables.add(key)\n\t\t\t} else {\n\t\t\t\tflippables.delete(key)\n\t\t\t}\n\t\t}\n\t}\n\n\tconst isConcaveCorner = (node: TriangleGridRhombusNode) => node.bottomIsSolid && node.leftIsSolid && node.rightIsSolid\n\tconst canFlipAt = (xy: XY) => {\n\t\tconst node = grid.get(xy)\n\t\tif(isConcaveCorner(node)){\n\t\t\treturn true\n\t\t}\n\n\t\tif(node.bottomIsSolid || node.leftIsSolid || node.rightIsSolid){\n\t\t\treturn false\n\t\t}\n\n\t\tconst top = grid.getTopOf(xy)\n\t\tconst left = grid.getBottomLeftOf(xy)\n\t\tconst right = grid.getBottomRightOf(xy)\n\n\t\tconst topIsSolid = !grid.isCoordValid(top) || grid.get(top).bottomIsSolid\n\t\tconst leftIsSolid = !grid.isCoordValid(left) || grid.get(left).rightIsSolid\n\t\tconst rightIsSolid = !grid.isCoordValid(right) || grid.get(right).leftIsSolid\n\n\t\treturn topIsSolid && leftIsSolid && rightIsSolid\n\t}\n\tconst getFlipped = (node: TriangleGridRhombusNode): TriangleGridRhombusNode => {\n\t\tif(isConcaveCorner(node)){\n\t\t\treturn {leftIsSolid: false, rightIsSolid: false, bottomIsSolid: false}\n\t\t}\n\t\treturn {leftIsSolid: true, rightIsSolid: true, bottomIsSolid: true}\n\t}\n\tconst tryMutate = (xy: XY, mutator: (node: TriangleGridRhombusNode) => TriangleGridRhombusNode) => {\n\t\tif(grid.isCoordValid(xy)){\n\t\t\tgrid.set(xy, mutator(grid.get(xy)))\n\t\t}\n\t}\n\tconst flipAt = (xy: XY) => {\n\t\t// console.log(`Flipping ${xy.x}, ${xy.y}`)\n\t\tconst node = grid.get(xy)\n\t\ttryMutate(grid.getBottomLeftOf(xy), node => ({...node, rightIsSolid: !node.rightIsSolid}))\n\t\ttryMutate(grid.getBottomRightOf(xy), node => ({...node, leftIsSolid: !node.leftIsSolid}))\n\t\ttryMutate(grid.getTopOf(xy), node => ({...node, bottomIsSolid: !node.bottomIsSolid}))\n\t\tgrid.set(xy, getFlipped(node))\n\t\tupdateNeighbours(xy)\n\t}\n\n\tfor(let i = 0; i < grid.count * 100; i++){\n\t\tif(flippables.size === 0){\n\t\t\tconsole.log(\"no flip candidate????\")\n\t\t\tbreak\n\t\t}\n\n\t\tperformeter.enterBlock(\"copy set\")\n\t\tconst arr = [...flippables] // very unoptimized, but I don't want to think about it too much right now\n\t\tperformeter.exitEnterBlock(\"flip\")\n\t\tconst xy = decodeXY(arr[Math.floor(Math.random() * arr.length)]!)\n\t\tflipAt(xy)\n\t\tperformeter.exitBlock()\n\t}\n\n}","interface Block {\n\tparent: Block | null\n\tsubblocks: Record<string, Block>\n\ttimeStart: number\n\ttimeSum: number\n\tenterCount: number\n}\n\ninterface BlockToPrint {\n\t\"ms per enter\": number\n\t\"full %\": number\n\t\"parent %\": number\n}\n\nclass Perfometer {\n\n\tprivate root: Block = this.makeBlock(null)\n\tprivate currentBlock: Block = this.root\n\tprivate eventCounters: Record<string, number> = {}\n\n\tprivate makeBlock(parent: Block | null): Block {\n\t\treturn {\n\t\t\tsubblocks: {}, parent: parent,\n\t\t\ttimeStart: -1, timeSum: 0,\n\t\t\tenterCount: 0\n\t\t}\n\t}\n\n\tenterBlock(name: string): void {\n\t\tlet nextBlock = this.currentBlock.subblocks[name]\n\t\tif(!nextBlock){\n\t\t\tnextBlock = this.makeBlock(this.currentBlock)\n\t\t\tthis.currentBlock.subblocks[name] = nextBlock\n\t\t}\n\t\tnextBlock.timeStart = performance.now()\n\t\tnextBlock.enterCount++\n\t\tthis.currentBlock = nextBlock\n\t}\n\n\trecordEvent(name: string): void {\n\t\tthis.eventCounters[name] = (this.eventCounters[name] ?? 0) + 1\n\t}\n\n\texitBlock(): void {\n\t\tthis.currentBlock.timeSum += performance.now() - this.currentBlock.timeStart\n\t\tconst parent = this.currentBlock.parent\n\t\tif(!parent){\n\t\t\tthrow new Error(\"No parent! Blocks are all messed up.\")\n\t\t}\n\t\tthis.currentBlock = parent\n\t}\n\n\texitEnterBlock(name: string): void {\n\t\tthis.exitBlock()\n\t\tthis.enterBlock(name)\n\t}\n\n\tprint(): void {\n\t\tconst table: Record<string, BlockToPrint> = {}\n\t\tlet fullTime = 0\n\t\tfor(const name in this.root.subblocks){\n\t\t\tfullTime += this.root.subblocks[name]!.timeSum\n\t\t}\n\n\t\tthis.forEachBlock((block, name, depth) => {\n\t\t\tname = new Array(depth + 1).join(\"-\") + name\n\t\t\ttable[name] = {\n\t\t\t\t\"parent %\": strip((block.timeSum / block.parent!.timeSum) * 100),\n\t\t\t\t\"full %\": strip((block.timeSum / fullTime) * 100),\n\t\t\t\t\"ms per enter\": strip(block.timeSum / block.enterCount)\n\t\t\t}\n\t\t})\n\n\t\tconsole.table(table)\n\t\tconsole.table(this.eventCounters)\n\t}\n\n\treset(): void {\n\t\tthis.root = this.makeBlock(null)\n\t\tthis.currentBlock = this.root\n\t\tthis.eventCounters = {}\n\t}\n\n\tprivate forEachBlock(callback: (block: Block, name: string, depth: number) => void, start: Block = this.root, currentDepth = 0): void {\n\t\tfor(const name in start.subblocks){\n\t\t\tconst subblock = start.subblocks[name]!\n\t\t\tcallback(subblock, name, currentDepth)\n\t\t\tthis.forEachBlock(callback, subblock, currentDepth + 1)\n\t\t}\n\t}\n\n}\n\nexport const performeter = new Perfometer()\n\nfunction strip(v: number): number {\n\treturn Math.round(v * 100) / 100\n}","import {Queue} from \"common/queue\"\n\ninterface Props<T> {\n\treadonly length: number // left side distance\n\treadonly width: number // right side distance\n\treadonly height: number // top side distance\n\treadonly defaultValue: T\n}\n\nexport interface XY {\n\treadonly x: number\n\treadonly y: number\n}\n\nexport const encodeXY = (xy: XY): number => (xy.y << 0x10) | xy.x\nexport const decodeXY = (key: number): XY => ({x: key & 0xffff, y: (key >> 0x10)})\n\n/** A container for values arranged in triangle pattern.\n * Columns are aligned, each next row is offset by half.\n * Resulting pattern of values, if drawn on 2d plane, will generally look like 6-sided polygon (4-sided, if one of the dimensions is 1, etc)\n *\n * This class also contains utility related arithmetic functions.  */\nexport class TriangleGrid<T> {\n\n\t/** Amount of columns in the grid */\n\treadonly xWidth: number\n\t/** Difference of Y coord between lowest and highest point of grid, in cells.\n\t * May be fractional (because half-cell distance is possible in triangle grid). */\n\treadonly yHeight: number\n\t/** Count of elements in the grid. */\n\treadonly count: number\n\t/** X coord of column that has highest grid point */\n\treadonly topCornerColumnX: number\n\tprivate readonly values: T[][]\n\n\tconstructor(private readonly props: Props<T>) {\n\t\tif(props.width < 1 || props.height < 1 || props.length < 1 || props.width % 1 || props.height % 1 || props.length % 1){\n\t\t\tthrow new Error(`Incorrect grid dimensions: ${props.length} x ${props.width} x ${props.height}`)\n\t\t}\n\t\tthis.xWidth = props.length + props.width - 1\n\t\tthis.yHeight = (this.xWidth / 2) + props.height\n\t\tthis.topCornerColumnX = this.props.width - 1\n\t\tlet count = 0\n\t\tthis.values = new Array(this.xWidth)\n\t\t\t.fill(null)\n\t\t\t.map((_, x) => {\n\t\t\t\tconst height = this.getHeightOfColumnAt(x)\n\t\t\t\tcount += height\n\t\t\t\treturn new Array(height)\n\t\t\t\t\t.fill(null)\n\t\t\t\t\t.map(() => props.defaultValue)\n\t\t\t})\n\t\tthis.count = count\n\t}\n\n\tgetHeightOfColumnAt(x: number): number {\n\t\tlet result = this.props.height\n\t\tif(x < this.props.length && x < this.props.width){\n\t\t\tresult += x\n\t\t} else if((x < this.props.length) !== (x < this.props.width)){\n\t\t\tresult += Math.min(this.props.length, this.props.width) - 1\n\t\t} else {\n\t\t\tresult += this.xWidth - 1 - x\n\t\t}\n\t\treturn result\n\t}\n\n\t* [Symbol.iterator](): IterableIterator<{x: number, y: number, value: T}> {\n\t\tfor(let x = 0; x < this.values.length; x++){\n\t\t\tconst col = this.values[x]!\n\t\t\tfor(let y = 0; y < col.length; y++){\n\t\t\t\tyield{x, y, value: col[y]!}\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @returns difference between y coord of highest point of the whole rhombus and y coords the highest point in this column, in cells */\n\tgetVerticalOffset(x: number): number {\n\t\tconst topPointX = this.props.length - 1\n\t\treturn Math.abs(topPointX - x) / 2\n\t}\n\n\tgetCenterCornerCoords(): XY {\n\t\treturn {\n\t\t\tx: this.topCornerColumnX,\n\t\t\ty: this.props.height - 1\n\t\t}\n\t}\n\n\tgetTopCornerCoords(): XY {\n\t\treturn {\n\t\t\tx: this.topCornerColumnX,\n\t\t\ty: 0\n\t\t}\n\t}\n\n\tgetLeftBottomCornerCoords(): XY {\n\t\treturn {\n\t\t\tx: 0,\n\t\t\ty: this.values[0]!.length - 1\n\t\t}\n\t}\n\n\tgetRightBottomCornerCoords(): XY {\n\t\treturn {\n\t\t\tx: this.values.length - 1,\n\t\t\ty: this.values[this.values.length - 1]!.length - 1\n\t\t}\n\t}\n\n\t/** @returns true if coords are within the grid */\n\tisCoordValid(coords: XY): boolean {\n\t\tif(coords.x < 0 || coords.y < 0){\n\t\t\treturn false\n\t\t}\n\t\tconst col = this.values[coords.x]\n\t\treturn !!col && col.length > coords.y\n\t}\n\n\tprivate throwOnInvalidCoords(coords: XY): void {\n\t\tif(!this.isCoordValid(coords)){\n\t\t\tthrow new Error(`Asked for value at ${coords.x}, ${coords.y}, but container only has ${this.values.length} columns, and this column ${this.values.length > coords.x ? `contains only ${this.values[coords.x]!.length} rows` : \"does not exist\"}.`)\n\t\t}\n\t}\n\n\tget(coords: XY): T {\n\t\tthis.throwOnInvalidCoords(coords)\n\t\treturn this.values[coords.x]![coords.y]!\n\t}\n\n\tset(coords: XY, value: T): void {\n\t\tthis.values[coords.x]![coords.y] = value\n\t}\n\n\t// this method, and others, are just for arithmetics\n\t// they can return a coord that is out of this grid\n\t// use areCoordsValid() to check if this is the case\n\tgetTopLeftOf({x, y}: XY): XY {\n\t\treturn {x: x - 1, y: x <= this.topCornerColumnX ? y - 1 : y}\n\t}\n\n\tgetBottomLeftOf({x, y}: XY): XY {\n\t\treturn {x: x - 1, y: x <= this.topCornerColumnX ? y : y + 1}\n\t}\n\n\tgetTopRightOf({x, y}: XY): XY {\n\t\treturn {x: x + 1, y: x < this.topCornerColumnX ? y : y - 1}\n\t}\n\n\tgetBottomRightOf({x, y}: XY): XY {\n\t\treturn {x: x + 1, y: x < this.topCornerColumnX ? y + 1 : y}\n\t}\n\n\tgetTopOf({x, y}: XY): XY {\n\t\treturn {x, y: y - 1}\n\t}\n\n\tgetBottomOf({x, y}: XY): XY {\n\t\treturn {x, y: y + 1}\n\t}\n\n\tgetValidNeighbourCoords(xy: XY): XY[] {\n\t\treturn [\n\t\t\tthis.getTopOf(xy),\n\t\t\tthis.getBottomOf(xy),\n\t\t\tthis.getTopLeftOf(xy),\n\t\t\tthis.getTopRightOf(xy),\n\t\t\tthis.getBottomLeftOf(xy),\n\t\t\tthis.getBottomRightOf(xy)\n\t\t].filter(xy => this.isCoordValid(xy))\n\t}\n\n\t/** Starting at startingPoint, get next points from explorer; explore while there are points to explore.\n\t * Each point is visited only once. */\n\texploreFrom(startingPoint: XY, explore: (xy: XY) => XY[]): void {\n\t\tconst queue = new Queue<XY>()\n\t\tconst processed = new Set<number>()\n\n\t\tlet next: XY | undefined = startingPoint\n\t\twhile(next){\n\t\t\tconst points = explore(next)\n\t\t\tfor(const xy of points){\n\t\t\t\tif(!this.isCoordValid(xy)){\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst key = encodeXY(xy)\n\t\t\t\tif(!processed.has(key)){\n\t\t\t\t\tprocessed.add(key)\n\t\t\t\t\tqueue.enqueue(xy)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnext = queue.maybeDequeue()\n\t\t}\n\t}\n\n\n}","interface Node<T> {\n\tprev?: Node<T>\n\tvalue: T\n}\n\nexport class Queue<T> {\n\n\tprivate len = 0\n\tprivate headNode?: Node<T>\n\tprivate tailNode?: Node<T>\n\n\tget length(): number {\n\t\treturn this.len\n\t}\n\n\tget head(): T | undefined {\n\t\treturn this.headNode?.value\n\t}\n\n\tget tail(): T | undefined {\n\t\treturn this.tailNode?.value\n\t}\n\n\tenqueue(value: T): void {\n\t\tif(this.headNode && this.tailNode){\n\t\t\tconst oldTail = this.tailNode\n\t\t\tthis.tailNode = {value}\n\t\t\toldTail.prev = this.tailNode\n\t\t} else {\n\t\t\tthis.headNode = this.tailNode = {value}\n\t\t}\n\t\tthis.len++\n\t}\n\n\tdequeue(): T {\n\t\tif(!this.headNode){\n\t\t\tthrow new Error(\"Queue empty, cannot dequeue.\")\n\t\t}\n\t\tconst result = this.headNode.value\n\t\tthis.headNode = this.headNode.prev\n\t\tthis.len--\n\t\treturn result\n\t}\n\n\tmaybeDequeue(): T | undefined {\n\t\tif(!this.headNode){\n\t\t\treturn undefined\n\t\t}\n\t\tconst result = this.headNode.value\n\t\tthis.headNode = this.headNode.prev\n\t\tthis.len--\n\t\treturn result\n\t}\n\n\tclear(): void {\n\t\tthis.len = 0\n\t\tthis.headNode = this.tailNode = undefined\n\t}\n\n\ttoArrayHeadFirst(): T[] {\n\t\tconst result: T[] = new Array(this.len)\n\t\tlet node = this.headNode\n\t\tlet i = 0\n\t\twhile(node){\n\t\t\tresult[i++] = node.value\n\t\t\tnode = node.prev\n\t\t}\n\t\treturn result\n\t}\n\n}"],"names":["$elQpM","parcelRequire","$feb87bdc332a04e8$var$colors","$feb87bdc332a04e8$export$f22da7240b7add18","container","$8HcCf","performeter","enterBlock","grid","$kFpLY","getEmptyRhombusPattern","width","height","length","exitEnterBlock","tileWithRandomRhombuses","color","Math","floor","random","svg","renderRhombuses","horisontalColor","$efatB","transformColorHsl","h","s","l","leftColor","rightColor","cellSize","x","y","style","margin","appendChild","exitBlock","print","$fbf140c75cf60424$export$61227af714afdbe3","props","$aCP3q","svgTag","tagName","setAttribute","xWidth","yHeight","strokeWidth","makePathMaker","expr","offset","getVerticalOffset","max","min","attrs","d","fill","rgbNumberToColorString","stroke","makeLeft","makeRight","makeBottom","value","leftIsSolid","rightIsSolid","bottomIsSolid","exploreFrom","getTopCornerCoords","xy","get","getBottomLeftOf","getBottomRightOf","getRightBottomCornerCoords","getTopOf","getLeftBottomCornerCoords","$fa4a5aa5cdd6ce8e$var$twoHex","toString","$fa4a5aa5cdd6ce8e$export$fdc9c29511f1a926","$fa4a5aa5cdd6ce8e$export$79db3ad3d560d193","components","r","g","b","$fa4a5aa5cdd6ce8e$var$hueToRgb","p","q","t","$fa4a5aa5cdd6ce8e$export$c5ea230d2f55d434","rgb","$fa4a5aa5cdd6ce8e$export$21d90289cdbe307c","colorRgb","transform","transformResult","cmin","cmax","delta","round","abs","toFixed","$fa4a5aa5cdd6ce8e$export$c85ca4f4753af384","hsl","$fa4a5aa5cdd6ce8e$export$29fb7152bd3f781a","$hIDiW","$4c0fbf616468c6ce$var$resolveArgs","a","Array","isArray","$hsvBG","isRBox","$4c0fbf616468c6ce$var$populateTag","tagBase","description","children","binder","text","getBinder","watch","textContent","unbox","on","evtName","handler","addEventListener","passive","capture","k","v","removeAttribute","vv","setChildren","childTags","filter","parent","newChildren","i","childTag","childNodes","insertBefore","remove","$4c0fbf616468c6ce$var$updateChildren","class","$jM5hi","makeClassname","classname","classList","$4c0fbf616468c6ce$export$2b067c6666111485","document","createElement","$4c0fbf616468c6ce$export$e0e99c6b21dfde8d","createElementNS","setAttributeNS","$0d27fb504028ccb8$export$4ded07f8b6ee4cea","node","parts","callback","arr","item","makeClassnameAndCallTheCallback","key","bool","result","push","classname1","join","$625d88d1d12e65ae$export$594265a16ba9ecb7","$6fuK6","TriangleGrid","defaultValue","center","getCenterCornerCoords","set","getBottomOf","getTopLeftOf","getTopRightOf","$625d88d1d12e65ae$export$3483baa73bd0a475","flippables","Set","encodeXY","isConcaveCorner","canFlipAt","top","left","right","topIsSolid","isCoordValid","tryMutate","mutator","flipAt","getFlipped","sourceXy","getValidNeighbourCoords","add","delete","updateNeighbours","count","size","console","log","decodeXY","$6f792b9b35387246$export$e1ee22bc4cc102ea","root","this","makeBlock","currentBlock","eventCounters","subblocks","timeStart","timeSum","enterCount","name","nextBlock","performance","now","recordEvent","Error","table","fullTime","forEachBlock","block","depth","$6f792b9b35387246$var$strip","reset","start","currentDepth","subblock","$6A5Hp","$420e0860c859833c$export$7f5a1f6765a2b466","$420e0860c859833c$export$5fdd4d96ea786aae","$420e0860c859833c$export$f83afd22d38be4aa","constructor","topCornerColumnX","values","map","_","getHeightOfColumnAt","Symbol","iterator","col","topPointX","coords","throwOnInvalidCoords","startingPoint","explore","queue","Queue","processed","next","points","has","enqueue","maybeDequeue","$d86dd992f2068262$export$3dc07afe418952bc","len","head","headNode","tail","tailNode","oldTail","prev","dequeue","clear","undefined","toArrayHeadFirst"],"version":3,"file":"random_rhombus_tilings.413f80a4.js.map"}