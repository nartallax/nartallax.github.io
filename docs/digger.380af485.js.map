{"mappings":"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","sources":["src/sketches/digger/digger.ts","src/sketches/digger/digger_world.ts","src/common/bitmap.ts","src/common/rectangle_deduplicator.ts","src/common/tag.ts","src/common/classname.ts"],"sourcesContent":["import {DiggerWorld, DiggerWorldOptions} from \"./digger_world\"\n\nexport async function main(root: HTMLElement): Promise<void> {\n\tconst config: DiggerWorldOptions = {\n\t\twidthCells: 15,\n\t\theightCells: 10,\n\t\tscreenWidth: document.body.clientWidth,\n\t\tscreenHeight: document.body.clientHeight,\n\t\twallThickness: 0.1,\n\t\tcolors: {\n\t\t\tterrainA: \"#d45500\",\n\t\t\tterrainB: \"#aa4400\",\n\t\t\tterrainEmpty: \"#2b1100\"\n\t\t},\n\t\tdramaticDrawTiming: {\n\t\t\tterrain: 0.5\n\t\t}\n\t}\n\n\tconst world = new DiggerWorld(config)\n\troot.appendChild(world.el)\n\tworld.start()\n\n\tworld.digVertical(0, 0, 5)\n\tworld.digVertical(0, 0, 4)\n\n\t/*\n\tlet rects = [\n\t\t{x: 100, y: 100, w: 100, h: 100},\n\t\t{x: 175, y: 175, w: 100, h: 100},\n\t\t{x: 250, y: 125, w: 100, h: 100}\n\t]\n\n\tlet dedup = new RectanlgeDeduplicator()\n\trects.forEach(rect => dedup.add(rect))\n\tdocument.body.style.cssText = \"position: relative; width: 100vw; height: 100vh; background-color: #000\"\n\tfor(let rect of dedup.getNonIntersectingRects()){\n\t// for(let rect of rects){\n\t\tconsole.log(rect)\n\t\tdocument.body.appendChild(tag({\n\t\t\tstyle: {\n\t\t\t\tposition: \"absolute\",\n\t\t\t\ttop: rect.y + \"px\",\n\t\t\t\tleft: rect.x + \"px\",\n\t\t\t\twidth: rect.w + \"px\",\n\t\t\t\theight: rect.h + \"px\",\n\t\t\t\tbackgroundColor: \"rgba(255, 255, 255, 0.5)\",\n\t\t\t\tboxSizing: \"border-box\",\n\t\t\t\tborder: \"3px solid red\"\n\t\t\t}\n\t\t}))\n\t}\n\t*/\n}","import {Bitmap} from \"common/bitmap\"\nimport {RectanlgeDeduplicator} from \"common/rectangle_deduplicator\"\nimport {tag} from \"common/tag\"\n\nexport interface DiggerWorldOptions {\n\treadonly widthCells: number\n\treadonly heightCells: number\n\treadonly screenHeight: number\n\treadonly screenWidth: number\n\treadonly wallThickness: number\n\treadonly dramaticDrawTiming: {\n\t\treadonly terrain: number\n\t}\n\treadonly colors: {\n\t\treadonly terrainA: string\n\t\treadonly terrainB: string\n\t\treadonly terrainEmpty: string\n\t}\n}\n\nenum GameState {\n\tDramaticDrawTerrain,\n\tRunning\n}\n\nexport class DiggerWorld {\n\n\tprivate readonly terrain: Bitmap\n\treadonly el: HTMLCanvasElement\n\tprivate readonly context: CanvasRenderingContext2D\n\tprivate state: GameState = GameState.Running\n\tprivate dramaticDrawProgress = 0\n\tprivate raf: number | null = null\n\tprivate readonly cellSizePx: number\n\tprivate readonly soilMarginLeft: number\n\t// private readonly soilMarginRight: number\n\t// private readonly soilMarginBottom: number\n\tprivate readonly playgroundWidthPx: number\n\t// private readonly playgroundHeightPx: number\n\n\treadonly invalidatedRects = new RectanlgeDeduplicator()\n\n\tconstructor(private readonly options: DiggerWorldOptions) {\n\n\t\tconst cellSizeByWidth = options.screenWidth / options.widthCells\n\t\tconst cellSizeByHeight = options.screenHeight / (options.heightCells + 1)\n\t\tthis.cellSizePx = Math.floor(Math.min(cellSizeByWidth, cellSizeByHeight))\n\t\tconst hMarginSum = options.screenWidth - (this.cellSizePx * options.widthCells)\n\t\tthis.soilMarginLeft = Math.ceil(hMarginSum / 2)\n\t\t// this.soilMarginRight = hMarginSum - this.soilMarginLeft\n\t\t// this.soilMarginBottom = options.screenHeight - (this.cellSizePx * (options.heightCells + 1))\n\t\tthis.playgroundWidthPx = options.widthCells * this.cellSizePx\n\t\t// this.playgroundHeightPx = options.heightCells * this.cellSizePx\n\n\t\tthis.terrain = new Bitmap((this.cellSizePx ** 2) * options.widthCells * options.heightCells)\n\t\tthis.terrain.setAll()\n\n\t\tthis.el = tag({\n\t\t\ttagName: \"canvas\",\n\t\t\tattrs: {\n\t\t\t\twidth: options.screenWidth,\n\t\t\t\theight: options.screenHeight\n\t\t\t}\n\t\t})\n\t\tconst ctx = this.el.getContext(\"2d\")\n\t\tif(!ctx){\n\t\t\tthrow new Error(\"Browser can't canvas 2d\")\n\t\t}\n\t\tthis.context = ctx\n\n\t\tif(!requestAnimationFrame){\n\t\t\tthrow new Error(\"Browser can't RAF\")\n\t\t}\n\t}\n\n\t// screen coords here\n\tprivate drawTerrainPixelAt(x: number, y: number, isFull: boolean): void {\n\t\tthis.context.fillStyle\n\t\tthis.context.fillStyle = isFull\n\t\t\t? ((y & 0b1111) > 0b1000 ? ((y + x) & 0b1111) > 0b1000 : ((y - x) & 0b1111) < 0b1000)\n\t\t\t\t? this.options.colors.terrainA\n\t\t\t\t: this.options.colors.terrainB\n\t\t\t: this.options.colors.terrainEmpty\n\t\tthis.context.fillRect(x, y, 1, 1)\n\t}\n\n\t// playground coords here\n\tprivate redrawTerrainAt(x: number, y: number): void {\n\t\tthis.drawTerrainPixelAt(\n\t\t\tx + this.soilMarginLeft,\n\t\t\ty + this.cellSizePx,\n\t\t\tthis.terrain.get((y * this.playgroundWidthPx) + x)\n\t\t)\n\t}\n\n\tprivate dramaticDrawInitialTerrain(deltaTime: number): void {\n\t\tconst startAt = this.dramaticDrawProgress\n\n\t\tconst limit = this.options.screenWidth * (this.options.screenHeight - this.cellSizePx)\n\t\tconst drawSpeed = limit / this.options.dramaticDrawTiming.terrain\n\t\tconst pixelsToDraw = Math.floor(deltaTime * drawSpeed)\n\t\tthis.dramaticDrawProgress = Math.min(\n\t\t\tlimit,\n\t\t\tthis.dramaticDrawProgress + pixelsToDraw\n\t\t)\n\n\t\tfor(let i = startAt; i < this.dramaticDrawProgress; i++){\n\t\t\tconst x = (i % this.options.screenWidth)\n\t\t\tconst y = ((i - x) / this.options.screenWidth) + this.cellSizePx\n\t\t\tthis.drawTerrainPixelAt(x, y, true)\n\t\t}\n\n\t\tif(this.dramaticDrawProgress === limit){\n\t\t\tthis.state = GameState.Running\n\t\t\tthis.dramaticDrawProgress = 0\n\t\t}\n\t}\n\n\tinvalidate(x: number, y: number, w: number, h: number): void {\n\t\tthis.invalidatedRects.add({x, y, w, h})\n\t}\n\n\tprivate redrawInvalidatedRectangles(): void {\n\t\tfor(const rect of this.invalidatedRects.getNonIntersectingRects()){\n\t\t\tconst xLim = rect.x + rect.w\n\t\t\tconst yLim = rect.y + rect.h\n\t\t\tfor(let x = rect.x; x < xLim; x++){\n\t\t\t\tfor(let y = rect.y; y < yLim; y++){\n\t\t\t\t\tthis.redrawTerrainAt(x, y)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.invalidatedRects.clear()\n\t}\n\n\tprivate onTick(deltaTime: number): void {\n\t\tswitch(this.state){\n\t\t\tcase GameState.DramaticDrawTerrain:\n\t\t\t\tthis.dramaticDrawInitialTerrain(deltaTime)\n\t\t\t\treturn\n\t\t\tcase GameState.Running:\n\t\t\t\tthis.redrawInvalidatedRectangles()\n\t\t\t\t// draw objects here\n\t\t\t\treturn\n\t\t}\n\t}\n\n\tprivate reset(): void {\n\t\tthis.state = GameState.DramaticDrawTerrain\n\t\tthis.dramaticDrawProgress = 0\n\t}\n\n\tstart(): void {\n\t\tif(this.raf){\n\t\t\tthrow new Error(\"Already started\")\n\t\t}\n\n\t\tthis.reset()\n\n\t\tlet prevTime = 0\n\t\tconst doTick = (time: number) => {\n\t\t\tthis.raf = requestAnimationFrame(doTick)\n\t\t\tconst deltaTime = Math.min(1000 / 15, time - prevTime) / 1000\n\t\t\tprevTime = time\n\t\t\tthis.onTick(deltaTime)\n\t\t}\n\t\tdoTick(prevTime)\n\t}\n\n\tstop(): void {\n\t\tif(!this.raf){\n\t\t\tthrow new Error(\"Not started\")\n\t\t}\n\n\t\tcancelAnimationFrame(this.raf)\n\t\tthis.raf = null\n\t}\n\n\tdigVertical(cellX: number, startCellY: number, endCellY: number): void {\n\t\tif(startCellY > endCellY){\n\t\t\tconst buf = startCellY\n\t\t\tendCellY = startCellY\n\t\t\tstartCellY = buf\n\t\t}\n\t\tconst width = this.cellSizePx * (1 - this.options.wallThickness)\n\t\tconst xStart = (cellX * this.cellSizePx) - (width / 2)\n\t\tconst xEnd = xStart + width\n\t\tconst yStart = startCellY * this.cellSizePx\n\t\tconst yEnd = endCellY * this.cellSizePx\n\t\tfor(let y = yStart; y <= yEnd; y++){\n\t\t\tconst rowStart = (y * this.playgroundWidthPx)\n\t\t\tfor(let x = xStart; x <= xEnd; x++){\n\t\t\t\tthis.terrain.clear(rowStart + x)\n\t\t\t}\n\t\t}\n\t\tthis.invalidate(xStart, yStart, xEnd - xStart, yEnd - yStart)\n\t}\n\n}","/** An optimized array of bits (booleans) */\nexport class Bitmap {\n\tprivate readonly arr: Uint8Array\n\tconstructor(readonly size: number) {\n\t\tif(size < 0){\n\t\t\tthrow new Error(`Expected non-negative as size, got ${size}`)\n\t\t}\n\n\t\tif(size % 8){\n\t\t\tsize = Math.ceil(size / 8) * 8\n\t\t}\n\n\t\tthis.arr = new Uint8Array(size >> 3)\n\t}\n\n\t/** Set bit at selected index to 1 */\n\tset(index: number): void {\n\t\tconst arr = this.arr\n\t\tconst byteIndex = index >> 3\n\t\tarr[byteIndex] = arr[byteIndex]! | (1 << (index & 0b111))\n\t}\n\n\t/** Set bit at selected index to 0 */\n\tclear(index: number): void {\n\t\tconst arr = this.arr\n\t\tconst byteIndex = index >> 3\n\t\tarr[byteIndex] = arr[byteIndex]! & (~(1 << (index & 0b111)))\n\t}\n\n\t/** Get value of bit at index */\n\tget(index: number): boolean {\n\t\treturn (this.arr[index >> 3]! & (1 << (index & 0b111))) !== 0\n\t}\n\n\t/** Set value of all the bits to 1 */\n\tsetAll(): void {\n\t\tthis.arr.fill(0xff)\n\t}\n\n\t/** Set value of all the bits to 0 */\n\tclearAll(): void {\n\t\tthis.arr.fill(0)\n\t}\n\n\t/** @returns sorted array of offsets within [start, start + length] */\n\tgetOffsetsAsNumbers(start: number, length: number): number[] {\n\t\tif(start & 0x7 || length & 0x7){\n\t\t\tthrow new Error(\"Assertion failed, only byte-aligned start/length is supported\")\n\t\t}\n\t\tconst result: number[] = []\n\t\tlet i = 0\n\t\tfor(let byteOffset = 0; byteOffset < (length >> 3); byteOffset++){\n\t\t\tconst byte = this.arr[(start >> 3) + byteOffset]!\n\t\t\tlet mask = 0x1\n\t\t\twhile(mask !== 0x100){\n\t\t\t\tif(byte & mask){\n\t\t\t\t\tresult.push(i)\n\t\t\t\t}\n\t\t\t\ti++\n\t\t\t\tmask <<= 1\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n\n\t/** Sets to 1 every offset that is present in array of offsets and to 0 everything else\n\t * @param offsets sorted array of offsets\n\t * @returns if anything was changed */\n\tsetOffsetsByNumbers(start: number, length: number, offsets: number[]): boolean {\n\t\tif(start & 0x7 || length & 0x7){\n\t\t\tthrow new Error(\"Assertion failed, only byte-aligned start/length is supported\")\n\t\t}\n\t\tlet hasChange = false\n\t\tlet offset = 0\n\t\tlet offsetIndex = 0\n\t\tlet nextNonzeroOffset = offsets[offsetIndex]\n\t\tfor(let byteOffset = 0; byteOffset < (length >> 3); byteOffset++){\n\t\t\tconst origByte = this.arr[(start >> 3) + byteOffset]!\n\t\t\tlet byte = 0\n\t\t\tlet mask = 0x1\n\t\t\twhile(mask !== 0x100){\n\t\t\t\tconst bit = offset === nextNonzeroOffset ? mask : 0\n\t\t\t\thasChange = hasChange || (origByte & mask) !== bit\n\t\t\t\tif(bit){\n\t\t\t\t\tbyte |= mask\n\t\t\t\t\toffsetIndex++\n\t\t\t\t\tnextNonzeroOffset = offsets[offsetIndex]\n\t\t\t\t}\n\t\t\t\toffset++\n\t\t\t\tmask <<= 1\n\t\t\t}\n\t\t\tthis.arr[(start >> 3) + byteOffset] = byte\n\t\t}\n\t\treturn hasChange\n\t}\n\n\t/** Applies bitwise-and operation to this bitmap; saves result in this bitmap\n\t * Expecting other bitmap to be smaller than this one\n\t * @returns if this bitmap was changed\n\t */\n\tand(other: Bitmap, startThis: number): boolean {\n\t\tif(startThis & 0x7){\n\t\t\tthrow new Error(\"Assertion failed, only byte-aligned start/length is supported\")\n\t\t}\n\t\tlet hasChange = false\n\t\tfor(let byteOffset = 0; byteOffset < other.arr.length; byteOffset++){\n\t\t\tconst thisByte = this.arr[(startThis >> 3) + byteOffset]!\n\t\t\tconst otherByte = other.arr[byteOffset]!\n\t\t\tconst result = thisByte & otherByte\n\t\t\thasChange = hasChange || (result !== thisByte)\n\t\t\tthis.arr[(startThis >> 3) + byteOffset] = result\n\t\t}\n\t\treturn hasChange\n\t}\n\n}","interface Rect {\n\treadonly x: number\n\treadonly y: number\n\treadonly w: number\n\treadonly h: number\n}\n\ninterface Span {\n\treadonly a: number\n\treadonly b: number\n}\n\n/** A collection of rectangles.\n * Can return set of rectangles that occupy the same area, but don't intersect.\n * (useful in the case when you need to drop intersections) */\nexport class RectanlgeDeduplicator {\n\n\tprivate readonly rects: Rect[] = []\n\n\tadd(rect: Rect): void {\n\t\tthis.rects.push(rect)\n\t}\n\n\tclear(): void {\n\t\tthis.rects.length = 0\n\t}\n\n\t* getNonIntersectingRects(): IterableIterator<Rect> {\n\t\tfor(const lump of this.groupByLumps()){\n\t\t\tconst splitResult = [...this.splitLump(lump)]\n\t\t\tyield* dropDuplicates(splitResult)\n\t\t}\n\t}\n\n\t/** Packs rectangles into groups.\n\t * Rectangles in different groups never intersect.\n\t * Rectangles in same group has common area (maybe not directly, but through another rectangle) */\n\tprivate* groupByLumps(): IterableIterator<Rect[]> {\n\t\tfor(const vLump of groupByCond(this.rects, intersectionCondition(\"y\", \"h\"))){\n\t\t\tyield* groupByCond(vLump, intersectionCondition(\"x\", \"w\"))\n\t\t}\n\t}\n\n\tprivate* splitLump(lump: Rect[]): IterableIterator<Rect> {\n\t\tconst hBounds = findBoundaries(lump, \"x\", \"w\")\n\t\tconst vBounds = findBoundaries(lump, \"y\", \"h\")\n\t\tfor(const rect of lump){\n\t\t\tfor(const vRect of splitRectByBoundaries(rect, hBounds, \"x\", \"w\")){\n\t\t\t\tyield* splitRectByBoundaries(vRect, vBounds, \"y\", \"h\")\n\t\t\t}\n\t\t}\n\t}\n\n\n}\n\nfunction* groupByCond<T, G>(values: T[], condition: (a: T, b: T, g: G | null) => G | null): IterableIterator<T[]> {\n\tif(values.length === 0){\n\t\treturn\n\t}\n\n\tlet prev = values[0]!\n\tlet pack = [prev]\n\tlet groupData: G | null = null\n\tfor(let i = 1; i < values.length; i++){\n\t\tconst cur = values[i]!\n\t\tgroupData = condition(prev, cur, groupData)\n\t\tif(groupData){\n\t\t\tpack.push(cur)\n\t\t} else {\n\t\t\tyield pack\n\t\t\tpack = [cur]\n\t\t}\n\t\tprev = cur\n\t}\n\tyield pack\n}\n\nfunction intersectionCondition(coordField: \"x\" | \"y\", sizeField: \"w\" | \"h\"): (a: Rect, b: Rect, span: Span | null) => Span | null {\n\treturn (a, b, span) => {\n\t\tconst spanStart = span ? span.a : a[coordField]\n\t\tconst spanEnd = span ? span.b : a[coordField] + a[sizeField]\n\t\tif(b[coordField] + b[sizeField] < spanStart || b[coordField] > spanEnd){\n\t\t\treturn null\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ta: Math.min(spanStart, b[coordField]),\n\t\t\t\tb: Math.max(spanEnd, b[coordField] + b[sizeField])\n\t\t\t}\n\t\t}\n\t}\n}\n\n/** Returns sorted array of starts and ends of rectangles in a dimension\n * Duplicates are possible! */\nfunction findBoundaries(rects: Rect[], coordField: \"x\" | \"y\", sizeField: \"w\" | \"h\"): number[] {\n\tconst result = [] as number[]\n\n\tfor(let i = 0; i < rects.length; i++){\n\t\tconst rect = rects[i]!\n\t\tconst coord = rect[coordField]\n\t\tresult.push(coord, coord + rect[sizeField])\n\t}\n\n\treturn result.sort((a, b) => a - b)\n}\n\n/** Split rectangle by horisontal/vertical boundary, making more rectangles\n * Assumes boundaries are sorted */\nfunction* splitRectByBoundaries(rect: Rect, boundaries: number[], coordField: \"x\" | \"y\", sizeField: \"w\" | \"h\"): IterableIterator<Rect> {\n\tlet prevBound = boundaries[0]!\n\tfor(let j = 1; j < boundaries.length; j++){\n\t\tconst curBound = boundaries[j]!\n\t\tif(curBound === prevBound){\n\t\t\tcontinue\n\t\t}\n\t\tconst coord = rect[coordField]\n\t\tif(prevBound < coord){\n\t\t\tif(curBound > coord){\n\t\t\t\tyield{\n\t\t\t\t\t...rect,\n\t\t\t\t\t[sizeField]: curBound - coord\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst size = rect[sizeField]\n\t\t\tif(curBound < coord + size){\n\t\t\t\tyield{\n\t\t\t\t\t...rect,\n\t\t\t\t\t[coordField]: prevBound,\n\t\t\t\t\t[sizeField]: curBound - prevBound\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tyield{\n\t\t\t\t\t...rect,\n\t\t\t\t\t[coordField]: prevBound,\n\t\t\t\t\t[sizeField]: coord + size - prevBound\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tprevBound = curBound\n\t}\n}\n\nfunction* dropDuplicates(rects: Rect[]): IterableIterator<Rect> {\n\tif(rects.length < 1){\n\t\treturn\n\t}\n\n\trects = rects.sort((a, b) => (a.x - b.x) || (a.y - b.y))\n\tlet prevRect = rects[0]!\n\tyield prevRect\n\tif(rects.length < 2){\n\t\treturn\n\t}\n\n\tfor(let i = 1; i < rects.length; i++){\n\t\tconst rect = rects[i]!\n\t\tif(rect.x === prevRect.x && rect.y === prevRect.y && rect.h === prevRect.h && rect.w === prevRect.w){\n\t\t\tcontinue\n\t\t}\n\t\tyield rect\n\t\tprevRect = rect\n\t}\n}","import {Binder, getBinder} from \"common/binder/binder\"\nimport {isRBox, MaybeRBoxed, RBox, unbox, WBox} from \"common/box\"\nimport {ClassNameParts, makeClassname} from \"common/classname\"\nimport {FieldsOfObjectWithType, WritableKeysOf} from \"common/type_utils\"\n\ntype CssStyleAssignableKeys = WritableKeysOf<CSSStyleDeclaration> & FieldsOfObjectWithType<CSSStyleDeclaration, string>\n\ninterface TagDescription<K extends string = string, ThisType = unknown> {\n\treadonly tagName?: K\n\treadonly text?: MaybeRBoxed<string | number>\n\treadonly attrs?: {\n\t\treadonly [attrName: string]: MaybeRBoxed<string | number | undefined | null>\n\t}\n\treadonly on?: {\n\t\treadonly [k in keyof GlobalEventHandlersEventMap]?: (this: ThisType, evt: GlobalEventHandlersEventMap[k]) => void\n\t}\n\treadonly class?: ClassNameParts\n}\n\nexport interface HTMLTagDescription<K extends keyof HTMLElementTagNameMap = keyof HTMLElementTagNameMap> extends TagDescription<K, HTMLElementTagNameMap[K]> {\n\n\treadonly style?: {\n\t\treadonly [k in CssStyleAssignableKeys]?: MaybeRBoxed<string | number>\n\t}\n}\n\nexport type SVGTagDescription<K extends keyof SVGElementTagNameMap = keyof SVGElementTagNameMap> = TagDescription<K, SVGElementTagNameMap[K]>\n\ntype ChildArray = (Element | null | undefined)[] | RBox<(Element | null | undefined)[]>\n\n// typings are weird here, had to cast\nfunction resolveArgs<K>(a?: K | ChildArray, b?: ChildArray): [K, ChildArray | undefined] {\n\tif(!a){\n\t\treturn [{} as K, b]\n\t} else if(Array.isArray(a) || isRBox(a)){\n\t\treturn [{} as K, a as ChildArray]\n\t} else {\n\t\treturn [a as K, b]\n\t}\n}\n\nfunction populateTag<K extends string, T>(tagBase: Element, description: TagDescription<K, T>, children?: ChildArray): Binder | null {\n\tlet binder: Binder | null = null\n\n\tif(description.text){\n\t\tconst text = description.text\n\t\tif(isRBox(text)){\n\t\t\t(binder ||= getBinder(tagBase)).watch<string | number>(text, text => {\n\t\t\t\ttagBase.textContent = text + \"\"\n\t\t\t})\n\t\t}\n\t\ttagBase.textContent = unbox(text) + \"\"\n\t}\n\n\tif(description.on){\n\t\tfor(const evtName in description.on){\n\t\t\tconst handler = description.on[evtName as keyof GlobalEventHandlersEventMap]\n\t\t\t// I don't want to construct elaborat solid type here\n\t\t\t// I know the type will be correct, because it is enforced by function parameter type\n\t\t\t// so just be Any and that's it\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\ttagBase.addEventListener(evtName, handler as any, {passive: true, capture: false})\n\t\t}\n\t}\n\n\tfor(const k in description.attrs){\n\t\tconst v = description.attrs[k]\n\t\tif(isRBox(v)){\n\t\t\t(binder ||= getBinder(tagBase)).watch<string | number | null | undefined>(v, v => {\n\t\t\t\tif(v === null || v === undefined){\n\t\t\t\t\ttagBase.removeAttribute(k)\n\t\t\t\t} else {\n\t\t\t\t\ttagBase.setAttribute(k, v + \"\")\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\tconst vv = unbox(v)\n\t\tif(v !== null && v !== undefined){\n\t\t\ttagBase.setAttribute(k, vv + \"\")\n\t\t}\n\t}\n\n\tif(children){\n\t\tconst setChildren = (children: (Element | null | undefined)[]) => {\n\t\t\tconst childTags = children.filter(x => !!x) as Element[]\n\t\t\tupdateChildren(tagBase, childTags)\n\t\t}\n\n\t\tif(isRBox(children)){\n\t\t\t(binder ||= getBinder(tagBase)).watch(children, children => {\n\t\t\t\tsetChildren(children)\n\t\t\t})\n\t\t}\n\t\tsetChildren(unbox(children))\n\t}\n\n\tif(description.class){\n\t\tbinder = makeClassname(\n\t\t\tbinder,\n\t\t\ttagBase,\n\t\t\tdescription.class,\n\t\t\t// using classList here because on svg elements .className is readonly (in runtime)\n\t\t\tclassname => tagBase.classList.value = classname\n\t\t) || binder\n\t}\n\n\treturn binder\n}\n\nexport function tag(): HTMLDivElement\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(description: HTMLTagDescription<K>): HTMLElementTagNameMap[K]\nexport function tag(children: ChildArray): HTMLDivElement\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(description: HTMLTagDescription<K>, children: ChildArray): HTMLElementTagNameMap[K]\n\nexport function tag<K extends keyof HTMLElementTagNameMap = \"div\">(a?: HTMLTagDescription<K> | ChildArray, b?: ChildArray): HTMLElementTagNameMap[K] {\n\tconst [description, children] = resolveArgs(a, b)\n\n\tconst tagBase = document.createElement(description.tagName || \"div\")\n\n\tlet binder = populateTag(tagBase, description, children)\n\n\tif(description.style){\n\t\tfor(const k in description.style){\n\t\t\tconst v = description.style[k as CssStyleAssignableKeys]\n\t\t\tif(isRBox(v)){\n\t\t\t\t(binder ||= getBinder(tagBase)).watch<string | number>(v, v => {\n\t\t\t\t\ttagBase.style[k] = v + \"\"\n\t\t\t\t})\n\t\t\t}\n\t\t\ttagBase.style[k] = unbox(description.style[k]!) + \"\"\n\t\t}\n\t}\n\n\treturn tagBase as HTMLElementTagNameMap[K]\n}\n\nexport function svgTag(): SVGGElement\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(description: SVGTagDescription<K>): SVGElementTagNameMap[K]\nexport function svgTag(children: ChildArray): SVGGElement\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(description: SVGTagDescription<K>, children: ChildArray): SVGElementTagNameMap[K]\n\nexport function svgTag<K extends keyof SVGElementTagNameMap = \"g\">(a?: SVGTagDescription<K> | ChildArray, b?: ChildArray): SVGElementTagNameMap[K] {\n\tconst [description, children] = resolveArgs(a, b)\n\n\tconst tagBase = document.createElementNS(\"http://www.w3.org/2000/svg\", description.tagName || \"g\")\n\n\tif(description.tagName === \"svg\"){\n\t\ttagBase.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\")\n\t}\n\n\tpopulateTag(tagBase, description, children)\n\n\treturn tagBase as SVGElementTagNameMap[K]\n}\n\nfunction updateChildren(parent: Element, newChildren: readonly Element[]): void {\n\tfor(let i = 0; i < newChildren.length; i++){\n\t\tconst childTag = newChildren[i]!\n\t\tconst x = parent.childNodes[i]\n\t\tif(x === childTag){\n\t\t\tcontinue\n\t\t}\n\t\tif(x){\n\t\t\tparent.insertBefore(childTag, x)\n\t\t} else {\n\t\t\tparent.appendChild(childTag)\n\t\t}\n\t}\n\n\twhile(parent.childNodes[newChildren.length]){\n\t\tparent.childNodes[newChildren.length]!.remove()\n\t}\n}\n\n/** Cached renderer for list of elements\n * Won't re-render an element if already has one for the value */\nexport function renderArray<T, K, E extends Element>(src: WBox<T[]>, getKey: (value: T) => K, render: (value: WBox<T>) => E): RBox<E[]>\nexport function renderArray<T, K, E extends Element>(src: RBox<T[]>, getKey: (value: T) => K, render: (value: RBox<T>) => E): RBox<E[]>\nexport function renderArray<T, K, E extends Element>(src: MaybeRBoxed<readonly T[]>, getKey: (value: T) => K, render: (value: MaybeRBoxed<T>) => E): E[]\nexport function renderArray<T, K, E extends Element>(src: MaybeRBoxed<readonly T[]> | WBox<T[]>, getKey: (value: T) => K, render: (value: WBox<T> | T) => E): Node[] | RBox<Node[]> {\n\tif(Array.isArray(src)){\n\t\treturn src.map(el => render(el))\n\t}\n\n\tconst map = new Map<WBox<T>, E>()\n\n\treturn (src as WBox<T[]>).wrapElements(getKey).map(itemBoxes => {\n\t\tconst leftoverBoxes = new Set(map.keys())\n\n\t\tconst result = itemBoxes.map(itemBox => {\n\t\t\tleftoverBoxes.delete(itemBox)\n\t\t\tlet el = map.get(itemBox)\n\t\t\tif(!el){\n\t\t\t\tel = render(itemBox)\n\t\t\t\tmap.set(itemBox, el)\n\t\t\t}\n\t\t\treturn el\n\t\t})\n\n\t\tfor(const oldBox of leftoverBoxes){\n\t\t\tmap.delete(oldBox)\n\t\t}\n\n\t\treturn result\n\t})\n}","import {Binder, getBinder} from \"common/binder/binder\"\nimport {isRBox, MaybeRBoxed, unbox} from \"common/box\"\n\ntype ClassNamePart = MaybeRBoxed<string | null | undefined> | Record<string, MaybeRBoxed<boolean | undefined>>\nexport type ClassNameParts = ClassNamePart | ClassNamePart[]\n\n/** Utility function that assembles classname from parts */\nexport function makeClassname(binder: Binder | null, node: Node, parts: ClassNameParts, callback: (className: string) => void): Binder | null {\n\tconst arr = Array.isArray(parts) ? parts : [parts]\n\tfor(const item of arr){\n\t\tif(isRBox(item)){\n\t\t\t(binder ||= getBinder(node)).watch(item, makeClassnameAndCallTheCallback)\n\t\t} else if(item && typeof(item) === \"object\"){\n\t\t\tfor(const key in item){\n\t\t\t\tconst bool = item[key]\n\t\t\t\tif(isRBox(bool)){\n\t\t\t\t\t(binder ||= getBinder(node)).watch(bool, makeClassnameAndCallTheCallback)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction makeClassnameAndCallTheCallback() {\n\t\tconst result = []\n\t\tfor(const item of arr){\n\t\t\tif(item && typeof(item) === \"object\"){\n\t\t\t\tfor(const classname in item){\n\t\t\t\t\tif(unbox(item[classname])){\n\t\t\t\t\t\tresult.push(classname)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst classname = unbox(item)\n\t\t\t\tif(classname){\n\t\t\t\t\tresult.push(classname)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcallback(result.join(\" \"))\n\t}\n\n\tmakeClassnameAndCallTheCallback()\n\n\treturn binder\n}"],"names":["$d1Qaj","parcelRequire","async","$b9439f575dba7083$export$f22da7240b7add18","root","config","widthCells","heightCells","screenWidth","document","body","clientWidth","screenHeight","clientHeight","wallThickness","colors","terrainA","terrainB","terrainEmpty","dramaticDrawTiming","terrain","world","DiggerWorld","appendChild","el","start","digVertical","$1VHh9","$af01df04fee5a419$var$GameState","GameState","$af01df04fee5a419$export$e7d8c2491f2c2a3a","constructor","options","state","Running","dramaticDrawProgress","raf","invalidatedRects","$cZ4Y3","RectanlgeDeduplicator","cellSizeByWidth","cellSizeByHeight","this","cellSizePx","Math","floor","min","hMarginSum","soilMarginLeft","ceil","playgroundWidthPx","Bitmap","setAll","$aCP3q","tag","tagName","attrs","width","height","ctx","getContext","Error","context","requestAnimationFrame","drawTerrainPixelAt","x","y","isFull","fillStyle","fillRect","redrawTerrainAt","get","dramaticDrawInitialTerrain","deltaTime","startAt","limit","drawSpeed","pixelsToDraw","i","invalidate","w","h","add","redrawInvalidatedRectangles","rect","getNonIntersectingRects","xLim","yLim","clear","onTick","DramaticDrawTerrain","reset","prevTime","doTick","time","stop","cancelAnimationFrame","cellX","startCellY","endCellY","xStart","xEnd","yStart","yEnd","rowStart","$665dc4e67c6f8c6a$export$3924f7882b5e2b61","size","arr","Uint8Array","set","index","byteIndex","fill","clearAll","getOffsetsAsNumbers","length","result","byteOffset","byte","mask","push","setOffsetsByNumbers","offsets","hasChange","offset","offsetIndex","nextNonzeroOffset","origByte","bit","and","other","startThis","thisByte","$f426c83f2b66182a$export$4f00dabc81d75002","rects","lump","groupByLumps","splitResult","splitLump","$f426c83f2b66182a$var$dropDuplicates","vLump","$f426c83f2b66182a$var$groupByCond","$f426c83f2b66182a$var$intersectionCondition","hBounds","$f426c83f2b66182a$var$findBoundaries","vBounds","vRect","$f426c83f2b66182a$var$splitRectByBoundaries","values","condition","prev","pack","groupData","cur","coordField","sizeField","a","b","span","spanStart","spanEnd","max","coord","sort","boundaries","prevBound","j","curBound","prevRect","$hIDiW","$4c0fbf616468c6ce$var$resolveArgs","Array","isArray","$hsvBG","isRBox","$4c0fbf616468c6ce$var$populateTag","tagBase","description","children","binder","text","getBinder","watch","textContent","unbox","on","evtName","handler","addEventListener","passive","capture","k","v","removeAttribute","setAttribute","vv","setChildren","childTags","filter","parent","newChildren","childTag","childNodes","insertBefore","remove","$4c0fbf616468c6ce$var$updateChildren","class","$jM5hi","makeClassname","classname","classList","value","$4c0fbf616468c6ce$export$2b067c6666111485","createElement","style","$4c0fbf616468c6ce$export$e0e99c6b21dfde8d","createElementNS","setAttributeNS","$0d27fb504028ccb8$export$4ded07f8b6ee4cea","node","parts","callback","item","makeClassnameAndCallTheCallback","key","bool","classname1","join"],"version":3,"file":"digger.380af485.js.map"}